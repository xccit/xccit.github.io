
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>xccitのblog</title>
    <meta name="author" content="CH_ywx" />
    <meta name="description" content="人生如逆旅,我亦是行人" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/myavatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XCCITのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XCCITのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>xccitのblog</h1>
                <h3>like life | like myself</h3>
                <h5>人生如逆旅,我亦是行人</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/29/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/">
        <h2 class="post-title">浅析数据脱敏</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="浅析数据脱敏"><a href="#浅析数据脱敏" class="headerlink" title="浅析数据脱敏"></a>浅析数据脱敏</h1><h2 id="数据脱敏的概念"><a href="#数据脱敏的概念" class="headerlink" title="数据脱敏的概念"></a>数据脱敏的概念</h2><p><strong>数据脱敏是一种保护敏感信息的技术，通过对原始数据进行变换或修改来隐藏敏感信息，从而在非生产环境中安全使用脱敏后的数据</strong>。以下是对数据脱敏概念的具体介绍：</p>
<ol>
<li><strong>基本概念</strong>：数据脱敏，也称为数据去隐私化或数据变形，是对敏感数据进行有策略的修改或替换的过程，旨在防止未经授权的访问或泄露。这种技术通过特定的规则和策略，将敏感信息转换为看似相似但不含真正敏感细节的数据副本，以供开发、测试、分析或培训等非生产环境使用。</li>
<li><strong>主要类型</strong>：静态数据脱敏通常在数据被提取并复制到非生产环境之前完成一次性脱敏处理，适用于数据外发场景，如提供给第三方或用于测试数据库。动态数据脱敏在数据查询过程中实时进行，当用户访问敏感数据时，系统自动对其进行脱敏处理，适用于直接连接生产数据库的场景。</li>
<li><strong>实现方式</strong>：包括使用脚本手动编写代码进行脱敏，以及利用专业的数据脱敏产品进行自动化脱敏，后者能够提高脱敏效率并节省操作时间。</li>
<li><strong>技术手段</strong>：常见的脱敏技术包括数据替换、屏蔽、加密、混淆和伪装等，这些方法可以根据实际业务场景选择，以满足数据一致性和可用性的需求。</li>
<li><strong>应用场景</strong>：数据脱敏广泛应用于金融、医疗、政府等领域，特别是在涉及个人身份信息、联系方式、银行卡信息等敏感数据的处理中。</li>
<li><strong>重要性</strong>：数据脱敏技术的重要性在于它能够在不降低数据价值的前提下，有效保护个人隐私和商业机密不被泄露。随着大数据和云计算的发展，数据脱敏成为了确保数据安全合规的关键措施之一。</li>
</ol>
<p>总的来说，数据脱敏是一种关键的信息安全技术，它通过多种手段和方法，有效地保护了敏感数据的安全，同时也支持了数据的有效利用。在实施数据脱敏时，需要综合考虑数据一致性、可用性和安全性的要求，选择合适的技术和方法来实现最佳的数据保护效果。</p>
<h2 id="数据脱敏的实现方式"><a href="#数据脱敏的实现方式" class="headerlink" title="数据脱敏的实现方式"></a>数据脱敏的实现方式</h2><h3 id="1-前端脱敏"><a href="#1-前端脱敏" class="headerlink" title="1.前端脱敏"></a>1.前端脱敏</h3><ul>
<li>后端返回的数据已经进行了脱敏处理</li>
<li>后端返回的数据没有脱敏处理,前端使用JavaScript等脚本进行脱敏</li>
</ul>
<h3 id="2-后端脱敏"><a href="#2-后端脱敏" class="headerlink" title="2.后端脱敏"></a>2.后端脱敏</h3><ul>
<li>数据存储时直接进行加密处理,例如AES、RSA等对称&#x2F;非对称加密方式</li>
</ul>
<h2 id="前后端脱敏各自的弊端"><a href="#前后端脱敏各自的弊端" class="headerlink" title="前后端脱敏各自的弊端"></a>前后端脱敏各自的弊端</h2><h3 id="1-前端脱敏的弊端"><a href="#1-前端脱敏的弊端" class="headerlink" title="1.前端脱敏的弊端"></a>1.前端脱敏的弊端</h3><h4 id="1-1-安全性不够"><a href="#1-1-安全性不够" class="headerlink" title="1.1 安全性不够"></a>1.1 安全性不够</h4><p>总的来说,数据脱敏就是对一些敏感数据进行保护,不想被用户看到,但是前端接收到的数据为原文的话,即使JS等脚本进行处理,原来的响应结果也不会变,只是页面显示的东西变了而已,没有实际意义。</p>
<h3 id="2-后端脱敏的弊端"><a href="#2-后端脱敏的弊端" class="headerlink" title="2.后端脱敏的弊端"></a>2.后端脱敏的弊端</h3><h4 id="2-1无法模糊检索"><a href="#2-1无法模糊检索" class="headerlink" title="2.1无法模糊检索"></a>2.1无法模糊检索</h4><p>如何理解检索呢?以查询用户信息为例,假如代入一个条件:<code>匹配手机号前三位为177,后四位为0000</code>的用户,假如是精确匹配,比如我就要<code>手机号为17799890000</code>这个用户的信息,那SQL可以是这样的:</p>
<p>假设自定义一个解密函数为<code>deenc(phone varchar(11))</code>,那么SQL为:</p>
<pre><code class="sql">SELECT username,nick_name,birthday,deenc(phone) as phone FROM t_user WHERE phone = &#39;edcXdejhopacahah89avavsaib&#39;;
</code></pre>
<p>其中,<code>edcXdejhopacahah89avavsaib</code>为前端传入的<code>17799890000</code>这条数据在后端被加密算法加密之后的数据,那么精确匹配的话,可以很快查询到这条数据,流程图可以是这样的:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240928235655491.png" alt="image-20240928235655491"></p>
<p>但是,精确匹配只需要后端的业务层对前端传过来的数据进行加密,交给dao去数据库精确匹配即可,只需要查询这一条数据,并且将手机号解密后返回给前端,如果是模糊查询呢?比如<code>匹配手机号前三位为177,后四位为0000</code>的用户,那么正常的SQL应该是:</p>
<pre><code class="sql">SELECT username,nick_name,birthday,deenc(phone) as phone FROM t_user WHERE deenc(phone) like &#39;177%0000&#39;;
</code></pre>
<p>首先,需要将所有数据进行解密之后再匹配<code>177%0000</code>,假设数据库中有10000w条数据,那么我们会解密到什么时候呢?这是一道送命题。我们必须在<code>数据安全</code>与<code>用户体验</code>中做出选择。所以在数据脱敏这个问题上,基本上不会有公司做得很好,经过撞库等操作用户敏感信息被泄漏的事情并不少,这里就不点名了,<code>d(懂)d(的)d(都)d(懂)</code></p>
<h2 id="优雅实现数据脱敏"><a href="#优雅实现数据脱敏" class="headerlink" title="优雅实现数据脱敏"></a>优雅实现数据脱敏</h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" style="color: #00a596">Java开发技巧</a>
        </span>
        
    </div>
    <a href="/2024/09/29/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/19/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/">
        <h2 class="post-title">Spring快速入门2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Spring快速入门2"><a href="#Spring快速入门2" class="headerlink" title="Spring快速入门2"></a>Spring快速入门2</h1><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="构造方法赋值"><a href="#构造方法赋值" class="headerlink" title="构造方法赋值"></a>构造方法赋值</h3><h4 id="1-更改实体类"><a href="#1-更改实体类" class="headerlink" title="1.更改实体类"></a>1.更改实体类</h4><p><code>Person.java</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private Cat cat;
&#125;
</code></pre>
<h4 id="2-更改配置文件"><a href="#2-更改配置文件" class="headerlink" title="2.更改配置文件"></a>2.更改配置文件</h4><pre><code class="xml">    &lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
        &lt;constructor-arg name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Jackson&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;cat&quot; ref=&quot;cat&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
</code></pre>
<h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><pre><code class="java">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person)context.getBean(&quot;person2&quot;);
        System.out.println(person);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919132608571.png" alt="image-20240919132608571"></p>
<blockquote>
<p>Tips:配置文件中,使用构造方法赋值必须确保有该构造方法,如添加了带参构造,必须添加无参构造,不然会报错。另外<code>name</code>属性可以去掉,确保value或ref的顺序与构造方法参数的顺序一致,如顺序不一致,也会导致因类型转换问题报错,此时可以使用<code>index</code>属性解决,只需要在<code>constructor-arg</code>标签中添加<code>index</code>,属性,值为该参数所在的索引,例如(int id,String name),此时id的索引应该为0,name应该为1</p>
</blockquote>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="复杂类型注入"><a href="#复杂类型注入" class="headerlink" title="复杂类型注入"></a>复杂类型注入</h3><blockquote>
<p>使用<code>ref</code>可以给单个引用类型赋值,如果一个对象与另外一个对象是<code>一对多</code>的关系,需要使用到集合又该怎么赋值呢?</p>
</blockquote>
<h4 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h4><pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;母&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;lucky&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;公&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919133548992.png" alt="image-20240919133548992"></p>
<h4 id="2-Map"><a href="#2-Map" class="headerlink" title="2.Map"></a>2.Map</h4><pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope 作用域"></a>scope 作用域</h3><blockquote>
<p>Spring管理的bean的作用域需要使用scope属性来进行管理,分别有四个值:</p>
<ul>
<li>singleton:单例模式,通过ioc获取的bean唯一。(默认值)</li>
<li>prototype:多例模式，通过ioc获取的bean不唯一。</li>
<li>request:请求有效，在一次Http请求中有效。</li>
<li>session:会话有效，在一个用户会话内有效。</li>
</ul>
<p><code>request</code>和<code>session</code>仅适用于web项目,多数情况下使用<code>singleton</code>和<code>prototype</code></p>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>分别配置一个scope为<code>singleton</code>和<code>prototype</code>的bean</p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
Person person1 = (Person) context.getBean(&quot;person&quot;);
System.out.println(person == person1);

Person person2 = (Person) context.getBean(&quot;person2&quot;);
Person person3 = (Person) context.getBean(&quot;person2&quot;);
System.out.println(person2 == person3);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919135020404.png" alt="image-20240919135020404"></p>
<blockquote>
<p>测试可得:单例模式下,获取的bean唯一,而多例模式下,获取的bean确实不唯一。并且创建对象的方式也不同,singleton会在加载配置文件时创建bean,而prototype在获取bean时才会创建bean,之后每一次获取时都会创建一次,通过无参构造创建。</p>
</blockquote>
<h2 id="Spring继承机制"><a href="#Spring继承机制" class="headerlink" title="Spring继承机制"></a>Spring继承机制</h2><p>Spring的继承主要在对象层面,可以实现子对象对父对象的属性继承,不同于Java层面的是,Java是子类对父类结构的继承。</p>
<p><code>Java层面继承:</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919191459330.png" alt="image-20240919191459330"></p>
<p><code>Spring层面继承:</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919191909763.png" alt="image-20240919191909763"></p>
<h3 id="使用继承机制"><a href="#使用继承机制" class="headerlink" title="使用继承机制"></a>使用继承机制</h3><p><code>配置两个Person</code></p>
<pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot; parent=&quot;person&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><code>测试代码</code></p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        Person person1 = (Person) context.getBean(&quot;person2&quot;);
        System.out.println(person);
        System.out.println(person1);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919194047771.png" alt="image-20240919194047771"></p>
<blockquote>
<p>使用<code>parent</code>属性可快速为bean指定父对象。</p>
<p>值得一提的是，在Spring中，即使该类没有继承自<code>parent</code>指定的对象对应的类,属性值依然可以继承。只要确保该类定义时,与<code>parent</code>指定的bean所对应的类属性结构一致,才可以继承,否则会报错。</p>
</blockquote>
<p><code>测试使用不同类型的bean继承该bean是否可以</code></p>
<p><code>User.java</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
&#125;
</code></pre>
<p><code>applicationContext.xml</code></p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot; parent=&quot;person2&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919195900842.png" alt="image-20240919195900842"></p>
<p><code>tips:</code>如果User定义的属性结构中,<code>不包含</code>Person的某个属性,则继承会<code>失败</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919200052736.png" alt="image-20240919200052736"></p>
<pre><code class="java">9月 19, 2024 8:00:28 下午 org.springframework.context.support.AbstractApplicationContext refresh
警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;user&#39; defined in class path resource [applicationContext.xml]: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;user&#39; defined in class path resource [applicationContext.xml]: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1740)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1454)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:599)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)
    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:85)
    at io.xccit.App.main(App.java:38)
Caused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:209)
    at org.springframework.beans.AbstractNestablePropertyAccessor.processLocalProperty(AbstractNestablePropertyAccessor.java:430)
    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:278)
    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:269)
    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:104)
    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:79)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1737)
    ... 13 more
</code></pre>
<p>但是如果<code>User有自己的专属属性</code>,并且<code>还有Person的所有属性</code>,这是可以成功的</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    private String address;
&#125;
</code></pre>
<pre><code class="java">Person(id=1, name=Kitty, age=18, gender=女, cat=[Cat(id=1, name=mimi, age=3, gender=母, breed=英国短毛猫), Cat(id=2, name=lucky, age=3, gender=公, breed=英国短毛猫)], others=&#123;address=北京市, phone=18099565699, email=123456@qq.com&#125;)
User(id=1, name=Kitty, age=18, gender=女, cat=[Cat(id=1, name=mimi, age=3, gender=母, breed=英国短毛猫), Cat(id=2, name=lucky, age=3, gender=公, breed=英国短毛猫)], others=&#123;address=北京市, phone=18099565699, email=123456@qq.com&#125;, address=null)
</code></pre>
<blockquote>
<p>上面为输出结果,截图截不全,所以直接贴文字</p>
</blockquote>
<h2 id="Spring依赖机制"><a href="#Spring依赖机制" class="headerlink" title="Spring依赖机制"></a>Spring依赖机制</h2><blockquote>
<p>描述<code>对象(bean)</code>与<code>对象(bean)</code>之间的依赖关系,被依赖的bean先在ioc容器中创建,依赖其他bean的bean后创建</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">@Data
//@NoArgsConstructor
//@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    public Person()&#123;
        System.out.println(&quot;Person() invoked&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Data
//@NoArgsConstructor
//@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    private String address;
    public User()&#123;
        System.out.println(&quot;User() invoked)&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
User user = (User) context.getBean(&quot;user&quot;);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919205414582.png" alt="image-20240919205414582"></p>
<blockquote>
<p>无依赖关系时,按照xml中的配置自上而下依次创建</p>
</blockquote>
<h3 id="使用依赖机制"><a href="#使用依赖机制" class="headerlink" title="使用依赖机制"></a>使用依赖机制</h3><pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot; depends-on=&quot;person&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>使用<code>depends-on</code>属性来指定该bean依赖于哪个bean,被依赖的bean会先创建</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919210407806.png" alt="image-20240919210407806"></p>
<p>这次<code>person</code>的创建优先级高于<code>user</code></p>
<h2 id="Spring配置的命名空间"><a href="#Spring配置的命名空间" class="headerlink" title="Spring配置的命名空间"></a>Spring配置的命名空间</h2><blockquote>
<p>使用命名空间可以<code>简化配置文件</code>中bean与bean之间<code>关系的配置</code>以及<code>依赖注入</code></p>
</blockquote>
<h3 id="p名称空间"><a href="#p名称空间" class="headerlink" title="p名称空间"></a>p名称空间</h3><p>要使用p命名空间,首先xml的dtd中必须要有p命名空间的<code>schema</code></p>
<pre><code class="xml-dtd">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
</code></pre>
<p>完整的<code>xml-dtd</code>应该为:</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="使用p名称空间"><a href="#使用p名称空间" class="headerlink" title="使用p名称空间"></a>使用p名称空间</h3><pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot; p:id=&quot;1&quot; p:name=&quot;mimi&quot; p:age=&quot;3&quot; p:gender=&quot;母&quot; p:breed=&quot;英国短毛猫&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; p:id=&quot;1&quot; p:name=&quot;张三&quot; p:cat-ref=&quot;cat&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;person1&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>上面的案例中,person对应的bean的属性值与person1一致,只不过<code>赋值方法</code>不同,一个使用了property,一个使用了p名称空间</p>
</blockquote>
<p><code>直接加载配置文件,不做其他操作:</code></p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240920151821582.png" alt="image-20240920151821582"></p>
<p><code>创建了两个Person对象</code></p>
<p>如需获取属性,直接获取该bean打印即可</p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
Person person1 = (Person) context.getBean(&quot;person1&quot;);
System.out.println(person);
System.out.println(person1);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240920152018747.png" alt="image-20240920152018747"></p>
<p><code>完全一致</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ffa2c4">SSM</a>
        </span>
        
    </div>
    <a href="/2024/09/19/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/17/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">
        <h2 class="post-title">Spring快速入门</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/17
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h1><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring框架是一个开源的J2EE应用程序框架，由Rod Johnson发起，旨在解决开发者在J2EE开发中遇到的常见问题。它提供了一个轻量级的容器，通过<code>控制反转IoC</code>和<code>面向切面编程（AOP)</code>等核心机制，简化了企业级应用程序的开发。Spring框架不仅限于服务器端开发，而且由于其简单性、可测试性和松耦合性，可以应用于绝大部分Java应用中。</p>
<h2 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h2><p>Spring框架的主要特性包括：</p>
<ol>
<li>‌<strong>轻量级</strong>‌：Spring的核心jar包很小，对代码几乎无污染，提供了轻量级的解决方案。</li>
<li>‌<strong>面向接口编程</strong>‌：Spring底层设计遵循面向接口的开发规范，通过接口定义实现类的行为，提高了代码的灵活性和可扩展性。</li>
<li>‌<strong>AOP支持</strong>‌：Spring提供了强大的AOP支持，使得开发者可以方便地处理日志、事务、权限验证等公共功能。</li>
<li>‌<strong>整合其他框架</strong>‌：Spring可以单独使用，也可以与其他框架（如Struts、Hibernate等）无缝集成，降低了使用难度。</li>
<li>‌<strong>降低API使用难度</strong>‌：Spring对Java EE API进行了封装，使其更易于使用，同时也降低了开发难度。</li>
</ol>
<p>Spring框架的架构包括多个模块，如Core模块提供基本的IOC和AOP功能，Data模块提供持久化数据的访问框架，而Web模块则提供Web应用程序的基础功能和编程框架。Spring框架的工作流程涉及嵌入容器中运行，通过定义Bean和配置XML文件来实现应用程序的启动和Bean的管理。</p>
<p>总的来说，Spring框架通过其简洁的设计、强大的功能和灵活的扩展性，成为了Java企业级应用开发的首选框架之一‌。</p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><code>IOC</code>全称<code>Inverse Of Control</code>,中文翻译为<code>控制反转</code>,是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（<code>Dependency Injection</code>，依赖注入）来实现的。</p>
<h3 id="IoC初体验"><a href="#IoC初体验" class="headerlink" title="IoC初体验"></a>IoC初体验</h3><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><ul>
<li><p>创建Maven工程</p>
</li>
<li><p>引入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;6.1.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>创建实体类</p>
<pre><code class="java">@Data
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
&#125;
</code></pre>
</li>
<li><p>简化实体类操作</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;version&gt;1.18.34&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>Spring配置文件</p>
<p><code>applicationContext.xml</code></p>
<p>命名并不是统一的,有些开发会习惯性的命名为<code>spring.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;lucy&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
        &lt;property name=&quot;gender&quot; value=&quot;女&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">public class App &#123;
    public static void main( String[] args ) &#123;
/*        Person person = new Person();
        person.setId(1);
        person.setName(&quot;张三&quot;);
        person.setAge(20);
        person.setGender(&quot;男&quot;);
        System.out.println(person);*/
        //ioc
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>使用<code>ApplicationContext</code>来new实现类<code>ClassPathXmlApplicationContext</code>来加载配置文件,还有<code>FileSystemXmlApplicationContext</code>可加载非本项目的配置文件,只需全路径即可。获取Bean的方式也并不是只有使用配置文件的<code>id属性值</code>一种,还可以直接用<code>Xxx.class</code></p>
</blockquote>
</li>
</ul>
<p>输出结果:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240917224205210.png" alt="image-20240917224205210"></p>
<h4 id="2-配置文件详解"><a href="#2-配置文件详解" class="headerlink" title="2.配置文件详解"></a>2.配置文件详解</h4><ul>
<li><p><code>beans</code>:根标签,管理所有的bean</p>
</li>
<li><p><code>bean</code>:配置每一个需要被Spring管理的bean</p>
<ul>
<li><p><code>name</code>:给bean起一个名字,值不唯一</p>
</li>
<li><p><code>id</code>属性:给bean起一个名字,值唯一</p>
</li>
<li><p><code>class</code>属性:bean的全路径</p>
</li>
<li><p><code>property</code>标签:bean的属性</p>
<p>​	<code>name</code>: 属性名</p>
<p>​	<code>value</code>:属性值,只能写基本类型及字符串String</p>
<p>​	<code>ref</code>:属性值,可以写引用类型,引用另外一个bean</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-复杂类型配置"><a href="#3-复杂类型配置" class="headerlink" title="3.复杂类型配置"></a>3.复杂类型配置</h4><h5 id="新建Cat类"><a href="#新建Cat类" class="headerlink" title="新建Cat类"></a>新建Cat类</h5><pre><code class="java">@Data
public class Cat &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private String breed;
&#125;
</code></pre>
<h5 id="改变Person"><a href="#改变Person" class="headerlink" title="改变Person"></a>改变Person</h5><pre><code class="java">@Data
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private Cat cat;
&#125;
</code></pre>
<h5 id="配置person和cat"><a href="#配置person和cat" class="headerlink" title="配置person和cat"></a>配置person和cat</h5><pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;母&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;lucy&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = context.getBean(Person.class);
System.out.println(person);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240917225416370.png" alt="image-20240917225416370"></p>
<h3 id="Ioc底层原理"><a href="#Ioc底层原理" class="headerlink" title="Ioc底层原理"></a>Ioc底层原理</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>1.读取配置文件,解析</li>
<li>2.通过反射机制实例化配置文件中的bean</li>
</ul>
<h4 id="手写Ioc"><a href="#手写Ioc" class="headerlink" title="手写Ioc"></a>手写Ioc</h4><h5 id="1-创建Maven工程"><a href="#1-创建Maven工程" class="headerlink" title="1.创建Maven工程"></a>1.创建Maven工程</h5><h5 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2.引入依赖"></a>2.引入依赖</h5><pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;version&gt;1.18.34&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- dom4j 解析xml --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dom4j&lt;/groupId&gt;
  &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="3-复制上一份代码中的配置文件及实体类"><a href="#3-复制上一份代码中的配置文件及实体类" class="headerlink" title="3.复制上一份代码中的配置文件及实体类"></a>3.复制上一份代码中的配置文件及实体类</h5><h5 id="4-定义ApplicationContext接口"><a href="#4-定义ApplicationContext接口" class="headerlink" title="4.定义ApplicationContext接口"></a>4.定义ApplicationContext接口</h5><pre><code class="java">public interface ApplicationContext &#123;
    
&#125;
</code></pre>
<h5 id="5-定义ClassPathXmlApplicationContext实现类"><a href="#5-定义ClassPathXmlApplicationContext实现类" class="headerlink" title="5.定义ClassPathXmlApplicationContext实现类"></a>5.定义ClassPathXmlApplicationContext实现类</h5><pre><code class="java">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;

&#125;
</code></pre>
<h5 id="6-定义-实现方法"><a href="#6-定义-实现方法" class="headerlink" title="6.定义&#x2F;实现方法"></a>6.定义&#x2F;实现方法</h5><pre><code class="java">public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;
    private String configPath;
    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();
    public ClassPathXmlApplicationContext() &#123;
        //指定默认的配置文件
        this.configPath = &quot;spring02-custom-ioc\\src\\main\\resources\\applicationContext.xml&quot;;
        analysisConfig(this.configPath);
    &#125;
    public ClassPathXmlApplicationContext(String configPath) &#123;
        analysisConfig(configPath);
    &#125;

    /**
     * 解析配置文件，将配置文件中的bean标签解析为bean对象，并放入beanMap中
     * @param configPath 配置文件
     */
    public void analysisConfig(String configPath)&#123;
        SAXReader saxReader = new SAXReader();
        try &#123;
            Document document = saxReader.read(configPath);
            Element root = document.getRootElement();
            Iterator&lt;Element&gt; elementIterator = root.elementIterator();
            while(elementIterator.hasNext())&#123;
                Element element = elementIterator.next();
                if(&quot;bean&quot;.equals(element.getName()))&#123;
                    String id = element.attributeValue(&quot;id&quot;);
                    String className = element.attributeValue(&quot;class&quot;);
                    Class&lt;?&gt; clazz = Class.forName(className);
                    Object bean = clazz.newInstance();
                    //给对象赋值
                    Iterator&lt;Element&gt; propertyIterator = element.elementIterator();
                    while(propertyIterator.hasNext())&#123;
                        Element propertyElement = propertyIterator.next();
                        String propertyName = propertyElement.attributeValue(&quot;name&quot;);
                        String propertyValue = propertyElement.attributeValue(&quot;value&quot;);
                        Field field = clazz.getDeclaredField(propertyName);
                        String methodName = &quot;set&quot; + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
                        Method declaredMethod = clazz.getDeclaredMethod(methodName, field.getType());
                        String typeName = field.getType().getName();
                        //如果该对象的property有ref属性,则赋值为对应的bean对象
                        if(propertyElement.attributeValue(&quot;ref&quot;) != null)&#123;
                            Object refBean = beanMap.get(propertyElement.attributeValue(&quot;ref&quot;));
                            declaredMethod.invoke(bean, refBean);
                            continue;
                        &#125;
                        //调用set方法, 将属性值注入到对象中
                        if (typeName.equals(&quot;int&quot;) || typeName.equals(&quot;java.lang.Integer&quot;))&#123;
                            declaredMethod.invoke(bean, Integer.parseInt(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;java.lang.String&quot;))&#123;
                            declaredMethod.invoke(bean, propertyValue);
                        &#125;
                        if (typeName.equals(&quot;boolean&quot;) || typeName.equals(&quot;java.lang.Boolean&quot;))&#123;
                            declaredMethod.invoke(bean, Boolean.parseBoolean(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;double&quot;) || typeName.equals(&quot;java.lang.Double&quot;))&#123;
                            declaredMethod.invoke(bean, Double.parseDouble(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;float&quot;) || typeName.equals(&quot;java.lang.Float&quot;))&#123;
                            declaredMethod.invoke(bean, Float.parseFloat(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;long&quot;) || typeName.equals(&quot;java.lang.Long&quot;))&#123;
                            declaredMethod.invoke(bean, Long.parseLong(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;char&quot;) || typeName.equals(&quot;java.lang.Character&quot;))&#123;
                            declaredMethod.invoke(bean, propertyValue.charAt(0));
                        &#125;
                        if (typeName.equals(&quot;short&quot;) || typeName.equals(&quot;java.lang.Short&quot;))&#123;
                            declaredMethod.invoke(bean, Short.parseShort(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;byte&quot;) || typeName.equals(&quot;java.lang.Byte&quot;))&#123;
                            declaredMethod.invoke(bean, Byte.parseByte(propertyValue));
                        &#125;
                    &#125;
                    beanMap.put(id,bean);
                &#125;
            &#125;
        &#125; catch (DocumentException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchFieldException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    @Override
    public Object getBean(String beanId) &#123;
        return beanMap.get(beanId);
    &#125;
&#125;
</code></pre>
<h5 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h5><pre><code class="java">public class App &#123;
    public static void main( String[] args ) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240918212023333.png" alt="image-20240918212023333"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #00bcd4">SSM</a>
        </span>
        
    </div>
    <a href="/2024/09/17/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/02/SpringAI%E5%88%9D%E4%BD%93%E9%AA%8C/">
        <h2 class="post-title">SpringAI初体验</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SpringAI简介"><a href="#SpringAI简介" class="headerlink" title="SpringAI简介"></a>SpringAI简介</h1><p>Spring AI是一个<code>基于Spring Boot</code>框架的AI应用开发工具包。它旨在简化A!模型的集成和部署，使开发者能够更快地构建智能应用。SpringAI提供了一系列功能，包括对话管理、自然语言处理、图像识别等，其中<code>ChatGPT</code>就是其中之一。</p>
<h1 id="SpringAI环境搭建"><a href="#SpringAI环境搭建" class="headerlink" title="SpringAI环境搭建"></a>SpringAI环境搭建</h1><h2 id="1-创建SpringBoot工程"><a href="#1-创建SpringBoot工程" class="headerlink" title="1.创建SpringBoot工程"></a>1.创建SpringBoot工程</h2><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902223807549.png" alt="image-20240902223807549"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902223945095.png" alt="image-20240902223945095"></p>
<blockquote>
<p><code>Tips:</code>SpringBoot3必须使用JDK17及以上版本,请求接口需要使用到WEB模块,所以导入Spring Web,我们选择使用ChatGpt,所以导入openai依赖</p>
</blockquote>
<p>创建完成的项目依赖应该如下:</p>
<pre><code class="xml">    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;spring-ai.version&gt;1.0.0-M2&lt;/spring-ai.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<blockquote>
<p><code>Tips:</code>由于阿里等maven仓库未能及时更新SpringAI的依赖,所以Maven配置阿里仓库等国内源会导致依赖下载失败,可以使用maven公共仓库以及配合科学上网解决此问题</p>
</blockquote>
<h2 id="2-接口申请"><a href="#2-接口申请" class="headerlink" title="2.接口申请"></a>2.接口申请</h2><p>由于ChatGpt需要使用<code>科学上网</code>外加<code>$</code>支付,可以使用国内的OpenAI中转站,这里使用<a target="_blank" rel="noopener" href="https://api.xty.app/">https://api.xty.app/</a></p>
<h3 id="2-1-注册"><a href="#2-1-注册" class="headerlink" title="2.1 注册"></a>2.1 注册</h3><p>使用<code>https://api.xty.app/register?aff=iz9s</code>链接进行注册,可以获得<code>1.0$</code>的免费额度</p>
<h3 id="2-2-生成令牌"><a href="#2-2-生成令牌" class="headerlink" title="2.2 生成令牌"></a>2.2 生成令牌</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902224738699.png" alt="image-20240902224738699"></p>
<p>点击此处使用账户送的<code>1.0$</code>申请令牌即可</p>
<h2 id="3-接口开发"><a href="#3-接口开发" class="headerlink" title="3.接口开发"></a>3.接口开发</h2><h3 id="3-1-配置AI参数"><a href="#3-1-配置AI参数" class="headerlink" title="3.1 配置AI参数"></a>3.1 配置AI参数</h3><pre><code class="yaml">spring:
  # ChatGPT配置
  ai:
    openai:
      api-key: 你申请到的key
      base-url: https://api.xty.app
      chat:
        options:
          model: gpt-3.5-turbo
</code></pre>
<p>关于配置,可以在<a target="_blank" rel="noopener" href="https://api.xty.app/%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">https://api.xty.app/查看使用教程</a></p>
<p>关于SpringAI的更多配置,可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/chat/openai-chat.html#_sample_controller%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B%E5%8F%8A%E9%85%8D%E7%BD%AE">https://docs.spring.io/spring-ai/reference/api/chat/openai-chat.html#_sample_controller进行查看及配置</a></p>
<h3 id="3-2-接口定义"><a href="#3-2-接口定义" class="headerlink" title="3.2 接口定义"></a>3.2 接口定义</h3><pre><code class="java">/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/2
 * &lt;p&gt;AI测试控制器&lt;/p&gt;
 */
@CrossOrigin
@RestController
public class OpenAIController &#123;
    private final OpenAiChatModel chatModel;

    @Autowired
    public OpenAIController(OpenAiChatModel chatModel) &#123;
        this.chatModel = chatModel;
    &#125;
    @GetMapping(&quot;/ai/generate&quot;)
    public Map generate(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;) String message) &#123;
        return Map.of(&quot;generation&quot;, chatModel.call(message));
    &#125;

    @GetMapping(value = &quot;/ai/generateStream&quot;,produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; generateStream(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;) String message) &#123;
//        Prompt prompt = new Prompt(new UserMessage(message));
        Flux&lt;String&gt; stream = chatModel.stream(message);
        return stream;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>以上代码在官网都可以copy的到,稍加改动即可</p>
</blockquote>
<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902225103791.png" alt="image-20240902225103791"></p>
<h2 id="4-接入前端测试"><a href="#4-接入前端测试" class="headerlink" title="4.接入前端测试"></a>4.接入前端测试</h2><h3 id="4-1-创建Vue项目"><a href="#4-1-创建Vue项目" class="headerlink" title="4.1 创建Vue项目"></a>4.1 创建Vue项目</h3><pre><code class="javascript">npm create vite
填写项目信息,选择vue项目,javascript语言
cd /项目根路径
npm run dev
</code></pre>
<h3 id="4-2-删除项目自带的组件及css等无关配置"><a href="#4-2-删除项目自带的组件及css等无关配置" class="headerlink" title="4.2 删除项目自带的组件及css等无关配置"></a>4.2 删除项目自带的组件及css等无关配置</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902225259851.png" alt="image-20240902225259851"></p>
<h3 id="4-3-改造App-vue"><a href="#4-3-改造App-vue" class="headerlink" title="4.3 改造App.vue"></a>4.3 改造App.vue</h3><pre><code class="javascript">&lt;script setup&gt;
  import &#123;ref&#125; from &#39;vue&#39;
  const message = ref(&#39;&#39;)
  const result = ref([])
  const sendMessage = ()=&gt;&#123;
    //事件流请求
    let source = new EventSource(`http://localhost:8080/ai/generateStream?message=$&#123;message.value&#125;`)
    source.onmessage = (event)=&gt;&#123;
      result.value.push(event.data)
    &#125;
  &#125;
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;小昕AI v1.0&lt;/h1&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;historyWindow&quot;&gt;
      &lt;span v-for=&quot;(text,index) in result&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;text&#125;&#125;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;chatWindow&quot;&gt;
      &lt;textarea class=&quot;chatText&quot; v-model=&quot;message&quot;&gt;
      &lt;/textarea&gt;
      &lt;button class=&quot;chatSend&quot; @click=&quot;sendMessage()&quot;&gt;发&amp;nbsp;&amp;nbsp;送&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  *&#123;
    margin: 0px;
    padding: 0px;
  &#125;
  .container&#123;
    display: flex;
    width: 100%;
    height: 100vh;
    flex-direction: row;
    flex-wrap: wrap;
  &#125;
  .historyWindow&#123;
    //background-color: aqua;
    width: 100%;
    height: 600px;
    border: 3px solid aqua;
    border-radius: 5px;
    color: black;
  &#125;
  .chatWindow&#123;
    display: flex;
    //background-color: #646cff;
    width: 100%;
    height: 100px;
  &#125;
  .chatText&#123;
    width: 80%;
    height: 100%;
  &#125;
  .chatSend&#123;
    width: 10%;
    height: 50px;
    flex: content;
    margin-top: 50px;
    color: aqua;
    font-size: 30px;
  &#125;
&lt;/style&gt;
</code></pre>
<h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><pre><code class="javascript">npm run dev
</code></pre>
<blockquote>
<p><code>Tips:</code>接入的模型为ChatGpt3.5,可以进行聊天对话,资料查询等等功能</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902230707068.png" alt="image-20240902230707068"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SpringAI/" style="color: #03a9f4">SpringAI</a>
        </span>
        
    </div>
    <a href="/2024/09/02/SpringAI%E5%88%9D%E4%BD%93%E9%AA%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/01/%E5%88%9D%E5%A7%8Bredis/">
        <h2 class="post-title">初识redis</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><blockquote>
<p>Redis是使用C语言开发的一款高性能开源键值对非关系性数据库,数据间没有必然的关联关系,内部采用单线程机制进行工作,有高性能、高并发的特性,可进行数据持久化,数据灾难恢复</p>
</blockquote>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>通过百度网盘分享的文件：Redis-x64-3.2.100.msi<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/11co2TyJzmNyj4dw8NJWHIg?pwd=1209">https://pan.baidu.com/s/11co2TyJzmNyj4dw8NJWHIg?pwd=1209</a><br>提取码：1209</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a target="_blank" rel="noopener" href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/">Install Redis on Linux | Docs</a></p>
<h1 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h1><h2 id="作为缓存使用"><a href="#作为缓存使用" class="headerlink" title="作为缓存使用"></a>作为缓存使用</h2><ul>
<li>业务功能设计,例如:秒杀、促销、抢票等</li>
<li>高频访问数据,例如:在线人数统计</li>
</ul>
<h2 id="系统功能优化"><a href="#系统功能优化" class="headerlink" title="系统功能优化"></a>系统功能优化</h2><ul>
<li>单服务器升级集群</li>
<li>Session、Token管理</li>
</ul>
<h1 id="Redis基本使用"><a href="#Redis基本使用" class="headerlink" title="Redis基本使用"></a>Redis基本使用</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre><code class="shell">select 0 //选择0号数据库(0-15)
dbsize //当前数据库key的总数
exists key //查看某个key是否存在,存在返回1,不存在返回0
keys * //获取当前数据库所有键
get key //获取key对应的value
type key //获取件对应的value的类型
del key //删除指定的key:value
expire key num //key:键 num:数字 给key设置n秒后过期
ttl key //查看key剩余的过期时间
persist key //去除key的过期时间
</code></pre>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ul>
<li>bind: 绑定redis自身的服务器的ip，不是绑定访问过来的IP地址，默认是127.0.0.1，即只允许本地访问</li>
<li>port:  指定redis监听端口，默认为6379</li>
<li>requirepass:  设置连接密码，客户端连接时，需要密码认证</li>
<li>protected-mode: 开启保护模式(默认开启)，若开启且bind未配置密码也未设置，redis只接受本机连接</li>
<li>timeout: 设置客户端连接时的超时时间，单位为秒，默认值：0代表禁用，永不关闭</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis中的数据类型针对的是value的值,key永远是字符串</p>
<h3 id="1-string字符串"><a href="#1-string字符串" class="headerlink" title="1.string字符串"></a>1.string字符串</h3><pre><code class="shell">set key value //存储
get key //获取
del key //删除

mset key1 value1 key2 value2 ……  //存储多个
mget key1 key2 …… //获取多个

setex key seconds value //设置秒
setex key milliseconds value //设置毫秒
</code></pre>
<h3 id="2-Hash哈希类型"><a href="#2-Hash哈希类型" class="headerlink" title="2.Hash哈希类型"></a>2.Hash哈希类型</h3><pre><code class="shell">hset key field value //存储 hset user username zhangsan
hget key field  //获取一个  hget user username
hgetall key //获取全部
hdel key field  //删除 hdel user username
</code></pre>
<h3 id="3-list列表类型"><a href="#3-list列表类型" class="headerlink" title="3.list列表类型"></a>3.list列表类型</h3><ul>
<li>采用双向链表linkedlist,支持重复元素</li>
<li>可以添加一个元素到列表的头部或者尾部</li>
</ul>
<pre><code class="shell">lpush key value //将元素添加到列表头部
rpush key value //将元素添加到列表尾部
lrange key start end //获取start-end索引位置的元素
lrange key 0 -1 //获取所有元素
lpop key //删除最左边的元素
rpop //删除最右边的元素
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240901102627970.png" alt="image-20240901102627970"></p>
<h3 id="4-set集合类型"><a href="#4-set集合类型" class="headerlink" title="4.set集合类型"></a>4.set集合类型</h3><h4 id="4-1无序集合"><a href="#4-1无序集合" class="headerlink" title="4.1无序集合"></a>4.1无序集合</h4><blockquote>
<p>不允许重复,元素无序</p>
</blockquote>
<pre><code class="shell">sadd key value //存储
sadd key value1,value2... //存储多个
smembers key //获取该key的所有元素
srem key value //删除该key的value
</code></pre>
<h4 id="4-2有序集合"><a href="#4-2有序集合" class="headerlink" title="4.2有序集合"></a>4.2有序集合</h4><blockquote>
<p>元素不允许重复,但元素有序,每个元素都会关联一个double类型的分数</p>
</blockquote>
<pre><code class="shell">zadd key score value //存储
zrange key start end //获取start至end之间的元素
zrange key 0 -1 withscores //获取全部并带着分数
zrem key value //删除该key的value
</code></pre>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><blockquote>
<p>默认的数据持久化方式,不需要配置,在一定的时间间隔中,检测key的变化,最终持久化数据</p>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>redis.conf:</code></p>
<ul>
<li>save 500 1  :900秒后至少有1个key发生改变就持久化一次</li>
<li>save 200 10  :300秒后至少有10key发生改变就持久化一次</li>
<li>save 100 100 :50秒后至少有10000个key发生改变就持久化一次</li>
</ul>
<blockquote>
<p>注意:修改配置文件后需要重启redis服务</p>
</blockquote>
<h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><blockquote>
<p>通过日志记录对的方式,记录每一条命令的操作。每次操作后持久化数据。</p>
</blockquote>
<p><code>redis.conf</code></p>
<ul>
<li>appendonly no（关闭）</li>
<li>appendonly yes（开启）</li>
<li>appendfsync always  每次操作都持久化</li>
<li>appendfsync everysec  每隔一秒持久化（默认值）</li>
<li>appendfsync no  不持久化</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Redis/" style="color: #ff7d73">Redis</a>
        </span>
        
    </div>
    <a href="/2024/09/01/%E5%88%9D%E5%A7%8Bredis/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/13/vite-vue3%E5%B0%81%E8%A3%85request-js/">
        <h2 class="post-title">vite+vue3封装request.js</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="vite-vue3封装request-js"><a href="#vite-vue3封装request-js" class="headerlink" title="vite+vue3封装request.js"></a>vite+vue3封装request.js</h1><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><ul>
<li><p>1.安装node.js</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere (nodejs.org)</a></p>
</blockquote>
<p>尽量安装LTS版本</p>
</li>
<li><p>2.创建工程</p>
<blockquote>
<p>npm init vite@latest</p>
<p>选择<code>vue</code></p>
<p>选择<code>3</code></p>
<p>输入项目名称，例如<code>my-vue3-project</code></p>
<p>选择存放项目的路径</p>
<p>cd my-vue3-project<br>npm run dev</p>
</blockquote>
</li>
</ul>
<h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h2><h3 id="1-安装axios"><a href="#1-安装axios" class="headerlink" title="1.安装axios"></a>1.安装axios</h3><pre><code class="shell">npm install axios
</code></pre>
<h3 id="2-封装request-js"><a href="#2-封装request-js" class="headerlink" title="2.封装request.js"></a>2.封装request.js</h3><p>在<code>src</code>下新建<code>utils</code>文件夹，新建<code>request.js</code></p>
<pre><code class="javascript">import axios from &quot;axios&quot;
import &#123; ElMessage &#125; from &#39;element-plus&#39;;
import &#123;useTokenStore&#125; from &quot;@/store/token.js&quot;;

const baseURL = &#39;/api&#39;
// 创建axios实例
const service = axios.create(&#123;
    baseURL: baseURL, // 设置默认的 API 地址，url = baseURL + url（使用proxy代理时此处可不写）
    timeout: 5000,	// 设置请求超时时间
&#125;)

//请求拦截器
service.interceptors.request.use(
    (config)=&gt;&#123;
        let tokenStore = useTokenStore()
        if (tokenStore.token)&#123;
            config.headers.Authorization = tokenStore.token
        &#125;
        return config
    &#125;,
    (error)=&gt;&#123;
        ElMessage.error(error.message)
        return Promise.reject(error)
    &#125;
)

// 响应拦截器
service.interceptors.response.use(
    // 响应数据，2xx 范围内的状态码都会触发该函数。
    (response) =&gt; &#123;
        if (response.data.code == 200)&#123;
            const &#123; status, data &#125; = response;
            if (status === 200) &#123;
                const &#123; code, message &#125; = data;
                // 根据后端返回的自定义状态码 code 进行错误信息提示（根据具体需求确定是否需要书写）
                switch (code) &#123;
                    case 401:
                        ElMessage(&#123; message: message, type: &#39;error&#39; &#125;)
                        return Promise.reject(data);
                    default:
                        return data;
                &#125;
            &#125;
        &#125;else&#123;
            return Promise.reject(response.data)
        &#125;
    &#125;,
    (error) =&gt; &#123;
        if (error.response) &#123;
            const &#123; status, data &#125; = error.response;
            ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // if (status === 500) &#123;
            //     ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // &#125; else if (status === 401) &#123;
            //     ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // &#125; else &#123;
            //     ElMessage(&#123; message: data.message || &#39;未知错误！&#39;, type: &#39;error&#39; &#125;)
            // &#125;
        &#125; else if (error.request) &#123;
            // 请求已发送，未收到响应
            ElMessage(&#123; message: error.message || &#39;请求已发送，未收到响应信息！&#39;, type: &#39;error&#39; &#125;)
        &#125; else &#123;
            // 其他错误
            ElMessage(&#123; message: error.message, type: &#39;error&#39; &#125;)
        &#125;
        // 若简写，上面代码可省略，只写此一行
        return Promise.reject(error);
    &#125;
)

export default service;
</code></pre>
<h3 id="3-使用pinia进行状态管理"><a href="#3-使用pinia进行状态管理" class="headerlink" title="3.使用pinia进行状态管理"></a>3.使用pinia进行状态管理</h3><p>后端接口一般都是需要验证token来进行访问的：</p>
<p>新建<code>src/store/token.js</code></p>
<pre><code class="javascript">import &#123;defineStore&#125; from &#39;pinia&#39;
import &#123;ref&#125; from &quot;vue&quot;;

export const useTokenStore = defineStore(&#39;token&#39;,()=&gt;&#123;
    const token = ref(&#39;&#39;)
    const setToken = (newToken)=&gt;&#123;
        token.value = newToken
    &#125;

    const removeToken = ()=&gt;&#123;
        token.value = &#39;&#39;
    &#125;

    return &#123;token,setToken,removeToken&#125;
&#125;)
</code></pre>
<p>这里定义了pinia状态管理的js文件，但是我们需要在<code>main.js</code>中使用pinia</p>
<pre><code class="javascript">import &#123;createPinia&#125; from &#39;pinia&#39;
const pinia = createPinia()

const app = createApp(App)
app.use(ElementPlus,&#123;locale&#125;)
    .use(router)
    .use(pinia)
app.mount(&#39;#app&#39;)
</code></pre>
<p>忽略掉ElementPlus与locale以及router,并且在上面的<code>request.js</code>文件中，同样引入了<code>token.js</code>,这是为了方便将登录后获得的token传给请求拦截器，在请求头<code>Headers</code>中加入token</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>定义接口文件<code>api/user.js</code></p>
<pre><code class="javascript">import request from &#39;@/utils/request.js&#39;

const baseUrl = &#39;/user&#39;
export const register = (params)=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/register`,
        params: params
    &#125;)
&#125;

export const login = (params)=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/login`,
        params: params
    &#125;)
&#125;

export const logout = ()=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/logout`
    &#125;)
&#125;
</code></pre>
<p>定义接口文件<code>category.js</code></p>
<pre><code class="javascript">import request from &#39;@/utils/request.js&#39;

const baseUrl = &#39;/category&#39;
export const list = ()=&gt;&#123;
    return request(&#123;
        method: &#39;GET&#39;,
        url: `$&#123;baseUrl&#125;`
    &#125;)
&#125;

export const insert = (category)=&gt;&#123;
    return request(&#123;
        method: &#39;POST&#39;,
        url:`$&#123;baseUrl&#125;`,
        data: category
    &#125;)
&#125;

export const update = (category)=&gt;&#123;
    return request(&#123;
        method: &#39;PUT&#39;,
        url: `$&#123;baseUrl&#125;`,
        data: category
    &#125;)
&#125;

export const remove = (id)=&gt;&#123;
    return request(&#123;
        method: &#39;DELETE&#39;,
        url: `$&#123;baseUrl&#125;/$&#123;id&#125;`
    &#125;)
&#125;

export const detail = (id)=&gt;&#123;
    return request(&#123;
        method: &#39;GET&#39;,
        url: `$&#123;baseUrl&#125;/detail`,
        params: id
    &#125;)
&#125;
</code></pre>
<p>登录后发送请求，浏览器控制台：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/QQ_1723528176173.png" alt="QQ_1723528176173" style="zoom:150%;" />

<p><code>前端新手，若有不对欢迎指正</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="color: #00a596">前端开发</a>
        </span>
        
    </div>
    <a href="/2024/08/13/vite-vue3%E5%B0%81%E8%A3%85request-js/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/08/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">
        <h2 class="post-title">Java基础笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="JAVA快速入门"><a href="#JAVA快速入门" class="headerlink" title="JAVA快速入门"></a>JAVA快速入门</h1><p>注:个人笔记，适合新手学习，适合对Java SE的复习，请勿转载,如有错误请指教，虚心改正 </p>
<p><code>QQ: 1571466236</code></p>
<p><code>wechat: lucky_all_time_max</code></p>
<h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>准备环境：JAVA 8（JDK8） Windows 10系统</p>
<p>本教程使用的是Java8，在2018年企业开始陆续使用JAVA11，到后面13,16都在用，但8是最稳定的一个版本，新版本特性我辞职后没有好好学习，只能使用我所掌握的jdk8</p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Oracle官网</a>下载JDK安装包：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908231449599.png" alt="image-20210908231449599"></p>
<p>大家可以看到的是页面打开有很多版本，我们需要根据自己所使用的系统进行选择，windows系统使用*.exe*后缀的安装包即可，但在此之前确定好自己的系统是32bit还是64bit，一般家用电脑都是64bit，下载<strong>windows x64</strong>的版本。</p>
<p>安装步骤很简单且我电脑已经装了多个版本，就不一一给大家截图演示，直接在安装界面点击next或者下一步即可。</p>
<h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><h4 id="1-配置JAVA-HOME"><a href="#1-配置JAVA-HOME" class="headerlink" title="1.配置JAVA_HOME"></a>1.配置JAVA_HOME</h4><p>windows10:</p>
<p>桌面此电脑鼠标右击—-&gt;属性—-&gt;高级系统设置—-&gt;环境变量</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908232718137.png" alt="image-20210908232718137"></p>
<p>这里注意：上面的是用户变量，切换用户后就会失效，下面的是系统变量，我们要在系统变量中设置环境变量</p>
<p>新建：JAVA_HOME</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908232848228.png" alt="image-20210908232848228"></p>
<p>变量值是安装JAVA的路径，安装时注意看好路径，一般默认都在C盘下的Program Files\Java</p>
<p>找到Path环境变量：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908233118938.png" alt="image-20210908233118938"></p>
<h4 id="2-配置Path"><a href="#2-配置Path" class="headerlink" title="2.配置Path"></a>2.配置Path</h4><p>将</p>
<p><strong>%JAVA_HOME%\bin</strong></p>
<p><strong>%JAVA_HOME%\jre\bin</strong></p>
<p>加入到Path，将这两条变量值上移到置顶</p>
<p>确定</p>
<h4 id="3-配置CLASSPATH"><a href="#3-配置CLASSPATH" class="headerlink" title="3.配置CLASSPATH"></a>3.配置CLASSPATH</h4><p>找到ClASSPATH，没有就新建：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908233317079.png" alt="image-20210908233317079"></p>
<p>变量值：</p>
<pre><code class="java">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
</code></pre>
<p>完成后确定，退出来</p>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>使用组合键WIN+R，输入CMD，回车</p>
<p>在命令窗口分别输入：</p>
<p>java -version        </p>
<p>javac</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908234658646.png" alt="image-20210908234658646"></p>
<p>这两条命令都有输出的时候代表环境配置成功。</p>
<h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>新建文件 Hello.java</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, world!&quot;);
    &#125;
&#125;
</code></pre>
<p>它的意思是在屏幕上打印出 Hello,world！ 这行文本内容。</p>
<p>Java源码本质上是一个文本文件，我们需要先用<code>javac</code>把<code>Hello.java</code>编译成字节码文件<code>Hello.class</code>，然后，用<code>java</code>命令执行这个字节码文件：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908235215588.png" alt="image-20210908235215588"></p>
<p>在Hello.java文件目录中运行cmd，使用命令javac Hello.java</p>
<p>如果源代码无误，上述命令不会有任何输出，而当前目录下会产生一个<code>Hello.class</code>文件：</p>
<p>使用命令java Hello</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908235622515.png" alt="image-20210908235622515"></p>
<p>出现上面结果就很完美，第一个程序运行完成！</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><strong>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</strong></p>
<p><strong>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</strong></p>
<p><strong>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</strong></p>
<h3 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h3><p>Java程序的入口是<code>main</code>方法，而<code>main</code>方法可以接受一个命令行参数，它是一个<code>String[]</code>数组。</p>
<p>这个命令行参数由JVM接收用户输入并传给<code>main</code>方法：</p>
<p>Java的<strong>main</strong>方法后面小括号中有<strong>String[] args</strong>,可以传入参数使用，比如我们写如下代码:</p>
<pre><code class="java">public class Hello&#123;
    public static void main(String[] args)&#123;
        for(String arg : args)&#123;
            if(arg.equals(&quot;-version&quot;))&#123;
                System.out.print(&quot;v1.0&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211007165158004-16335967296361.png" alt="image-20211007165158004"></p>
<p>对程序编译过后运行，带上一个**”-version”<strong>参数，程序做出了反应，将我们设置好的</strong>“v1.0”**打印了出来</p>
<h2 id="JAVA程序基础"><a href="#JAVA程序基础" class="headerlink" title="JAVA程序基础"></a>JAVA程序基础</h2><p>因为Java是面向对象的语言，一个程序的基本单位就是<code>class</code>，<code>class</code>是关键字，这里定义的<code>class</code>名字就是<code>Hello</code>：</p>
<pre><code class="java">public class Hello&#123;
    
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p>类名要求：</p>
<ul>
<li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>习惯以大写字母开头</li>
</ul>
<p>要注意遵守命名习惯，好的类命名：</p>
<ul>
<li>Hello</li>
<li>NoteBook</li>
<li>VRPlayer</li>
</ul>
<p>不好的类命名：</p>
<ul>
<li>hello</li>
<li>Good123</li>
<li>Note_Book</li>
<li>_World</li>
</ul>
<p><strong>注意：</strong></p>
<p><code>public</code>是访问修饰符，表示该<code>class</code>是公开的。</p>
<p>不写<code>public</code>，也能正确编译，但是这个类将无法从命令行执行。</p>
<p>在<code>class</code>内部，可以定义若干方法（method）：</p>
<pre><code class="java">public class Hello&#123;
    public static void main(String[] args)&#123;
        
    &#125;
&#125;
</code></pre>
<p>这里的main便是一个<strong>方法</strong>，也称为<strong>函数</strong></p>
<p>方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。</p>
<p>这里的方法名是<code>main</code>，返回值是<code>void</code>，表示没有任何返回值。</p>
<p>我们注意到<code>public</code>除了可以修饰<code>class</code>外，也可以修饰方法。而关键字<code>static</code>是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组。</p>
<p>方法名也有命名规则，命名和<code>class</code>一样，但是首字母小写：</p>
<p>好的方法命名：</p>
<ul>
<li>main</li>
<li>goodMorning</li>
<li>playVR</li>
</ul>
<p>不好的方法命名：</p>
<ul>
<li>Main</li>
<li>good123</li>
<li>good_morning</li>
<li>_playVR</li>
</ul>
<p>在方法内部，语句才是真正的执行代码。<strong>Java的每一行语句必须以分号结束：</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, world!&quot;); // 语句
    &#125;
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p>&#x2F;&#x2F;语句  ：这是Java中的<strong>注释</strong>，代码用于电脑读取，相当于人给电脑的指令，但&#x2F;&#x2F;后面的内容供人阅读，在企业中通常存在程序员离职的情况，这个时候注释的作用就体现出来了，有注释的代码看起来是清晰的，在另一名程序员接手项目的时候可以很快上手。</p>
<p>注释类型:</p>
<pre><code class="java">//单行注释
/*
  1
  2
  3
  多行注释
*/
/**
@Author Xccit
Javadoc
*/
</code></pre>
<h2 id="JAVA变量和数据类型"><a href="#JAVA变量和数据类型" class="headerlink" title="JAVA变量和数据类型"></a>JAVA变量和数据类型</h2><p>变量的概念，我们在小学时候就接触到了，解方程做应用题的时候：</p>
<p>设某某为x，x是一个不确定的量，所以称为变量</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int x = 100; // 定义int类型变量x，并赋予初始值100
        System.out.println(x); // 打印该变量的值
    &#125;
&#125;
</code></pre>
<p>试着运行以上代码：</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>引用类型最常见的就是String</p>
<p>在以后的学习中，会使用形形色色的变量，各种数据类型都会使用</p>
<h4 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h4><p>在Java中，多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围，例如：</p>
<pre><code class="java">if (...) &#123; // if开始
    ...
    while (...) &#123; // while 开始
        ...
        if (...) &#123; // if开始
            ...
        &#125; // if结束
        ...
    &#125; // while结束
    ...
&#125; // if结束
</code></pre>
<p>只要正确地嵌套这些{ }，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子：</p>
<pre><code class="java">&#123;
    ...
    int i = 0; // 变量i从这里开始定义
    ...
    &#123;
        ...
        int x = 1; // 变量x从这里开始定义
        ...
        &#123;
            ...
            String s = &quot;hello&quot;; // 变量s从这里开始定义
            ...
        &#125; // 变量s作用域到此结束
        ...
        // 注意，这是一个新的变量s，它和上面的变量同名，
        // 但是因为作用域不同，它们是两个不同的变量:
        String s = &quot;hi&quot;;
        ...
    &#125; // 变量x和s作用域到此结束
    ...
&#125; // 变量i作用域到此结束
</code></pre>
<p>定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。</p>
<h4 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h4><p>常量定义：</p>
<pre><code class="java">final int i = 1;
</code></pre>
<p>上面的语句使用关键字<strong>final</strong>定义了一个int类型的常量 i</p>
<p>常量定义后不可改变其值（不可重新赋值）；</p>
<h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>Java提供了两种变量类型：基本类型和引用类型</p>
<p>基本类型包括整型，浮点型，布尔型，字符型。</p>
<p>变量可重新赋值，等号是赋值语句，不是数学意义的等号。</p>
<p>常量在初始化后不可重新赋值，使用常量便于理解程序意图。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="整型运算"><a href="#整型运算" class="headerlink" title="整型运算"></a>整型运算</h4><p>整形运算整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    &#125;
&#125;
</code></pre>
<p><strong>溢出:</strong></p>
<p>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    &#125;
&#125;
</code></pre>
<p>可以自行运行以上代码测试，关于溢出的概念，大家可以买《Java核心技术》这本书继续稳固和提升。</p>
<h4 id="浮点型运算"><a href="#浮点型运算" class="headerlink" title="浮点型运算"></a>浮点型运算</h4><p>浮点型运算和整型运算的最大区别，就是浮点型无法进行位运算和移位运算。</p>
<p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p>
<p><strong>举个栗子：</strong></p>
<p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p>
<p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);
        System.out.println(y);
    &#125;
&#125;
</code></pre>
<p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>
<pre><code class="java">// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r &lt; 0.00001) &#123;
    // 可以认为相等
&#125; else &#123;
    // 不相等
&#125;
</code></pre>
<p>浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循<strong>IEEE-754</strong>标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。</p>
<p><strong>类型提升：</strong></p>
<p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 5;
        double d = 1.2 + 24.0 / n; // 6.0
        System.out.println(d);
    &#125;
&#125;
</code></pre>
<p>需要注意的是，在一个复杂的四则运算中出现两个整数的情况下·，整型不会进行类型提升：</p>
<pre><code class="java">double d = 1.2 + 24 / 5; //5.2
</code></pre>
<p>对比如上两条代码，理解类型提升的概念。</p>
<p><strong>溢出：</strong></p>
<p>整型运算在除数为0时会报错并结束程序，但在浮点型运算中如果除数为0，不会报错，但会返回几个特殊值：</p>
<p>NaN：表示 not a number 非数字</p>
<p>Infinity：表示无穷大</p>
<p>-Infinity:表示负无穷</p>
<p>例如：</p>
<pre><code class="java">double x = 0.0 / 0; //NaN
double y = 1.0 / 0; //Infinity
double z = -1.0 / 0; //-Infinity
</code></pre>
<p><strong>强制转型：</strong></p>
<p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p>
<pre><code class="java">int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647   1后面的小数点后移20位
</code></pre>
<p>如果要进行<strong>四舍五入</strong>，可以对浮点数加上0.5再强制转型：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        double d = 2.6;
        int n = (int) (d + 0.5);
        System.out.println(n);
    &#125;
&#125;
</code></pre>
<p><strong>小结</strong></p>
<p>浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；</p>
<p>比较两个浮点数通常比较它们的差的绝对值是否小于一个特定值；</p>
<p>整型和浮点型运算时，整型会自动提升为浮点型；</p>
<p>可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。</p>
<h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><p>对于<strong>boolean</strong>类型，永远只有两个值：<strong>true</strong>和<strong>false</strong></p>
<p>布尔运算是一种关系运算，包括以下几种运算符:</p>
<ul>
<li><p>比较运算符: <code>&lt;   &gt;   &gt;=   &lt;=   ==   != </code></p>
</li>
<li><p>与运算 <code>&amp;&amp;</code></p>
</li>
<li><p>或运算 <code>||</code></p>
</li>
<li><p>非运算  <code> !</code></p>
<pre><code class="java">boolean isGreater = 5 &gt; 3; // true
int age = 12;
boolean isZero = age == 0; // false
boolean isNonZero = !isZero; // true
boolean isAdult = age &gt;= 18; // false
boolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true
</code></pre>
</li>
</ul>
<p>关系运算符的优先级从高到低依次是：</p>
<ul>
<li><code>!</code></li>
<li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
<li><code>==</code>，<code>!=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ul>
<p><strong>短路运算</strong></p>
<p>首先了解一下短路运算的概念，它是布尔运算中的一个重要概念，短路运算在提前确定结果后就会停止后续结果的执行，直接返回结果。</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &lt; 3;
        boolean result = b &amp;&amp; (5 / 0 &gt; 0);
        System.out.println(result);//false
    &#125;
&#125;
</code></pre>
<p>在以上代码中，<code>b</code>的值为<code> false</code>,而<code>b</code>和<code>（5 / 0 &gt; 0）</code>之间使用<code>&amp;&amp;</code>运算符，<code>b</code>已经为<code>false</code>，<code>result</code>的整体结果就已经注定是<code>false</code>，至于<code>(5 /0 &gt; 0)</code>已经不需要去管。</p>
<p>如果没有短路运算，<code>&amp;&amp;</code>后面的表达式会由于除数为<code>0</code>而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果<code>false</code>。</p>
<p>如果变量<code>b</code>的值为<code>true</code>，则表达式变为<code>true &amp;&amp; (5 / 0 &gt; 0)</code>。因为无法进行短路运算，该表达式必定会由于除数为<code>0</code>而报错，可以自行测试。(&amp;&amp;运算符是第一个表达式为false则直接为false，而第一个表达式为true，它就需要确定&amp;&amp;之后的表达式，若表达式为false，整体结果依旧是false，如果表达式错误则程序会报错)</p>
<p>如果将表达式换为:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &gt; 3;//true
        boolean result = b &amp;&amp; (5 / 0 &gt; 0);//注意这里b为true
        System.out.println(result);//报错
    &#125;
&#125;
</code></pre>
<p>同理，如果将<code>&amp;&amp;</code>换为<code>||</code>,则结果为<code>true</code>，原因是<code>||</code>运算符中只要有一个结果为<code>true</code>，则整体结果为<code>true</code></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &gt; 3;//true
        boolean result = b || (5 / 0 &gt; 0);//注意这里b为true
        System.out.println(result);//true
    &#125;
&#125;
</code></pre>
<p><strong>三元运算符</strong></p>
<p>三元运算符也叫三目运算符，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = -100;
        int x = n &gt;= 0 ? n : -n;//三元运算
        System.out.println(x);//100
    &#125;
&#125;
</code></pre>
<p>上述语句的意思是，判断<code>n &gt;= 0</code>是否成立，如果为<code>true</code>，则返回<code>n</code>，否则返回<code>-n</code>。这实际上是一个求绝对值的表达式。</p>
<p>注意到三元运算<code>b ? x : y</code>会首先计算<code>b</code>，如果<code>b</code>为<code>true</code>，则只计算<code>x</code>，否则，只计算<code>y</code>。此外，<code>x</code>和<code>y</code>的类型必须相同，因为返回值不是<code>boolean</code>，而是<code>x</code>和<code>y</code>之一。</p>
<p>如果对三元运算没有掌握的话，做一个小练习：输入一个年龄，如果年龄在6-12岁，屏幕打印该生是小学生，否则打印该生不是。</p>
<pre><code class="java">public class Test&#123;
    public static void main(String[] args)&#123;
        System.out.print(&quot;请输入该生年龄：&quot;);
        int age = new Scanner(System.in).nextInt();
        int flag = age &gt;= 6 &amp;&amp; age &lt;=12 ? 1 : 0;
        switch (flag)&#123;
            case 1:
                System.out.print(&quot;该生是小学生&quot;);
                break;
            case 0:
                System.out.print(&quot;该生不是小学生&quot;);
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210911170633085.png" alt="image-20210911170633085"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210911170651064.png" alt="image-20210911170651064"></p>
<p>关于这道练习题，还有更加简单的方法来实现，不妨开动你们聪明的大脑来实现吧！</p>
<h4 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h4><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>首先明确一点：在Java中，字符和字符串是两个不同的类型。</p>
<p>字符类型<code>char</code>是基本数据类型，它是<code>character</code>的缩写。一个<code>char</code>保存一个Unicode字符：</p>
<pre><code class="java">char c1 = &#39;A&#39;;
char c2 = &#39;中&#39;;
</code></pre>
<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p>
<pre><code class="java">int c1 = &#39;A&#39;;
int c2 = &#39;中&#39;;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210914135737352.png" alt="image-20210914135649201"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210914224444734.png" alt="image-20210914224444734"></p>
<p><code>A</code>的Unicode码是65，<code>中</code>的Unicode码是20013</p>
<p>除此之外，还可以使用”\u”+Unicode码表示一个字符：</p>
<pre><code class="java">char c1 = &quot;\u0041&quot;;
char c2 = &quot;\u4e2d&quot;;
</code></pre>
<p>在16进制表示法中，<code>0041</code>表示十进制的<code>65</code>,<code>4e2d</code>就是十进制的<code>20013</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915201328569.png"></p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>与字符类型不同的是，字符串类型String是引用类型，可存储0到任意个字符，使用<code>&quot;字符串&quot;</code>来表示字符串类型的数据：</p>
<pre><code class="java">String str = &quot;我是一个字符串！&quot;;
String str1 = new String(&quot;我是字符串2！&quot;);
</code></pre>
<p><strong>转义字符：</strong></p>
<p>字符串的表示方式使用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>来进行包裹，万一在字符串中正好有<code>&quot;</code>或者<code>&#39;</code>怎么办呢？这个时候可以使用转义字符<code>\</code>来进行操作：</p>
<pre><code class="java">String str = &quot;I\&#39;m a Student!&quot;;
</code></pre>
<p>测试一下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915202414025.png" alt="image-20210915202414025"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915202441449.png" alt="image-20210915202441449"></p>
<p>结果显而易见！</p>
<p><strong>转义字符的分歧</strong></p>
<p>因为<code>\</code>本身就是转义字符，所以表示<code>\</code>本身时使用<code>\\</code>：</p>
<pre><code class="java">String str2 = &quot;\\&quot;;
        System.out.println(str2);
</code></pre>
<p>常见的转义字符包括：</p>
<ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<p><strong>字符串连接</strong></p>
<p>字符串的连接使用<code>+</code></p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        String str = &quot;Hello,&quot;;
        String str1 = &quot;World!&quot;;
        String str2 = str+str1;
        System.out.println(str2);
    &#125;
&#125;
</code></pre>
<p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int age = 20;
        String str = &quot;Age is &quot;;
        String str1 = str + age + &quot;years old!&quot;;
        System.out.println(str1);
    &#125;
&#125;
</code></pre>
<p><strong>多行字符串：</strong></p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        String str = &quot;I\&#39;m Ok,\n&quot;
            +&quot;Thank you!\n&quot;
            +&quot;And you?&quot;;
        System.out.println(str);
    &#125;
&#125;
</code></pre>
<p>用如上方法表示多行字符串是非常麻烦的，在Java13开始提供了一个重要特性，在表示多行字符串时使用<code>&#39;&#39;&#39; ...&#39;&#39;&#39;</code></p>
<p>举个栗子：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String str = &quot;&quot;&quot;
                   SELECT * FROM
                     users
                   WHERE id &gt; 100
                   ORDER BY name DESC
                   &quot;&quot;&quot;;
        System.out.println(str);
    &#125;
&#125;
</code></pre>
<p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：</p>
<pre><code class="java">String s = &quot;&quot;&quot; 
           SELECT * FROM
             users
           WHERE id &gt; 100
           ORDER BY name DESC&quot;&quot;&quot;;
</code></pre>
<p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p>
<pre><code class="java">String s = &quot;&quot;&quot;
...........SELECT * FROM
...........  users
...........WHERE id &gt; 100
...........ORDER BY name DESC
...........&quot;&quot;&quot;;
</code></pre>
<p>用<code>.</code>标注的空格都会被去掉。</p>
<p>如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p>
<pre><code class="java">String s = &quot;&quot;&quot;
.........  SELECT * FROM
.........    users
.........WHERE id &gt; 100
.........  ORDER BY name DESC
.........  &quot;&quot;&quot;;
</code></pre>
<p>即总是以最短的行首空格为基准。</p>
<p><strong>字符串的不可变特性</strong></p>
<pre><code class="java">public class StringTest&#123;
    public static void main(String[] args)&#123;
        String s = &#39;Hello&#39;;//打印s是Hello
        System.out.println(s);
        s = &#39;World!&#39;//打印s是World！
        System.out.println(s);
    &#125;
&#125;
</code></pre>
<p>上述代码中的<code>s</code>在重新赋值后打印结果发生了变化，是s本身的值发生了变化吗？其实并不是，只是s将结果的内存地址指向了另一个字符串。</p>
<p>执行<code>String s = &quot;Hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;Hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915210059713.png" alt="image-20210915210059713"></p>
<p>而紧接着执行<code>s = &#39;World!&#39;</code>之后,JVM虚拟机创建字符串<code>&quot;World!&quot;</code>,然后把字符串变量<code>s</code>指向它:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915210321212.png" alt="image-20210915210321212"></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;hello&quot;;
        String t = s;
        s = &quot;world&quot;;
        System.out.println(t);
    &#125;
&#125;
</code></pre>
<p>思考上述代码,t是”hello”还是”world”?</p>
<p>答案: <code>t并没有重新赋值为s，所以t的值依旧保留为&quot;hello&quot;,如果在打印前补上一句:t = s;那么t的值便是&quot;world&quot;</code></p>
<p><strong>空值null</strong></p>
<p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p>
<pre><code class="java">String s1 = null; // s1是null
String s2; // 没有赋初值值，s2也是null
String s3 = s1; // s3也是null
String s4 = &quot;&quot;; // s4指向空字符串，不是null
</code></pre>
<p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>如果有一组相同类型的数据，可以这么表示:</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int n1 = 98;
        int n2 = 100;
        int n3 = 99;
        int n4 = 70;
        int n5 = 78;
    &#125;
&#125;
</code></pre>
<p>以上方法表示太繁琐，也太复杂，可以使用数组来表示：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        arr[0] = 98;
        arr[1] = 100;
        arr[2] = 99;
        arr[3] = 70;
        arr[4] = 78;
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，<code>int[]</code>。和单个基本类型变量不同，数组变量初始化必须使用<code>new int[5]</code>表示创建一个可容纳5个<code>int</code>元素的数组。</p>
<p>Java的数组有几个特点：</p>
<ul>
<li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li>
<li>数组一旦创建后，大小就不可改变。</li>
</ul>
<p>要访问数组中的某一个元素，需要使用索引。数组索引从<code>0</code>开始，例如，5个元素的数组，索引范围是<code>0</code>~&#96;4&#96;。</p>
<p>可以修改数组中的某一个元素，使用赋值语句，例如，<code>arr[1] = 79;</code>。</p>
<p>可以用<code>数组变量.length</code>获取数组大小：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        arr[0] = 98;
        arr[1] = 100;
        arr[2] = 99;
        arr[3] = 70;
        arr[4] = 78;
        System.out.println(arr.length);//5
    &#125;
&#125;
</code></pre>
<p>除此之外，数组还有一种简单的创建方式：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;90,78,100,99,98&#125;;
        System.out.println(arr.length);//5
    &#125;
&#125;
</code></pre>
<p>这种创建方式最大的优点就是不用指定数组大小，编译器可以直接推算出数组大小</p>
<p>数组是<strong>引用类型</strong>，在使用索引访问数组元素时，如果索引超出范围，运行时将报错：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        int n = 5;
        System.out.println(arr[n]); // 索引n不能超出范围
    &#125;
&#125;
</code></pre>
<p><strong>数组是引用类型且大小不可变</strong></p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1,2,3,4,5&#125;;
        System.out.println(Arrays.toString(arr));//1,2,3,4,5
        arr = new int[]&#123;1,2,3&#125;;
        System.out.println(Arrays.toString(arr));//1,2,3
    &#125;
&#125;
</code></pre>
<p>与String同理，arr指向{1,2,3,4,5}的内存地址，在执行<code>arr = new int[]&#123;1,2,3&#125;;</code>这句代码之后，arr指向{1,2,3}这组数的内存地址。</p>
<p>原有5个数的数组没有改变，只是无法使用变量arr来引用它们。</p>
<p><strong>字符串数组</strong></p>
<pre><code class="java">public class StringArrayTest&#123;
    public static void main(String[] args)&#123;
        String[] names = &#123;&quot;Tom&quot;,&quot;Alice&quot;,&quot;Jack&quot;,&quot;James&quot;&#125;;
        System.out.println(Arrays.toString(names));
        names[0] = &quot;Bob&quot;;
        System.out.println(Arrays.toString(names));
    &#125;
&#125;
</code></pre>
<p>在以上代码中，<code>String[] names = &#123;&quot;Tom&quot;,&quot;Alice&quot;,&quot;Jack&quot;,&quot;James&quot;&#125;;</code>定义了一个String类型有四位元素的数组，在执行完<code>names[1] = &quot;Bob&quot;;</code>这句代码后，<code>Tom</code>就会被替换成<code>Bob</code></p>
<p>这并不是names指向了一个新的数组{“Bob”,”Alice”,”Jack”,”James”},而是names的元素names[0]指向了一个新的值”Bob”,在数组中每个值的指向都是独立的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916154445754.png" alt="image-20210916154445754"></p>
<h2 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h2><p>在Java程序中，JVM默认总是顺序执行以分号<code>;</code>结束的语句。但是，在实际的代码中，程序经常需要做条件判断、循环，因此，需要有多种流程控制语句，来实现程序的跳转和循环等功能。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>在使用流程控制之前，先学习输入输出：</p>
<p><strong>输出：</strong></p>
<p>在前面的代码中，我们总是使用<code>System.out.println()</code>来向屏幕输出一些内容。</p>
<p><code>println</code>是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用<code>print()</code>：</p>
<pre><code class="java">public class InOrOutTest&#123;
    public static void main(String[] args)&#123;
        System.out.print(&quot;A,&quot;);
        System.out.print(&quot;B,&quot;);
        System.out.print(&quot;C.&quot;);
        System.out.println();
        System.out.println(&quot;This line is next&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>格式化输出：</strong></p>
<p>Java还提供了格式化输出，因为适合电脑阅读的内容不一定适合我们人类：</p>
<pre><code class="java">public class FormatOut&#123;
    public static void main(String[] args)&#123;
        double d = 1270000000;
        System.out.println(d);//1.27e9
    &#125;
&#125;
</code></pre>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式：</p>
<pre><code class="java">public class FormatOut &#123;
    public static void main(String[] args) &#123;
        double d = 3.1415926;
        System.out.printf(&quot;%.2f\n&quot;, d); // 显示两位小数3.14
        System.out.printf(&quot;%.4f\n&quot;, d); // 显示4位小数3.1416
    &#125;
&#125;
</code></pre>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>格式化输出整数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化输出十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
</tbody></table>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p>
<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>
<pre><code class="java">public class FormatOut &#123;
    public static void main(String[] args) &#123;
        int n = 12345000;
        System.out.printf(&quot;n=%d, hex=%08x&quot;, n, n); // 注意，两个%占位符必须传入两个数
    &#125;
&#125;
</code></pre>
<p>运行结果:</p>
<p><img src="/./Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0.assets/image-20210916161022033.png" alt="image-20210916161022033"></p>
<p><strong>输入：</strong></p>
<p>输入使用的是Scanner，首先看一下比输出复杂的输入如何实现:</p>
<pre><code class="java">public class ScannerTest&#123;
    public static void main(String[] args)&#123;
        Scanner in = new Scanner(System.in);
        System.out.print(&quot;请输入一个数：&quot;);
        int num = in.nextInt();
        if(num % 2 == 0)&#123;
            System.out.println(num + &quot;是一个偶数！&quot;);
        &#125;else&#123;
            System.out.println(num + &quot;是一个奇数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过<code>import</code>语句导入<code>java.util.Scanner</code>，<code>import</code>是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的<code>package</code>中会详细讲解如何使用<code>import</code>。</p>
<p>然后，创建<code>Scanner</code>对象并传入<code>System.in</code>。<code>System.out</code>代表标准输出流，而<code>System.in</code>代表标准输入流。直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码。</p>
<p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</p>
<h3 id="if控制语句"><a href="#if控制语句" class="headerlink" title="if控制语句"></a>if控制语句</h3><p><strong>基本语法：</strong></p>
<pre><code class="java">if(boolean)&#123;
    //true
&#125;
</code></pre>
<p>if关键字后面的括号是一个条件且为布尔类型，可以使用诸如： <code>i == 2</code> <code>x + y == 2</code>等等</p>
<p>如果括号内条件为真则执行花括号里的代码块</p>
<pre><code class="java">public class IfTest&#123;
    public static void main(String[] args)&#123;
        int i = 2;
        if(i == 2)&#123;
            System.out.print(&quot;i结果为2！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>if嵌套：</strong></p>
<p>if可以嵌套else继续使用，假设有一个条件但是有两种结果，那你怎么去执行第二种结果呢？再写一个if吗？显然是不可能的。</p>
<pre><code class="java">public class IfTest&#123;
    public static void main(String[] args)&#123;
        int i = 1;
        if(i == 2)&#123;
            System.out.print(&quot;i结果为2！&quot;);
        &#125;else&#123;
            System.out.print(&quot;i结果不为2！&quot;);//被执行
        &#125;
    &#125;
&#125;
</code></pre>
<p>除此之外，还可以在else后面加上if：</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;请输入1-3的整数:&quot;);
        Scanner in = new Scanner(System.in);
        int i = in.nextInt();
        if(i == 1) &#123;
            System.out.println(&quot;i为1！&quot;);
        &#125;else if(i == 2) &#123;
            System.out.println(&quot;i为2！&quot;);
        &#125;else if(i == 3) &#123;
            System.out.println(&quot;i为3！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>使用if判断引用类型对象相等：</strong></p>
<p>&lt;1&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = &quot;HELLO&quot;;
        String str2 = &quot;hello&quot;.toUpperCase();
        if(str==str2) &#123;
            System.out.println(&quot;str == str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str != str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>&lt;2&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = &quot;HELLO&quot;;
        String str2 = &quot;hello&quot;.toUpperCase();
        if(str.equals(str2)) &#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>&lt;3&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = null;
        String str2 = &quot;HELLO&quot;;
        if(str.equals(str2)) &#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>在引用类型对象比较中， &#x3D;&#x3D; 用来表示两个变量的引用地址是否一致，很显然在代码1中，“HELLO” 和 “hello”.toUpperCase()值是一致的，都是”HELLO”,但内存地址就是不同，所以结果只能是 str !&#x3D; str2   在代码2中，由于使用了equals运算符进行比较，它只会比较两个值是否相等，很显然两个值是相等的，所以结果必然是 str equals str2  在代码3中，str &#x3D; null,它指向一个空地址，所以会报错：java.lang.NullPointException</strong></p>
<h4 id="和-equals的区别及应用场景"><a href="#和-equals的区别及应用场景" class="headerlink" title="&#x3D;&#x3D; 和 equals的区别及应用场景"></a>&#x3D;&#x3D; 和 equals的区别及应用场景</h4><p>​		&lt;1&gt;对于&#x3D;&#x3D;，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<p>　　&lt;2&gt;对于equals方法，注意：<strong>equals方法不能作用于基本数据类型的变量</strong></p>
<p>　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。</p>
<p>　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
<p>要避免<strong>java.lang.NullPointException</strong>错误，可以使用**&amp;&amp;**运算符来避免：</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = null;
        String str2 = &quot;Hello&quot;;
        if(str != null &amp;&amp; str.equals(str2))&#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else&#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<p>运行结果:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916201148893.png" alt="image-20210916201148893">	</p>
<p><strong>小结：</strong></p>
<p><code>if ... else</code>可以做条件判断，<code>else</code>是可选的；</p>
<p>不推荐省略花括号<code>&#123;&#125;</code>；</p>
<p>多个<code>if ... else</code>串联要特别注意判断顺序；</p>
<p>要注意<code>if</code>的边界条件；</p>
<p>要注意浮点数判断相等不能直接用<code>==</code>运算符；</p>
<p>引用类型判断内容相等要使用<code>equals()</code>，注意避免<code>NullPointerException</code>。</p>
<h3 id="switch控制语句"><a href="#switch控制语句" class="headerlink" title="switch控制语句"></a>switch控制语句</h3><p>除if之外还有一种表达式可以根据条件执行不同分支：switch</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果<code>option</code>的值没有匹配到任何<code>case</code>，例如<code>option = 99</code>，那么，<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code>：</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果把<code>switch</code>语句翻译成<code>if</code>语句，那么上述的代码相当于：</p>
<pre><code class="java">if (option == 1) &#123;
    System.out.println(&quot;已进入单人模式&quot;);
&#125; else if (option == 2) &#123;
    System.out.println(&quot;已进入双人模式&quot;);
&#125; else if (option == 3) &#123;
    System.out.println(&quot;已进入练习模式&quot;);
&#125; else &#123;
    System.out.println(&quot;No selected&quot;);
&#125;
</code></pre>
<p>对于多个<code>==</code>判断的情况，使用<code>switch</code>结构更加清晰。</p>
<p>同时注意，上述“翻译”只有在<code>switch</code>语句中对每个<code>case</code>正确编写了<code>break</code>语句才能对应得上。</p>
<p>使用<code>switch</code>时，注意<code>case</code>语句并没有花括号<code>&#123;&#125;</code>，而且，<code>case</code>语句具有“<em>穿透性</em>”，<strong>漏写<code>break</code>将导致意想不到的结果。</strong></p>
<p><strong>使用<code>switch</code>语句时，只要保证有<code>break</code>，<code>case</code>的顺序不影响程序逻辑：</strong></p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>switch</code>语句还可以匹配<strong>字符串</strong>。字符串匹配时，是比较“内容相等”。例如：</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;apple\n&quot;
        +&quot;orange\n&quot;
        +&quot;3.banana\n&quot;);
        System.out.print(&quot;请输入想吃的水果:&quot;);
        String option = new Scanner(System.in).nextLine();
        switch (option)&#123;
            case &quot;apple&quot;:
                System.out.println(&quot;您选择吃苹果！&quot;);
            break;
            case &quot;orange&quot;:
                System.out.println(&quot;您选择吃橘子！&quot;);
            break;
            case &quot;banana&quot;:
                System.out.println(&quot;您选择吃香蕉！&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>编译检查</strong></p>
<p>使用IDE时，可以自动检查是否漏写了<code>break</code>语句和<code>default</code>语句，方法是打开IDE的编译检查。</p>
<p>在Eclipse中，选择<code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code>，将以下检查标记为Warning：</p>
<ul>
<li>‘switch’ is missing ‘default’ case</li>
<li>‘switch’ case fall-through</li>
</ul>
<p>在IDEA中，选择<code>File </code>- <code>Settings</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code>，将以下检查标记为Warning：</p>
<ul>
<li>Fallthrough in ‘switch’ statement</li>
<li>‘switch’ statement without ‘default’ branch</li>
</ul>
<p>当<code>switch</code>语句存在问题时，即可在IDE中获得警告提示。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916205937679.png" alt="image-20210916205937679"></p>
<h4 id="Java12中的switch新特性"><a href="#Java12中的switch新特性" class="headerlink" title="Java12中的switch新特性"></a>Java12中的switch新特性</h4><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String fruit = new Scanner(System.in).nextLine();
        switch (fruit) &#123;
        case &quot;apple&quot; -&gt; System.out.println(&quot;Selected apple&quot;);
        case &quot;pear&quot; -&gt; System.out.println(&quot;Selected pear&quot;);
        case &quot;mango&quot; -&gt; &#123;
            System.out.println(&quot;Selected mango&quot;);
            System.out.println(&quot;Good choice!&quot;);
        &#125;
        default -&gt; System.out.println(&quot;No fruit selected&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h3><p> while的基本语法：</p>
<pre><code class="java">while (条件)&#123;
    //语句块
&#125;
</code></pre>
<p>while就是括号内的条件为真时，执行语句块的内容，然后返回while，再次判断条件，为真则继续执行，为假则退出。while的最小执行次数为0，因为while需要先判断条件再执行。</p>
<p>例如计算1-100的和：</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        int i = 1;
        int sum = 0;
        while(i &lt;= 100)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(&quot;1-100的和为:&quot;+sum);
    &#125;
&#125;
</code></pre>
<p>这里的条件就是i &lt;&#x3D; 100，如果i &gt; 100,则循环结束</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>如果while的条件一直为真，那么语句块的代码会一直执行下去，这种情况就会造成死循环:</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        while (true)&#123;
            System.out.println(&quot;死循环！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。</p>
<p>还有另一种情况，可能会执行很多次，但最终由于逻辑错误，还是会退出while:</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        int i,sum;
        i = 1;
        sum = 0;
        while (i &gt; 0)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(sum);
    &#125;
&#125;
</code></pre>
<p>表面上看这貌似也是个死循环，因为i怎么都大于0，但是当i超过整型的最大值后，便会返回一个负数，这个时候while就会退出；</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>while</code>循环先判断循环条件是否满足，再执行循环语句；</p>
<p><code>while</code>循环可能一次都不执行；</p>
<p>编写循环时要注意循环条件，并避免死循环。</p>
<h3 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do while循环控制"></a>do while循环控制</h3><p>do while与while不同的是，do while 需要先执行一次语句，再判断条件，所以do while最小执行次数为1</p>
<p>基本语法：</p>
<pre><code class="java">do &#123;
    //代码块
&#125;while (条件);
</code></pre>
<p>使用do while改写1-100的和:</p>
<pre><code class="java">public class DoWhileTest &#123;
    public static void main(String[] args) &#123;
        int i = 1,sum = 0;
        do &#123;
            sum += i;
            i++;
        &#125;while(i &lt;= 100);
        System.out.println(&quot;1-100的和:&quot;+sum);
    &#125;
&#125;
</code></pre>
<h3 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h3><p><code>for</code>循环的功能非常强大，它使用计数器实现循环。<code>for</code>循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为<code>i</code>。</p>
<p>我们把1到100求和用<code>for</code>循环改写一下：</p>
<pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int sum = 0;
        for (int i = 0; i &lt;= 100 ; i++) &#123;
            sum += i;
        &#125;
        System.out.println(&quot;1-100的和：&quot;+sum);
    &#125;
&#125;
</code></pre>
<h4 id="for循环基本语法"><a href="#for循环基本语法" class="headerlink" title="for循环基本语法:"></a>for循环基本语法:</h4><pre><code class="java">for (计数器;计数区间;计数器自增/自减)&#123;
    //代码块
&#125;
</code></pre>
<h4 id="for循环遍历数组"><a href="#for循环遍历数组" class="headerlink" title="for循环遍历数组"></a>for循环遍历数组</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;100,120,135,150,93,97&#125;;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="打印乘法表"><a href="#打印乘法表" class="headerlink" title="打印乘法表"></a>打印乘法表</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 9 ; i++) &#123;
            for (int j = 1; j &lt;= i; j++) &#123;
                System.out.print(j + &quot;x&quot; + i + &quot;=&quot; + j*i + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="使用全局变量定义for"><a href="#使用全局变量定义for" class="headerlink" title="使用全局变量定义for"></a>使用全局变量定义for</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int i,j;
        for (i = 1; i &lt;= 9 ; i++) &#123;
            for (j = 1; j &lt;= i; j++) &#123;
                System.out.print(j + &quot;x&quot; + i + &quot;=&quot; + j*i + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        i = 10;//i和j在经过for循环后还可以继续使用
        j = 20;
        System.out.println(i + &quot; &quot; + j);
    &#125;
&#125;
</code></pre>
<h4 id="灵活使用for循环"><a href="#灵活使用for循环" class="headerlink" title="灵活使用for循环"></a>灵活使用for循环</h4><p><code>for</code>循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：</p>
<pre><code>// 不设置结束条件:
for (int i=0; ; i++) &#123;
    ...
&#125;
// 不设置结束条件和更新语句:
for (int i=0; ;) &#123;
    ...
&#125;
// 什么都不设置:
for (;;) &#123;
    ...
&#125;
</code></pre>
<p>通常不推荐这样写，但是，某些情况下，是可以省略<code>for</code>循环的某些语句的。</p>
<h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>上面使用for循环遍历数组，使用数组下标访问数组的每一个元素，其实还有更简单的办法就是使用for each循环:</p>
<pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6&#125;;
        for (int num : arr)&#123;
            System.out.print(num + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>for each条件中间使用 <code>:</code>分割，左边是遍历容器中元素的类型变量，右边就是容器名，比如上面的数组，全都是整型元素，那么用来接收值额变量num也应该是整型</p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break:跳出循环，结束代码块；</p>
<p>continue:跳过此次循环，开始执行下次循环</p>
<p>这两句总结可能不会很简明，我们举个栗子：</p>
<p>需求:计算1-100内所有<strong>偶数</strong>的和：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args)&#123;
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++)&#123;
            if (i % 2 == 0)&#123;
                sum += i;
            &#125;else&#123;
                continue;
            &#125;
        &#125;
        System.out.print(&quot;1-100偶数和:&quot;+sum);
    &#125;
&#125;
</code></pre>
<p>需求：在for循环的计数器加到100时，结束该循环</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args)&#123;
        for (int i = 0; ; i++)&#123;
            if(i == 100)&#123;
                break;
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h4><p><code>break</code>语句可以跳出当前循环；</p>
<p><code>break</code>语句通常配合<code>if</code>，在满足条件时提前结束整个循环；</p>
<p><code>break</code>语句总是跳出最近的一层循环；</p>
<p><code>continue</code>语句可以提前结束本次循环；</p>
<p><code>continue</code>语句通常配合<code>if</code>，在满足条件时提前结束本次循环。</p>
<p><code>break和continue</code>不仅局限于for或while，可以使用于很多场景。</p>
<h2 id="Java数组操作"><a href="#Java数组操作" class="headerlink" title="Java数组操作"></a>Java数组操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i]+&quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for each遍历"></a>for each遍历</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        for (int num: arr) &#123;
            System.out.print(num + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="Arrays-toString-遍历"><a href="#Arrays-toString-遍历" class="headerlink" title="Arrays.toString()遍历"></a>Arrays.toString()遍历</h4><p>Arrays.toString()是Java提供的一个遍历数组的函数，如不使用它，直接打印数组就会打印数组的内存地址:</p>
<pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<h4 id="直接打印的效果"><a href="#直接打印的效果" class="headerlink" title="直接打印的效果:"></a>直接打印的效果:</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        System.out.println(arr);//[I@1540e19d
    &#125;
&#125;
</code></pre>
<p>这样就会直接打印出内存地址:[I@1540e19d</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;37,66,95,41,25,10,21&#125;;
        //排序前：
        System.out.println(&quot;排序前：&quot;+Arrays.toString(arr));
        //排序后:
        for (int i = 0; i &lt; arr.length -1; i++) &#123;
            for (int j = 0; j &lt; arr.length -i -1; j++) &#123;
                if (arr[j] &gt; arr[j+1])&#123;
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;排序后：&quot;+Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p>
<p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p>
<pre><code class="java">int x = 1;
int y = 2;

x = y; // x现在是2
y = x; // y现在还是2
</code></pre>
<p>正确的写法是：</p>
<pre><code class="java">int x = 1;
int y = 2;

int t = x; // 把x的值保存在临时变量t中, t现在是1
x = y; // x现在是2
y = t; // y现在是t的值1
</code></pre>
<h4 id="Java内置数组排序"><a href="#Java内置数组排序" class="headerlink" title="Java内置数组排序"></a>Java内置数组排序</h4><p>Java内置数组排序的方法为:<code>Arrays.sort();</code></p>
<pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;37,66,95,41,25,10,21&#125;;
        System.out.println(&quot;排序前:&quot;);
        System.out.println(Arrays.toString(arr));
        System.out.println(&quot;排序后:&quot;);
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>定义:</p>
<pre><code class="java">int[][] num = &#123;
    &#123;1,2,3,4&#125;,
    &#123;5,6,7,8&#125;,
    &#123;9,10,11,12&#125;,
    &#123;13,14,15,16&#125;
&#125;;
</code></pre>
<p>其次，二位数组对每个数组元素的长度也没有限制：</p>
<pre><code class="java">int[][] num = &#123;
    &#123;1,2,3&#125;,
    &#123;1,2&#125;,
    &#123;4,5,6,7,8&#125;
&#125;;
</code></pre>
<h4 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a>二维数组遍历</h4><p>fori:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        for(int i = 0;i&lt;nums.length;i++)&#123;
            for(int j = 0;j&lt;nums[i].length;j++)&#123;
                System.out.print(nums[i][j]+&quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>foreach:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        for(int[] num : nums)&#123;
            for (int i : num)&#123;
                System.out.print(i + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>deepToString:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        System.out.print(Arrays.deepToString(nums));
    &#125;
&#125;
</code></pre>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>下面二位数组代表几位同学的各科成绩，请计算各位同学的平均分：</p>
<pre><code class="java">int[][] scores = &#123;
                &#123; 82, 90, 91 &#125;,
                &#123; 68, 72, 64 &#125;,
                &#123; 95, 91, 89 &#125;,
                &#123; 67, 52, 60 &#125;,
                &#123; 79, 81, 85 &#125;,
        &#125;;
</code></pre>
<p>答案：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] scores = &#123;
                &#123; 82, 90, 91 &#125;,
                &#123; 68, 72, 64 &#125;,
                &#123; 95, 91, 89 &#125;,
                &#123; 67, 52, 60 &#125;,
                &#123; 79, 81, 85 &#125;,
        &#125;;

        for(int[] num : scores)&#123;
            int plus = 0;
            double average = 0;
            int count = 0;
            for(int i = 0;i&lt;num.length;i++)&#123;
                plus += num[i];
                average = plus / 3;
            &#125;
            count += 1;
            System.out.println(&quot;第&quot;+count+&quot;名同学的平均分是:&quot;+average+&quot;分！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="面向对象概念："><a href="#面向对象概念：" class="headerlink" title="面向对象概念："></a>面向对象概念：</h3><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p>
<p>那什么是面向对象编程？</p>
<p>顾名思义，面向对象，你得首先有个对象，在Java中有一个名词叫做”万物皆对象”</p>
<p>比如可以拿Java来表示女朋友:</p>
<pre><code class="java">public class GirlFriend&#123;
    int id;//身份证号
    String name;//姓名
    String[] hobby;//兴趣爱好
    String post;//地址
&#125;
</code></pre>
<p>那么如何让你女朋友的信息打印出来呢？</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        GirlFriend girlFriend = new GirlFriend();//对象实例化
        girlFriend.id = 620521200001011121L;
        girlFriend.name = &quot;女朋友&quot;;
        girlFriend.hobby = new String[]&#123;&quot;琴&quot;, &quot;棋&quot;, &quot;书&quot;, &quot;画&quot;&#125;;
        girlFriend.post = &quot;地球-中国-甘肃&quot;;
        System.out.println(girlFriend.id);
        System.out.println(girlFriend.name);
        System.out.println(Arrays.toString(girlFriend.hobby));
        System.out.println(girlFriend.post);
    &#125;
&#125;
</code></pre>
<p>因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p>
<p>在本章中，我们将讨论：</p>
<p>面向对象的基本概念，包括：</p>
<ul>
<li>类</li>
<li>实例</li>
<li>方法</li>
</ul>
<p>面向对象的实现方式，包括：</p>
<ul>
<li>继承</li>
<li>多态</li>
</ul>
<p>Java语言本身提供的机制，包括：</p>
<ul>
<li>package</li>
<li>classpath</li>
<li>jar</li>
</ul>
<p>以及Java标准库提供的核心类，包括：</p>
<ul>
<li>字符串</li>
<li>包装类型</li>
<li>JavaBean</li>
<li>枚举</li>
<li>常用工具类</li>
</ul>
<p>通过本章的学习，完全可以理解并掌握面向对象的基本思想，但不保证能找到对象。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211007171101932.png" alt="image-20211007171101932"></p>
<h3 id="面向对象基础："><a href="#面向对象基础：" class="headerlink" title="面向对象基础："></a>面向对象基础：</h3><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p>
<table>
<thead>
<tr>
<th align="left">现实世界</th>
<th align="left">计算机模型</th>
<th align="left">Java代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">人</td>
<td align="left">类 &#x2F; class</td>
<td align="left">class Person { }</td>
</tr>
<tr>
<td align="left">小明</td>
<td align="left">实例 &#x2F; ming</td>
<td align="left">Person ming &#x3D; new Person()</td>
</tr>
<tr>
<td align="left">小红</td>
<td align="left">实例 &#x2F; hong</td>
<td align="left">Person hong &#x3D; new Person()</td>
</tr>
<tr>
<td align="left">小军</td>
<td align="left">实例 &#x2F; jun</td>
<td align="left">Person jun &#x3D; new Person()</td>
</tr>
</tbody></table>
<p>面向对象主要搞清class和instance的概念，class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型。</p>
<p>instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同。</p>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><pre><code class="java">class Person&#123;
    String name;
    int age;
&#125;
</code></pre>
<p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><pre><code class="java">Person ming = new Person();
</code></pre>
<p>如上所示代码创建一个Person实例: <code>Person ming</code>是一个Person类型的变量，<code>new Person()</code>是创建一个Person类型的实例，通过变量ming即可对这个实例进行操作，也就是跟对象交流：</p>
<h4 id="操作对象实例"><a href="#操作对象实例" class="headerlink" title="操作对象实例"></a>操作对象实例</h4><pre><code class="java">ming.name = &quot;小明&quot;;
ming.age = 20;
</code></pre>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p> 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p>
<pre><code class="java">public class Main&#123;
    Person ming = new Person();//Person实例1
    Person hong = new Person();//Person实例2
    Book book1 = new Book();//Book实例1
    Book book2 = new Book();//Book实例2
    ming.name = &quot;小明&quot;;
    ming.age = 20;
    hong.name = &quot;小红&quot;;
    hong.age = 19;
    book1.bookName = &quot;Java编程思想&quot;;
    book1.author = &quot;Bruce Eckel&quot;;
    book1.price = 80.2;
    book2.bookName = &quot;C++编程思想&quot;;
    book2.author = &quot;Bruce Eckel&quot;;
    book2.price = 90.8;
&#125;
class Person&#123;
    String name;
    int age;
&#125;
class Book&#123;
    String bookName;
    String author;
    double price;
&#125;
</code></pre>
<p>上面两个类各自<strong>分别</strong>创建了两个实例，每个类的每一个实例有自己<strong>独立的数据，互不干扰</strong>。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p>
<p>定义<code>class</code>就是定义了一种数据类型，对应的<code>instance</code>是这种数据类型的实例；</p>
<p><code>class</code>定义的<code>field</code>，在每个<code>instance</code>都会拥有各自的<code>field</code>，且互不干扰；</p>
<p>通过<code>new</code>操作符创建新的<code>instance</code>，然后用变量指向它，即可通过变量来引用这个<code>instance</code>；</p>
<p>访问实例字段的方法是<code>变量名.字段名</code>；</p>
<p>指向<code>instance</code>的变量都是引用变量。</p>
<h4 id="方法-函数"><a href="#方法-函数" class="headerlink" title="方法&#x2F;函数"></a>方法&#x2F;函数</h4><p>在<code>class</code>中，不仅仅可以定义<code>field(字段)</code>，还可以定义<code>方法、函数（function）</code></p>
<p>不同的人对方法的叫法不同，也有人会称之为函数：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;//main方法/函数，程序入口
        
    &#125;
&#125;
</code></pre>
<p>我们给Person类定义方法:</p>
<pre><code class="java">class Person&#123;
    String name;
    int age;
    public void eat()&#123;
        System.out.print(&quot;吃了！&quot;);
    &#125;
&#125;
</code></pre>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person ming = new Person();
        ming.eat();
    &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>在定义方法时，有修饰符可选，<code>public</code>,<code>private</code>,<code>protected</code>,不同修饰符对应不同的调用权限:<strong>public</strong> void fun(){}</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>相同包</th>
<th>不同包</th>
<th>子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>private</td>
<td>可访问</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>protected</td>
<td>可访问</td>
<td>可访问</td>
<td>不可访问</td>
<td>可访问</td>
</tr>
</tbody></table>
<h5 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h5><p>返回值类型就是类似<code>void</code>,<code>int</code>,<code>String</code>,<code>char</code>这种数据类型：public <strong>void</strong> fun(){}</p>
<p>除void外，其他类型均需使用return返回相同数据类型的数据，这个数据可以是变量，也可以是常量：</p>
<pre><code class="java">public class Main&#123;
    public void eat()&#123;
        System.out.print(&quot;吃了！&quot;);
    &#125;
    public int drink()&#123;
        System.out.print(&quot;喝了！&quot;);
        return 1;
    &#125;
    public String sleep()&#123;
        System.out.print(&quot;睡了！&quot;);
        return &quot;晚安&quot;;
    &#125;
    ...
&#125;
</code></pre>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法就是带<code>static</code>的方法，这种方法甚至可以被<strong>类名直接调用</strong>，也可以被非静态方法调用，但是静态方法无法调用非静态方法</p>
<pre><code class="java">public class StaticTest &#123;
    static String name = &quot;Name&quot;;//静态field
    String str = &quot;Str&quot;;//非静态field
    public void eat()&#123;
        System.out.println(&quot;吃了！&quot;);
        drink();//非静态调用静态
    &#125;
    public static void drink()&#123;
        System.out.println(&quot;喝了！&quot;);
        System.out.println(name);//调用静态变量就没事
        //eat();//调用非静态方法就会报错
        //System.out.println(str);//调用非静态变量也会报错
    &#125;

    public static void main(String[] args) &#123;
        drink();//main方法也是静态方法，可以直接调用静态方法（使用StaticTest.drink();也可以）
        //要调用非静态方法，必须对象实例化
        StaticTest staticTest = new StaticTest();
        staticTest.eat();
        System.out.println(staticTest.str);
    &#125;
&#125;
</code></pre>
<p>仔细体会如上代码。</p>
<h5 id="this变量"><a href="#this变量" class="headerlink" title="this变量"></a>this变量</h5><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向<strong>当前实例</strong>。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>
<p>如果没有命名冲突，可以省略<code>this</code>。例如：</p>
<pre><code class="java">class Person&#123;
    String name;
    public String getName()&#123;
        return name;//相当于this.name
    &#125;
&#125;
</code></pre>
<p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>
<pre><code class="java">class Person&#123;
    String name;
    public void setName(String name)&#123;
        this.name = name;//注意，这里的this.name是类的字段，而单独的name是局部变量，局部变量指的是方法参数
    &#125;
&#125;
</code></pre>
<h5 id="带参函数"><a href="#带参函数" class="headerlink" title="带参函数"></a>带参函数</h5><p>定义方法时，方法后面总有一个括号，可能经常能看到这类函数:</p>
<pre><code class="java">public class Person&#123;
    int age;
    String name;
    String[] hobby;
    Long identity;
    public void setAttribute(int age,String name,String[] hobby,Long identity)&#123;
       this.age = age;
       this.name = name;
       this.hobby = hobby;
       this.identity = indentity;
    &#125; 
&#125;
</code></pre>
<p>这种函数在定义时后面的括号中总会有参数，这些参数在方法被调用时必须赋值，而且在赋值时必须顺序一致，也就是数据类型必须一一对应:</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person person = new Person();
        person.setAttribute(20,&quot;小昕&quot;,&#123;&quot;编程&quot;,&quot;社工&quot;,&quot;渗透&quot;&#125;,620521200101010101L);//这里传进去的值顺序不可以乱
    &#125;
&#125;
</code></pre>
<p>如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>
<p>上面Person类<code>setAttrubite()</code>函数后面的参数跟类中的字段一样，所以函数括号内的参数优先级更高。</p>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><h6 id="可变参数定义"><a href="#可变参数定义" class="headerlink" title="可变参数定义"></a>可变参数定义</h6><p>定义可变参数使用<code>数据类型...</code>来进行定义，可变参数相当于数组:</p>
<pre><code class="java">public class FunctionChangeAttribute&#123;
    private String[] names;
    public void setAttrubite(String...names)&#123;
        this.names = names;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        FunctionChangeAttribute f = new FunctionChangeAttribute();
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;,&quot;itio&quot;);//四个值
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;);//两个值
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;);//三个值
        f.setAttrubite();//空值
    &#125;
&#125;
</code></pre>
<p>上面调用方法时，<code>&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;,&quot;itio&quot;</code>等便是传进去的实参，且连续调用方法3次，每次传进不一样的值</p>
<p>其实<code>String... names</code>完全可以改写成<code>String[] names</code>，但这样做的话，你不想给方法传参数便会报错，例如:</p>
<p><code>FunctionChangeAttribute.java</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211014203551375.png" alt="image-20211014203551375"></p>
<p><code>Main.java</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211014203642388.png" alt="image-20211014203642388"></p>
<p>这就是一个缺点，另外在调用时必须手动<code>new String[]</code>,而且可以传入一个<code>null</code>,这样的话容易出现<code>java.lang.NullPointerException</code>异常，使用可变参数便可以有效避免传入参数为<code>null</code>的问题，就算不传值，它编译后也是一个空数组</p>
<h5 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h5><h6 id="基本类型参数绑定"><a href="#基本类型参数绑定" class="headerlink" title="基本类型参数绑定"></a>基本类型参数绑定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int age =15;
        Person person = new Person();
        person.setAge(age);
        System.out.println(person.getAge());//15
        age = 20;
        System.out.println(person.getAge());//15
    &#125;
&#125;
class Person&#123;
    private int age;
    public void setAge(int age)&#123;
        this.age = age;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
&#125;
</code></pre>
<p>运行代码，看结果可知，在<code>age赋值为15</code>后传入<code>Person</code>的<code>setAge()</code>方法,第一次通过<code>getAge()</code>方法获取<code>person实例</code>的age的值是15，在Main类的age重新赋值为20后再次调用<code>person实例</code>的<code>getAge()</code>方法，得到的值依旧是15</p>
<p>原因是<code>setAge()</code>方法获得的参数，复制了<code>age</code>的值，<code>person实例</code>的age和<code>Main类</code>的age的值得修改互不影响</p>
<h6 id="引用类型参数绑定"><a href="#引用类型参数绑定" class="headerlink" title="引用类型参数绑定"></a>引用类型参数绑定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] fullName = new String[]&#123;&quot;xcc&quot;,&quot;xccit&quot;,&quot;ywx&quot;&#125;;
        Person p = new Person();
        p.setNames(fullName);
        System.out.println(p.getName());//xcc xccit
        fullName[0] = &quot;JamesY&quot;;
        System.out.println(p.getName());//JamesY xccit
    &#125;
&#125;
class Person&#123;
    private String[] names;

    public void setNames(String[] names)&#123;
        this.names = names;
    &#125;
    public String getName()&#123;
        return this.names[0] + &quot; &quot; + this.names[1];
    &#125;
&#125;
</code></pre>
<p>注意<code>setNames()</code>传入的参数是一个数组，将数组传入<code>setNames()</code>后，修改<code>fullName</code>的内容，对象的<code>names</code>也被修改</p>
<p>结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</p>
<h6 id="特殊的引用类型参数绑定"><a href="#特殊的引用类型参数绑定" class="headerlink" title="特殊的引用类型参数绑定"></a>特殊的引用类型参数绑定</h6><p>有了上个引用类型参数绑定的案例，再看看另外一个:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String name = &quot;Bob&quot;;
        Person person = new Person();
        person.setName(name);
        System.out.println(person.getName());//Bob
        name = &quot;James&quot;;
        System.out.println(person.getName());//Bob
    &#125;
&#125;
class Person&#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>这里参数使用<code>String</code>类型，在参数被修改后对象的<code>name</code>并没有被改变，原因在哪呢？</p>
<p>看一下这份代码的运行结果：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String name = &quot;Bob&quot;;
        Person person = new Person();
        person.setName(name);
        System.out.println(person.getName());//Bob
        System.out.println(name == person.getName());//true
        name = &quot;James&quot;;
        System.out.println(person.getName());//Bob
        System.out.println(name == person.getName());//false
    &#125;
&#125;
class Person&#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p><code>==</code>在对诸如<code>String、Date</code>这种引用类型对象比较时，比较的是<code>内存地址</code>，在改变<code>name</code>的值后内存地址也发生了改变，<code>name</code>和<code>person对象的name</code>指向不同的地址，<code>person</code>依旧指向内存中的<code>Bob</code>,而<code>name</code>已经指向了一个新的值<code>James</code>，他们指向的地址不同，所以对应的值也不同，所以就会出现第一次给<code>person.setName()</code>指向name的值<code>Bob</code>不会被改变的状态。</p>
<p>简而言之，第一次给<code>person的name赋值为&quot;Bob&quot;</code>，在Main中的name值被改变后，Main中的name的值指向一个新的地址”James”,而<code>person的name</code>依旧指向”Bob”</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装概念"><a href="#封装概念" class="headerlink" title="封装概念"></a>封装概念</h4><p>封装就是将类的属性及实现方式隐藏起来，对外提供一个方法进行访问而不是直接访问，通常对参数使用<code>private</code>,并且提供<code>getter/setter</code>方法进行访问</p>
<h4 id="参数私密性"><a href="#参数私密性" class="headerlink" title="参数私密性"></a>参数私密性</h4><p>Computer.java</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>上面的类就对属性使用了private修饰符，使属性不能被直接调用，要使用参数必须调用参数对应的<code>getter/setter</code>方法</p>
<p>Main.java</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();
        computer.setCode(10);
        System.out.println(computer.getCode());//10
    &#125;
&#125;
</code></pre>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><p>无参构造实际上我们前面一直在用：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();//初始化对象时这种操作默认就是无参构造
        computer.setCode(10);
        System.out.println(computer.getCode());//10
    &#125;
&#125;
</code></pre>
<p>而对于Computer类来讲，无参构造也是默认存在的:</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer() &#123;//无参构造方法
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>Computer这两份代码实际上就是一模一样的，只是一个没写无参构造方法，一个写了无参构造方法</p>
<h5 id="带参构造"><a href="#带参构造" class="headerlink" title="带参构造"></a>带参构造</h5><p>无参构造貌似并没有感受到什么变化，带参构造就有变化了，我们初始化对象后要对其属性赋值，必须一个个使用<code>setter</code>方法赋值，而带参构造就是为了解决这个问题，在初始化对象时直接对属性赋值：</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer() &#123;//无参构造
    &#125;

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer(10,&quot;i7-7300HQ&quot;,true);
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<p>这样在对象初始化时，直接对属性赋值，但请注意:传值的顺序必须与括号内属性的顺序一致</p>
<p>要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>这段代码去掉了无参构造方法，只有带参构造,像以前一样直接<code>new Computer();</code>就会报错</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();//编译报错
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<p>看一下控制台:</p>
<pre><code class="java">E:\IdeaProjects\JavaSE\src\com\oop\base\Main.java:7:29
java: 无法将类 com.oop.base.Computer中的构造器 Computer应用到给定类型;
  需要: int,java.lang.String,boolean
  找到:    没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<p>如果既想使用没有参数的构造方法，又想使用带参数的构造方法，那么只能把两种方法都定义出来</p>
<h5 id="带参函数参数初始化注意事项"><a href="#带参函数参数初始化注意事项" class="headerlink" title="带参函数参数初始化注意事项"></a>带参函数参数初始化注意事项</h5><h6 id="对象属性的最终值由构造函数决定"><a href="#对象属性的最终值由构造函数决定" class="headerlink" title="对象属性的最终值由构造函数决定"></a>对象属性的最终值由构造函数决定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer(10,&quot;i7-7300HQ&quot;,true);
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Computer &#123;
    /*参数已经被初始化*/
    private int code = 20;
    private String cpu = &quot;R900&quot;;
    private boolean isNevdia = false;

/*    public Computer() &#123;//无参构造
    &#125;*/

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<h5 id="多构造方法"><a href="#多构造方法" class="headerlink" title="多构造方法"></a>多构造方法</h5><p>Java可以定义多个构造方法，在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Person();//调用Person()
        Person person1 = new Person(&quot;xccit&quot;);//调用Person(String name)
        Person person2 = new Person(&quot;xccit&quot;,20);//调用Person(String name,int age)
    &#125;
&#125;
class Person&#123;
    private int age;
    private String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);//调用Person(String name)
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);//调用Person(String name,int age)
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>另外各构造方法之间可以使用<code>this</code>进行调用，这样做的好处就是可以<code>代码复用</code>，具体的自己测试即可</p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>在一个类中，如果有功能相同但参数不同的方法，可以把这些方法以同名定义，称为<code>同名方法</code>，方法后面的参数替换掉即可，这就是方法重载</p>
<pre><code class="java">public class Hello &#123;

    public void hello()&#123;//第一个hello方法
        System.out.println(&quot;Hello&quot;);
    &#125;
    public void hello(String name)&#123;//第二个hello方法
        System.out.println(&quot;Hello&quot;+name);
    &#125;
    public void hello(String[] names)&#123;//第三个hello方法
        System.out.println(&quot;Hello&quot;+ Arrays.toString(names));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
       Hello h = new Hello();
       h.hello();//调用第一个hello()
       h.hello(&quot;小昕&quot;);//调用第二个hello()
       h.hello(new String[]&#123;&quot;小昕&quot;,&quot;小明&quot;,&quot;小军&quot;&#125;);//调用第三个hello()
    &#125;
&#125;
</code></pre>
<p>注意：方法重载的返回值类型通常都是相同的。</p>
<p>方法重载的目的是：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>举个栗子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p>
<ul>
<li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li>
<li><code>int indexOf(String str)</code>：根据字符串查找；</li>
<li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li>
<li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h4><p>如果有一些功能相同的类，并且在使用时不想二次写代码或者CTRL CV，那么这个时候<code>继承</code>就派上用场了,继承关键字是<code>extends</code></p>
<p>以Person类举个栗子：</p>
<pre><code class="java">public class Person &#123;
    private int age;
    private String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>这个时候新建一个类为:Student.java 继承Person</p>
<pre><code class="java">public class Student extends Person&#123;
    
&#125;
</code></pre>
<p>这个时候在Main.java中new一个Student实例：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211024135640149.png" alt="image-20211024135640149"></p>
<p>这个时候new的Student已经可以使用Person的所有方法</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Student student = new Student();
        student.setAge(20);
        student.setName(&quot;xccit&quot;);
        System.out.println(student);
    &#125;
&#125;
</code></pre>
<p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>
<p>想让Student实现新功能，只需要给它编写新功能即可：</p>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello(String name)&#123;//新功能，说一句Hello xxx
        System.out.println(&quot;Hello&quot;+name);
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211024140543769.png" alt="image-20211024140543769"></p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）</p>
<p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>
<pre><code class="ascii">┌───────────┐
│  Object   │
└───────────┘
      ▲
      │
┌───────────┐
│  Person   │
└───────────┘
      ▲
      │
┌───────────┐
│  Student  │
└───────────┘
</code></pre>
<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p>
<pre><code class="ascii">┌───────────┐
       │  Object   │
       └───────────┘
             ▲
             │
       ┌───────────┐
       │  Person   │
       └───────────┘
          ▲     ▲
          │     │
          │     │
┌───────────┐ ┌───────────┐
│  Student  │ │  Teacher  │
└───────────┘ └───────────┘
</code></pre>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段,这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问:</p>
<pre><code class="java">public class Person &#123;
    protected int age;
    protected String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;+name);//这里的name就是父类的name字段
    &#125;
&#125;
</code></pre>
<p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</p>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>，例如：</p>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;+super.name);//这里的super.name就是父类的name字段
    &#125;
&#125;
</code></pre>
<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>但是，在某些时候，就必须使用<code>super</code>,举个栗子：</p>
<pre><code class="java">public class Person &#123;
    protected int age;
    protected String name;

    public Person(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        this.score = score;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Student student = new Student(20,&quot;xccit&quot;,100);
        System.out.println(student);
    &#125;
&#125;
</code></pre>
<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法:</p>
<pre><code class="java">java: 无法将类 com.oop.extend.Person中的构造器 Person应用到给定类型;
  需要: int,java.lang.String
  找到:    没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        super();//自动调用父类的构造方法
        this.score = score;
    &#125;
&#125;
</code></pre>
<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        super(age,name);//自动调用父类的构造方法
        this.score = score;
    &#125;
&#125;
</code></pre>
<p>这样就可以正常编译了,因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<p>这里还顺带引出了另一个问题：<code>即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</code></p>
<h4 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h4><p>当一个类使用<code>final</code>关键字修饰时，它就不可被继承，如果只想指定类继承它，在Java15中新出两个关键字可以完美解决此需求:</p>
<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称：</p>
<pre><code class="java">public sealed class Person permits Student,Teacher,Engineer&#123;
    //现在的Person类就是一个sealed类，通过permits关键字只允许被Student,Teacher,Engineer类继承
&#125;
</code></pre>
<p>如果使用Student继承Person可以这么写:</p>
<pre><code class="java">public final class Student extends Person&#123;
    
&#125;
</code></pre>
<p>而如果使用一个未被permits关键字修饰的类继承Person就会报错，例如:</p>
<pre><code class="java">public final class People&#123;
    
&#125;
</code></pre>
<p>这种机制主要用于一些框架，防止继承被滥用，最典型的框架便是<code>Spring</code></p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>在使用Java的继承时，可以使用<code>父类</code>类型的变量接收<code>子类</code>类型的实例，但不允许使用<code>子类类型变量接收父类实例</code>：</p>
<p>举个栗子：Student类继承自Person类</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person p = new Student();//允许
        Student stu = new Person();//禁止，也是错误的
    &#125;
&#125;
</code></pre>
<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>向下转型跟向上转型完全相反，向下转型是将<code>父类类型实例使用子类类型变量接收</code></p>
<p>举个栗子:Student类继承自Person类</p>
<pre><code class="java">public class Main()&#123;
    public static void main(String[] args)&#123;
        Person p1 = new Person();
        Person p2 = new Student();
        Student stu1 = (Student) p1;//运行时异常，ClassCastException
        Student stu2 = (Student) p2;//运行成功
    &#125;
&#125;
</code></pre>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code></p>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<pre><code class="java">Person p = new Person();
System.out.println(p instanceof Person); // true
System.out.println(p instanceof Student); // false

Student s = new Student();
System.out.println(s instanceof Person); // true
System.out.println(s instanceof Student); // true

Student n = null;
System.out.println(n instanceof Student); // false
</code></pre>
<p>如果测试结果为false,在写代码时一定不要用<code>instanceof</code>操作符左边的类型转换成操作符右边的类型</p>
<p>instanceof<code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为</code>null<code>，那么对任何</code>instanceof<code>的判断都为</code>false</p>
<p>所以建议在进行类型转换操作时，可以使用<code>instanceof</code>进行判断，结果为<code>true</code>后再进行转换</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person person = new Student();
        if(person instanceof Student)&#123;//只有判断成功才会向下转型
            Student stu = (Student) person;//转型一定成功！
        &#125;
    &#125;
&#125;
</code></pre>
<p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。举个栗子：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Object obj = &quot;I am a String!&quot;;//Object是一切类的超类
        if(obj instanceof String)&#123;
            String str = (String) obj;
            System.out.println(str.toUpperCase());//可以调用String的方法
        &#125;
    &#125;
&#125;
</code></pre>
<p>上一份代码还可以这么改：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Object obj = &quot;I am a String!&quot;;//Object是一切类的超类
        if(obj instanceof String str)&#123;
            System.out.println(str.toUpperCase());//可以调用String的方法
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p><code>继承</code>和<code>组合</code>说起来容易，理解起来可能稍微有点难，特别是对基础并不扎实的童鞋来讲，可能只会写代码，并不知道这么写的意义在哪：</p>
<p>举个栗子:</p>
<p>给出三个类：Person,Student,Book</p>
<p>Person和Student是<code>is</code>关系，Student属于Person的一种，或者可以这么理解:人有很多种职业，按职业区分说这个人是程序员，那个人是学生，老师，白领… 所以在这个基础上，Student继承自Person，写法为:</p>
<pre><code class="java">public class Student extends Person&#123;
    
&#125;
</code></pre>
<p>而Book和Student呢？学生需要读书，都有什么书呢？比如语文，数学，英语，那么相应的每一本书属于某个同学，所以Book和Student属于<code>has</code>关系，用代码可以这么写：</p>
<pre><code class="java">public class Student &#123;
    private Book book;//Book属于Student
&#125;
</code></pre>
<p>因此继承是is关系，组合是has关系</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="方法重写（覆写）"><a href="#方法重写（覆写）" class="headerlink" title="方法重写（覆写）"></a>方法重写（覆写）</h4><p>在封装中说过方法重载，多态中又要说方法重写:</p>
<p>举个栗子:Person和Student</p>
<pre><code class="java">public class Person&#123;
    public void run()&#123;
        System.out.print(&quot;Person.run&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    public void run()&#123;//重写父类run方法
        System.out.print(&quot;Student.run&quot;);
    &#125;
&#125;
</code></pre>
<p>重写和重载的概念要分清：子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）</p>
<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
<pre><code class="java">class Person &#123;
    public void run() &#123; … &#125;
&#125;

class Student extends Person &#123;
    // 不是Override，因为参数不同:
    public void run(String s) &#123; … &#125;
    // 不是Override，因为返回值不同:
    public int run() &#123; … &#125;
&#125;
</code></pre>
<h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p>
<pre><code class="java">public class Person &#123;
    public void run()&#123;
        System.out.println(&quot;Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    @Override
    public void run(String s)&#123;//运行失败！因为重写的方法参数不同
        System.out.println(&quot;Run!&quot;);
    &#125;
&#125;
</code></pre>
<p>正确写法：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211025111155821.png" alt="image-20211025111155821"></p>
<p>另外，如果手动重写方法并且代码正确，**@Override<strong>并不是必需的，</strong>@Override**只是会在代码编写阶段帮助我们验证是否正确重写方法</p>
<h5 id="调用谁的方法"><a href="#调用谁的方法" class="headerlink" title="调用谁的方法"></a>调用谁的方法</h5><p>在前面我们使用了<code>父类类型 变量 = new 子类类型();</code>，在使用这种方法创建子类实例后覆写其父类方法，运行时调用其父类方法还是子类自身的方法：</p>
<pre><code class="java">public class Person &#123;
    public void run()&#123;
        System.out.println(&quot;Person.Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    @Override
    public void run()&#123;
        System.out.println(&quot;Student.Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Student();//父类new子类
        person.run();//调用该方法
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211025111900808.png" alt="image-20211025111900808"></p>
<p>事实证明依旧会调用子类自身的方法，得出结论：Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<p>这个非常重要的特性在面向对象编程中称之为<code>多态</code>。它的英文拼写非常复杂：<code>Polymorphic</code>。</p>
<h4 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h4><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
<p>那如果按上面的例子，有这么一个方法:</p>
<pre><code class="java">public void runTeice(Person p)&#123;
    p.run();
    p.run();
&#125;
</code></pre>
<p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>
<p>举个栗子:</p>
<p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p>
<pre><code class="java">class Income&#123;
    protected double income;
    public double getTax()&#123;
        return income*0.1;//税率10%
    &#125;
&#125;
</code></pre>
<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p>
<pre><code class="java">class Salary extends Income&#123;
    @Override
    public double getTax() &#123;
        if(income &lt; 5000)&#123;
            return 0;
        &#125;
        return (income - 5000) * 0.1;
    &#125;
&#125;
</code></pre>
<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<pre><code class="java">class StateCouncilSpecialAllowance extends Income&#123;
    @Override
    public double getTax() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<pre><code class="java">public double totalTax(Income... incomes) &#123;
    double total = 0;
    for (Income income: incomes) &#123;
        total = total + income.getTax();
    &#125;
    return total;
&#125;
</code></pre>
<p>整体代码:</p>
<pre><code class="java">package com.oop.polymorphic;

/**
 * @author Administrator_Xcc
 */
public class Main &#123;
    public static void main(String[] args) &#123;
        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:
        Income[] incomes = new Income[]&#123;
                new Income(3000),//300
                new Salary(7500),//250
                new StateCouncilSpecialAllowance(10000)//0
        &#125;;
        System.out.println(totalTax(incomes));
    &#125;
    public static double totalTax(Income... incomes) &#123;
        double total = 0;
        for (Income income: incomes) &#123;
            total += income.getTax();
        &#125;
        return total;
    &#125;
&#125;
class Income&#123;
    protected double income;
    public Income(double income)&#123;this.income = income;&#125;
    public double getTax()&#123;
        return income*0.1;//税率10%
    &#125;
&#125;
class Salary extends Income&#123;
    public Salary(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        if(income &lt; 5000)&#123;
            return 0;
        &#125;
        return (income - 5000) * 0.1;
    &#125;
&#125;
class StateCouncilSpecialAllowance extends Income&#123;
    public StateCouncilSpecialAllowance(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>
<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
<h4 id="重写Object方法"><a href="#重写Object方法" class="headerlink" title="重写Object方法"></a>重写Object方法</h4><p>Java有一个超类叫做<code>Object</code>，Object中定义了几个重要方法：</p>
<ul>
<li><code>toString()</code>:将实例对象以<code>String</code>输出，如不重写此方法会输出该实例内存地址</li>
<li><code>equals()</code>:判断两个实例是否逻辑相等</li>
<li><code>hashCode()</code>:计算实例的hash值</li>
</ul>
<p>在很多时候我们都会用到这几个方法:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Person();
        person.name = &quot;xcc&quot;;
        System.out.println(person.hashCode());
        System.out.println(person);
    &#125;
&#125;
class Person&#123;
    protected String name;

    @Override
    public int hashCode() &#123;
        return this.name.hashCode();
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if(obj instanceof Person)&#123;
            Person p = (Person) obj;
            return this.name.equals(p.name);
        &#125;
        return false;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person:name=&quot;+name;
    &#125;
&#125;
</code></pre>
<h4 id="调用super方法"><a href="#调用super方法" class="headerlink" title="调用super方法"></a>调用super方法</h4><p>在子类需要调用父类被重写的方法时，可以使用<code>super</code></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
       Person person = new Student();
       person.name = &quot;Xcc&quot;;
        System.out.println(person.hello());
    &#125;
&#125;
class Person &#123;
    protected String name;
    public String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

class Student extends Person &#123;
@Override
    public String hello() &#123;
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p>
<pre><code class="java">class Person&#123;
    protected String name;
    public final String hello()&#123;
        return &quot;Hello&quot;+name;
    &#125;
&#125;
class Student extends Person&#123;
    
    @Override
    public String hello()&#123;
        //compile error :不允许重写
    &#125;
&#125;
</code></pre>
<p>除此以外:</p>
<ul>
<li>一个类不想被继承，也可以在该类名前加上final</li>
<li>一个字段的值不想被修改，可以加上final</li>
<li><strong>可以在构造方法中初始化字段，这种方法很实用，可以保证实例一旦被创建，其被final修改的字段就不可以改变：</strong></li>
</ul>
<pre><code class="java">class Person&#123;
    public final String name;
    Person(String name)&#123;
        //构造方法中将name初始化
        this.name = name;
    &#125;
&#125;
</code></pre>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>由于多态的特性，每个子类都可以覆写父类的方法：</p>
<pre><code class="java">class Person &#123;
    protected String name;
    public String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

class Student extends Person &#123;
@Override
    public String hello() &#123;
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    &#125;
&#125;
</code></pre>
<p>如果父类的方法没有实际意义，可否去掉方法的执行语句？</p>
<pre><code class="java">class Person&#123;
    public String hello();//没有执行语句
&#125;
</code></pre>
<p>那么这么写肯定不行，编译会报错，可以讲&#x3D;将方法定义为抽象方法吗？</p>
<pre><code class="java">class Person&#123;
    public abstract String hello();//没有执行语句
&#125;
</code></pre>
<p>这样子也不行，会导致Person类无法编译。</p>
<p>这个时候抽象类的作用就出来了，把不需要写实际执行代码的方法写进抽象类，这样既可保证类正常编译，又能减轻代码量。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216223854115.png" alt="image-20211216223854115" style="zoom:50%;" />

<h4 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h4><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<pre><code class="java">Person s = new Student();
Person t = new Teacher();
</code></pre>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<pre><code class="java">//不用关心Person变量的子类类型
t.hello();
s.hello();
</code></pre>
<p>同样，如果新建一个类继承了Person，我们仍然不用关心Person类型变量的具体子类类型：</p>
<pre><code class="java">Person e = new Employee();
e.run();
</code></pre>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>抽象类的本质就是一个高层类，即定义一个接口规范，让继承它的类都使用同一个接口规范，如果这个抽象类中没有任何字段，所有方法都是抽象方法，那么这个类可以使用<code>接口</code>代替，也就是<code>interface</code>：</p>
<p>abstract class:</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224118794.png" alt="image-20211216224118794" style="zoom:50%;" />

<p>interface:</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224525393.png" alt="image-20211216224525393" style="zoom:50%;" />

<p>抽象类中子类使用<code>extends</code>字段继承该类后可使用该类的所有方法，在接口中，子类需使用<code>implements</code>实现该接口：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224830958.png" alt="image-20211216224830958" style="zoom:50%;" />

<p>其次在Java中，一个类只可以继承一个类，但一个类可以实现多个接口：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216225041644.png" alt="image-20211216225041644" style="zoom:50%;" />

<p>这样的话，Hello这个接口中有什么方法，Student类也必须重写该接口的方法，不然编译器就会报错：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216225239543.png" alt="image-20211216225239543"></p>
<p>未实现Hello接口的方法，编译器提示报错。</p>
<h4 id="Java接口和编程接口"><a href="#Java接口和编程接口" class="headerlink" title="Java接口和编程接口"></a>Java接口和编程接口</h4><p>Java接口泛指<code>intrface</code>的定义，表示一组接口类型和一组方法签名，编程接口泛指接口规范，比如方法签名，数据格式，网络协议等。</p>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>Person.java</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217133240926.png" alt="image-20211217133240926" style="zoom:50%;" />

<p>此时<code>Person</code>接口继承了<code>Hello</code>，<code>Hello</code>接口的方法也会一并继承下去，在有子类实现了<code>Person</code>接口时，也要一并实现<code>Hello</code>接口的方法：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217133529259.png" alt="image-20211217133529259" style="zoom:50%;" />

<p>在使用时，实例化的对象永远是一个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217172801420.png" alt="image-20211217172801420" style="zoom:50%;" />

<h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>在接口中，可以自定义<code>default</code>方法：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173242630.png" alt="image-20211217173242630" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173542446.png" alt="image-20211217173542446" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173711380.png" alt="image-20211217173711380" style="zoom:50%;" />

<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p>关于静态方法，前面在方法已经轻微提到过，本章着重讲解</p>
<h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>在一个<code>class</code>中定义的字段，称为<code>实例字段</code>，每个实例调用时都互不干扰，但是还有一种带<code>static</code>的字段，称为<code>静态字段（static field）</code>,静态字段在内存中有一块独立的区域，所有实例都会共享该字段,举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224185153367.png" alt="image-20211224185153367" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224190545524.png" alt="image-20211224190545524" style="zoom: 46%;" />



<p>最终的运行结果也是：</p>
<pre><code class="java">90
80
</code></pre>
<p>原因是st1实例和st2实例都属于<code>StaticTest</code>类，<code>num</code>字段也属于<code>StaticTest</code>类，所以使用<code>st1.num=90</code>给num赋值就相当于：所有这个类的实例调用num时都是同一个值，而这个值被某个实例调用时改变后，其他实例调用同样也是这个值。虽然实例可以访问静态字段，但是它们指向的其实都是<code>StaticTest</code>的静态字段。所以，所有实例共享一个静态字段。</p>
<p>而对于上述代码，其实更好写的方式是：</p>
<pre><code class="java">StaticTest.num = 90;
</code></pre>
<p>直接拿类名调用字段看起来更清晰，也更好理解。</p>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法同样使用一个类名就可以调用，举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224192336696.png" alt="image-20211224192336696" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224192403848.png" alt="image-20211224192403848" style="zoom:50%;" />

<p>因为静态方法同样属于<code>StaticTest</code>类而不属于某个实例，所以静态方法无法访问实例字段及<code>this.字段</code>，静态方法只能访问静态字段，通过某个实例也可以调用静态方法，编译器会自动将实例名称变为类名，正常情况下使用实例变量调用静态方法会收到编译器的警告：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224200915126.png" alt="image-20211224200915126"></p>
<p>虽然会警告，但是程序可以正常运行，所以建议使用<code>类名.静态方法</code></p>
<h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>一般来讲，接口做为一种纯抽象类，它不能定义实例字段，但可以定义静态字段，但静态字段必须是<code>final</code>类型，举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224201558286.png" alt="image-20211224201558286" style="zoom:50%;" />

<p>但其实编译器会自动加上前面的关键字，所以这段代码的简写形式为：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224201658652.png" alt="image-20211224201658652" style="zoom:50%;" />

<p>拓展：使用Java静态字段和静态方法统计实例创建次数：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224202607960.png" alt="image-20211224202607960" style="zoom:49%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224202523488.png" alt="image-20211224202523488" style="zoom:50%;" />

<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包名的定义规范"><a href="#包名的定义规范" class="headerlink" title="包名的定义规范"></a>包名的定义规范</h4><p>包名在定义时，一般使用项目域名的倒置写法，比如有一个web项目的域名是:<code>https://xccit.io</code>,那么这个项目的包名在命名时，就是这样的：<code>io.xccit.*</code></p>
<p>在后面使用<code>MVC</code>开发模式时，会有分层开发模式，而这个时候包名就会这么写：</p>
<p>M层：<code>io.xccit.model</code>(大多数会使用dao，这儿是举个栗子)</p>
<p>V层：<code>io.xccit.view</code></p>
<p>C层：<code>io.xccit.controller</code></p>
<p>看下我在举个栗子的时候写的包名：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224203456444.png" alt="image-20211224203456444"></p>
<p>项目名为：JavaSE</p>
<p>包名顶层为:com</p>
<p>com下有2个包：<code>base </code> <code>oop</code></p>
<p>base下只有三个类</p>
<p>oop下又有5个包：<code>base</code> <code>extend</code> <code>interfaces</code> <code>polymorphic</code> <code>statictest</code></p>
<p>这些包层层深入，里面有不同的类，类与类之间可以根据权限修饰符互相访问</p>
<p>参考另一个web项目的包：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224204009559.png" alt="image-20211224204009559"></p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h4><p>一个类定义在另一个类的内部，这个类就叫做内部类：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224205315948.png" alt="image-20211224205315948" style="zoom:50%;" />

<p>这里可以发现Outer十一个正常存在的类，而Inner是一个内部类，内部类必须依附外围的内存在，也就是Outer，这里可以看到Inner在创建时前面还有一个<code>Outer.</code>，而且创建后的<code>inner</code>实例成功访问到了Outer的<code>private</code>字段，因为Inner在Outer内部，所以可以访问Outer中使用<code>private</code>修饰的字段和方法。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>还有一种定义内部类的方法，它不需要在<code>Outer</code>中明确定义，而是在<code>Outer</code>的方法中通过<code>匿名内部类</code>来定义：</p>
<pre><code class="java">public class InnerTest()&#123;
    public static void main(String args[])&#123;
        new Outer(&quot;xccit&quot;).asyncHello();
    &#125;
    class Outer&#123;
    private String name;
    public Outer(String name)&#123;
        this.name = name;
    &#125;

    void asyncHello()&#123;
        Runnable r = new Runnable()&#123;
            @Override
            public void run()&#123;
                System.out.println(&quot;Hello &quot;+Outer.this.name);
            &#125;
        &#125;;
        new Thread(r).start();
    &#125;
&#125;
&#125;
</code></pre>
<p>通过实现一个<code>Runnable</code>接口的实例来体现出匿名内部类。</p>
<p>除此之外，匿名内部类还可以继承自普通类：</p>
<pre><code class="java">public class InnerTest &#123;
    public static void main(String[] args) &#123;
        HashMap&lt;String, Object&gt; map1 = new HashMap&lt;&gt;();
        HashMap&lt;String, Object&gt; map2 = new HashMap&lt;&gt;()&#123;&#125;;//匿名类
        HashMap&lt;String, Object&gt; map3 = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;Key1&quot;,&quot;Value1&quot;);
                put(&quot;Key2&quot;,&quot;Value2&quot;);
                put(&quot;Key3&quot;,&quot;Value3&quot;);
            &#125;
        &#125;;
        System.out.println(map3.get(&quot;Key1&quot;));
    &#125;
&#125;
</code></pre>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是在原来内部类的基础上加了<code>static</code>关键字，它不再依附于<code>Outer</code>，所以不会再使用<code>Outer.this</code>来引用，并且它还可以访问Outer的private静态字段和方法，但作用域仅在<code>Outer</code>类。</p>
<pre><code class="java">/**
 * 测试静态内部类
 * @author xccit
 */
public class StaticInnerClass &#123;
    public static void main(String[] args) &#123;
        Outerr.Innerr in = new Outerr.Innerr();
        in.sayHello();
    &#125;
&#125;

class Outerr&#123;
    static String NAME = &quot;xccit&quot;;
    private String name;
    public Outerr(String name)&#123;
        this.name = name;
    &#125;

    static class Innerr&#123;
        void sayHello()&#123;
            System.out.println(&quot;Hello &quot;+Outerr.NAME);
        &#125;
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #00a596">Java</a>
        </span>
        
    </div>
    <a href="/2024/08/08/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/08/Linux%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/">
        <h2 class="post-title">Linux挂载光盘安装软件</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="挂载光盘安装Linux软件包"><a href="#挂载光盘安装Linux软件包" class="headerlink" title="挂载光盘安装Linux软件包"></a>挂载光盘安装Linux软件包</h1><pre><code class="shell">mkdir /media/CentOS
mount -t /dev/cdrom /media/CentOS
df -HT
cd /etc/yum.repos.d/
mkdir ./bak
mv ./*.repo ./bak/
cp ./bak/CentOS-Media.repo .
vim CentOS-Media.repo
</code></pre>
<p>更改后的文件:</p>
<pre><code class="shell"># CentOS-Media.repo
#
#  This repo can be used with mounted DVD media, verify the mount point for
#  CentOS-7.  You can use this repo and yum to install items directly off the
#  DVD ISO that we release.
#
# To use this repo, put in your DVD and use it with the other repos too:
#  yum --enablerepo=c7-media [command]
#  
# or for ONLY the media repo, do this:
#
#  yum --disablerepo=\* --enablerepo=c7-media [command]

[c7-media]
name=CentOS-$releasever - Media
baseurl=file:///media/CentOS7/  ---需要改的地方，挂载的光驱
gpgcheck=1
enabled=1 ---从0改到1开启光驱
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

~                                                                               
~                                                                               
~                                                
</code></pre>
<p> 依次执行以下命令:  </p>
<pre><code class="shell">yum clean all
yum repolist
yum install ftp
</code></pre>
<h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><pre><code class="shell">yum install telnet telnet-server xinetd
service xinetd start
vim /etc/xinetd.d/telnet
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210415185927765.png" alt="image-20210415185927765"></p>
<pre><code class="shell">service xinetd restart
</code></pre>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><pre><code class="shell">yum install sshd  / openssh*
service sshd start
</code></pre>
<h2 id="Vsftpd"><a href="#Vsftpd" class="headerlink" title="Vsftpd"></a>Vsftpd</h2><pre><code class="shell">yum install vsftpd
service vsftpd start
iptables -I INPUT -p tcp 21 --dport -j ACCEPT
iptables -I INPUT -p udp 21 --dport -j ACCEPT
vim /etc/vsftpd/vsftpd.conf,修改anonymous_enable = NO  --禁止匿名用户登陆
去掉chroot_local_user = yes前的注释，限制用户访问家目录之外的地方
</code></pre>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><pre><code class="shell">yum install mysql mysql-server mysql-devel
service mysqld start
mysql -u root password &#39;password&#39;   --给mysql的root用户设置密码
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Linux/" style="color: #03a9f4">Linux</a>
        </span>
        
    </div>
    <a href="/2024/08/08/Linux%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/05/SpringBoot-validation%E5%A6%82%E4%BD%95%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/">
        <h2 class="post-title">SpringBoot-validation如何分组校验</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SpringBoot-validation如何分组校验"><a href="#SpringBoot-validation如何分组校验" class="headerlink" title="SpringBoot-validation如何分组校验"></a>SpringBoot-validation如何分组校验</h1><h2 id="1-分组校验的场景"><a href="#1-分组校验的场景" class="headerlink" title="1.分组校验的场景"></a>1.分组校验的场景</h2><p><code>实体类:</code></p>
<pre><code class="java">/**
* 
* @TableName category
*/
public class Category implements Serializable &#123;


    /**
    * ID
    */
    @NotNull(message=&quot;[ID]不能为空&quot;)
    @ApiModelProperty(&quot;ID&quot;)
    private Integer id;
    /**
    * 分类名称
    */
    @NotBlank(message=&quot;[分类名称]不能为空&quot;)
    @Size(max= 32,message=&quot;编码长度不能超过32&quot;)
    @ApiModelProperty(&quot;分类名称&quot;)
    @Length(max= 32,message=&quot;编码长度不能超过32&quot;)
    private String categoryName;
    /**
    * 分类别名
    */
    @NotBlank(message=&quot;[分类别名]不能为空&quot;)
    @Size(max= 32,message=&quot;编码长度不能超过32&quot;)
    @ApiModelProperty(&quot;分类别名&quot;)
    @Length(max= 32,message=&quot;编码长度不能超过32&quot;)
    private String categoryAlias;
    /**
    * 创建人ID
    */
    @ApiModelProperty(&quot;创建人ID&quot;)
    private Integer createUser;
    /**
    * 创建时间
    */
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)
    @ApiModelProperty(&quot;创建时间&quot;)
    private LocalDateTime createTime;
    /**
    * 修改时间
    */
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)
    @ApiModelProperty(&quot;修改时间&quot;)
    private LocalDateTime updateTime;

    /**
    * ID
    */
    public void setId(Integer id)&#123;
    this.id = id;
    &#125;

    /**
    * 分类名称
    */
    public void setCategoryName(String categoryName)&#123;
    this.categoryName = categoryName;
    &#125;

    /**
    * 分类别名
    */
    public void setCategoryAlias(String categoryAlias)&#123;
    this.categoryAlias = categoryAlias;
    &#125;

    /**
    * 创建人ID
    */
    public void setCreateUser(Integer createUser)&#123;
    this.createUser = createUser;
    &#125;

    /**
    * 创建时间
    */
    public void setCreateTime(LocalDateTime createTime)&#123;
    this.createTime = createTime;
    &#125;

    /**
    * 修改时间
    */
    public void setUpdateTime(LocalDateTime updateTime)&#123;
    this.updateTime = updateTime;
    &#125;


    /**
    * ID
    */
    public Integer getId()&#123;
    return this.id;
    &#125;

    /**
    * 分类名称
    */
    public String getCategoryName()&#123;
    return this.categoryName;
    &#125;

    /**
    * 分类别名
    */
    public String getCategoryAlias()&#123;
    return this.categoryAlias;
    &#125;

    /**
    * 创建人ID
    */
    public Integer getCreateUser()&#123;
    return this.createUser;
    &#125;

    /**
    * 创建时间
    */
    public LocalDateTime getCreateTime()&#123;
    return this.createTime;
    &#125;

    /**
    * 修改时间
    */
    public LocalDateTime getUpdateTime()&#123;
    return this.updateTime;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Category&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, categoryName=&#39;&quot; + categoryName + &#39;\&#39;&#39; +
                &quot;, categoryAlias=&#39;&quot; + categoryAlias + &#39;\&#39;&#39; +
                &quot;, createUser=&quot; + createUser +
                &quot;, createTime=&quot; + createTime +
                &quot;, updateTime=&quot; + updateTime +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p><strong>上面的实体类定义中,通过使用注解的方式来开启对各个字段的值进行校验,不符合规则的值将会通过抛异常的方式返回前端</strong></p>
<p><code>再来看Controller</code></p>
<pre><code class="java">/**
     * 添加分类
     * @param category
     * @return
     */
    @Operation(summary = &quot;添加分类&quot;)
    @PostMapping()
    public AjaxResult insert(@RequestBody @Validated Category category) &#123;
        categoryService.insert(category);
        return AjaxResult.success(AjaxHttpStatus.SUCCESS);
    &#125;

    /**
     * 修改分类
     * @param category
     * @return
     */
    @Operation(summary = &quot;修改分类&quot;)
    @PutMapping
    public AjaxResult update(@RequestBody @Validated Category category) &#123;
        categoryService.update(category);
        return AjaxResult.success(AjaxHttpStatus.SUCCESS);
    &#125;
</code></pre>
<p>**通过<code>@Validated</code>**注解开启校验规则,但是我们需要看两个请求的场景:</p>
<h3 id="1-1-修改"><a href="#1-1-修改" class="headerlink" title="1.1 修改"></a>1.1 修改</h3><p>修改接口中，我们需要使用到实体类的主键ID进行修改，那实体类中id字段上面的@NotNull貌似是合理的，我们看结果：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805131959778.png" alt="image-20240805131959778"></p>
<h3 id="1-2-添加"><a href="#1-2-添加" class="headerlink" title="1.2 添加"></a>1.2 添加</h3><p>在添加接口中，我们肯定是不会传ID的，毕竟数据库里面ID排到了多少，加上我们可能还会进行删除等测试，那ID谁又能知道是多少。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805132401050.png" alt="image-20240805132401050"></p>
<p>这里捕获到了异常：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805132516315.png" alt="image-20240805132516315"></p>
<pre><code class="java">    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public AjaxResult handleConstraintViolationException(ConstraintViolationException ex) &#123;
        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = ex.getConstraintViolations();
        List&lt;ConstraintViolation&lt;?&gt;&gt; list = constraintViolations.stream().toList();
        System.out.println(list);
        return AjaxResult.fail(AjaxHttpStatus.REQUEST_PARAM_ERROR);
    &#125;

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public AjaxResult handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123;
        return AjaxResult.fail(AjaxHttpStatus.REQUEST_PARAM_ERROR);
    &#125;
</code></pre>
<p>那这种场景下，我们难道要将实体类新建两次，每一种场景都用一个吗？答案肯定是不行，毕竟哪个开发有这么多精力一直去新建实体类。那有什么好的办法吗？答案是有的：分组校验</p>
<h2 id="2-分组校验的使用"><a href="#2-分组校验的使用" class="headerlink" title="2.分组校验的使用"></a>2.分组校验的使用</h2><h3 id="2-1-实体类中分别定义关于修改和添加到接口："><a href="#2-1-实体类中分别定义关于修改和添加到接口：" class="headerlink" title="2.1 实体类中分别定义关于修改和添加到接口："></a>2.1 实体类中分别定义关于修改和添加到接口：</h3><pre><code class="java">public class Category implements Serializable &#123;

    public interface Insert &#123;&#125;
    public interface Update &#123;&#125;
    
    //xxx其他代码
&#125;
</code></pre>
<h3 id="2-2-在校验的注解上加上groups属性"><a href="#2-2-在校验的注解上加上groups属性" class="headerlink" title="2.2 在校验的注解上加上groups属性"></a>2.2 在校验的注解上加上groups属性</h3><pre><code class="java"> /**
    * ID
    */
@NotNull(message=&quot;[ID]不能为空&quot;, groups = &#123;Update.class&#125;)
@ApiModelProperty(&quot;ID&quot;)
private Integer id;
/**
* 分类名称
*/
@NotBlank(message=&quot;[分类名称]不能为空&quot;,groups = &#123;Insert.class, Update.class&#125;)
@Size(max= 32,message=&quot;编码长度不能超过32&quot;)
@ApiModelProperty(&quot;分类名称&quot;)
@Length(max= 32,message=&quot;编码长度不能超过32&quot;)
private String categoryName;
/**
* 分类别名
*/
@NotBlank(message=&quot;[分类别名]不能为空&quot;,groups = &#123;Insert.class, Update.class&#125;)
@Size(max= 32,message=&quot;编码长度不能超过32&quot;)
@ApiModelProperty(&quot;分类别名&quot;)
@Length(max= 32,message=&quot;编码长度不能超过32&quot;)
private String categoryAlias;
</code></pre>
<h3 id="2-3-Controller方法上在-Validated指定校验的分组接口"><a href="#2-3-Controller方法上在-Validated指定校验的分组接口" class="headerlink" title="2.3 Controller方法上在@Validated指定校验的分组接口"></a>2.3 Controller方法上在@Validated指定校验的分组接口</h3><pre><code class="java"> /**
 * 添加分类
 * @param category
 * @return
 */
@Operation(summary = &quot;添加分类&quot;)
@PostMapping()
public AjaxResult insert(@RequestBody @Validated(Category.Insert.class) Category category) &#123;
    categoryService.insert(category);
    return AjaxResult.success(AjaxHttpStatus.SUCCESS);
&#125;

/**
 * 修改分类
 * @param category
 * @return
 */
@Operation(summary = &quot;修改分类&quot;)
@PutMapping
public AjaxResult update(@RequestBody @Validated(Category.Update.class) Category category) &#123;
    categoryService.update(category);
    return AjaxResult.success(AjaxHttpStatus.SUCCESS);
&#125;
</code></pre>
<p><strong>来，测试一把：</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805133113950.png" alt="image-20240805133113950"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805133144739.png" alt="image-20240805133144739"></p>
<p><strong>数据库中的结果：</strong><br><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240805133218945.png" alt="image-20240805133218945"></p>
<h2 id="3-项目地址"><a href="#3-项目地址" class="headerlink" title="3.项目地址"></a>3.项目地址</h2><h3 id="3-1-github"><a href="#3-1-github" class="headerlink" title="3.1 github"></a>3.1 github</h3><p><a target="_blank" rel="noopener" href="https://github.com/xccit/big-event">xccit&#x2F;big-event: 大事件(黑马程序员项目改造) (github.com)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot/" style="color: #ff7d73">SpringBoot</a>
        </span>
        
    </div>
    <a href="/2024/08/05/SpringBoot-validation%E5%A6%82%E4%BD%95%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/03/JWT-SpringBoot%E5%81%9A%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/">
        <h2 class="post-title">JWT+SpringBoot做登录拦截</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SpringBoot-JWT做登录拦截"><a href="#SpringBoot-JWT做登录拦截" class="headerlink" title="SpringBoot+JWT做登录拦截"></a>SpringBoot+JWT做登录拦截</h1><h2 id="1-为什么要做登录拦截"><a href="#1-为什么要做登录拦截" class="headerlink" title="1.为什么要做登录拦截?"></a>1.为什么要做登录拦截?</h2><p>项目为了防止接口被滥用,一般都会在除登录以及一些静态资源的访问之外将其他接口保护起来,为了安全访问必须登录之后才行。</p>
<h2 id="2-项目准备工作"><a href="#2-项目准备工作" class="headerlink" title="2.项目准备工作"></a>2.项目准备工作</h2><h3 id="2-1-实体类"><a href="#2-1-实体类" class="headerlink" title="2.1 实体类"></a>2.1 实体类</h3><h3 id="2-2-Controller-Service-Mapper三件套"><a href="#2-2-Controller-Service-Mapper三件套" class="headerlink" title="2.2 Controller,Service,Mapper三件套"></a>2.2 Controller,Service,Mapper三件套</h3><h3 id="2-3-返回的状态信息"><a href="#2-3-返回的状态信息" class="headerlink" title="2.3 返回的状态信息"></a>2.3 返回的状态信息</h3><blockquote>
<p>AjaxResult,AjaxHttpStatus</p>
</blockquote>
<h2 id="3-拦截器定义"><a href="#3-拦截器定义" class="headerlink" title="3.拦截器定义"></a>3.拦截器定义</h2><pre><code class="java">package io.xccit.event.interceptor;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.xccit.event.resut.AjaxHttpStatus;
import io.xccit.event.resut.AjaxResult;
import io.xccit.event.utils.JwtUtil;
import io.xccit.event.utils.ThreadLocalUserUtil;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.Map;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/8/3
 * &lt;p&gt;登录拦截器&lt;/p&gt;
 */
@Component
public class LoginInterceptor implements HandlerInterceptor &#123;

    private final ObjectMapper objectMapper = new ObjectMapper();
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        String authorization = request.getHeader(&quot;Authorization&quot;);
        try &#123;
            Map&lt;String, Object&gt; claims = JwtUtil.verify(authorization);
            ThreadLocalUserUtil.set(claims);
            return true;
        &#125; catch (Exception e) &#123;
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;UTF-8&quot;);
            response.setStatus(AjaxHttpStatus.UNAUTHORIZED.getCode());
            return false;
        &#125;
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        ThreadLocalUserUtil.remove();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>以上代码中，由于项目没有使用SpringSecurity权限管理框架，所以在没有权限的状态下，默认只能拦截请求，也就是在preHandle函数返回false，那这种情况下对于用户来说,体验就很差。优化建议:</p>
<p>1.导入Jackson库:使用Jackson库将AjaxResult对象转换为JSON字符串。<br>2.创建ObjectMapper实例:在类级别创建一个ObjectMapper实例，用于序列化AjaxResult对象。<br>3.构造AjaxResult:当JWT验证失败时，创建一个AjaxResult实例，设置状态码为401（未授权），并将其作为响应体的内容。<br>4.序列化和写入响应:使用ObjectMapper将AjaxResult对象序列化为JSON字符串。<br>5.使用response.getWriter()获取响应输出流，并将JSON字符串写入其中。这样，当JWT验证失败时，前端将收到一个符合AjaxResult格式的错误响应。</p>
</blockquote>
<p><strong>优化后的拦截器:</strong></p>
<pre><code class="java">package io.xccit.event.interceptor;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.xccit.event.resut.AjaxHttpStatus;
import io.xccit.event.resut.AjaxResult;
import io.xccit.event.utils.JwtUtil;
import io.xccit.event.utils.ThreadLocalUserUtil;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.Map;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/8/3
 * &lt;p&gt;登录拦截器&lt;/p&gt;
 */
@Component
public class LoginInterceptor implements HandlerInterceptor &#123;

    private final ObjectMapper objectMapper = new ObjectMapper();
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        String authorization = request.getHeader(&quot;Authorization&quot;);
        try &#123;
            Map&lt;String, Object&gt; claims = JwtUtil.verify(authorization);
            ThreadLocalUserUtil.set(claims);
            return true;
        &#125; catch (Exception e) &#123;
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;UTF-8&quot;);
            response.setStatus(AjaxHttpStatus.UNAUTHORIZED.getCode());
            AjaxResult&lt;Void&gt; result = AjaxResult.fail(AjaxHttpStatus.UNAUTHORIZED);
            response.getWriter().write(objectMapper.writeValueAsString(result));
            return false;
        &#125;
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        ThreadLocalUserUtil.remove();
    &#125;
&#125;
</code></pre>
<p>这样,当我们<code>未登录</code>时,返回的信息如下:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240803232806469.png" alt="image-20240803232806469"></p>
<p><code>登录后:</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240803232855964.png" alt="image-20240803232855964"></p>
<p>完整代码,请访问我的github主页: <a target="_blank" rel="noopener" href="https://github.com/xccit">xccit (github.com)</a></p>
<p>项目地址:<a target="_blank" rel="noopener" href="https://github.com/xccit/big-event">xccit&#x2F;big-event (github.com)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot/" style="color: #00bcd4">SpringBoot</a>
        </span>
        
    </div>
    <a href="/2024/08/03/JWT-SpringBoot%E5%81%9A%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">
        2
    </a>
    
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/myavatar.jpg" alt="avatar" />
        </div>
        <div class="name">CH_ywx</div>
        <div class="description">
            <p>贩卖温柔の優しさを振りまく<br>   QQ: 1571466236<br>WECHAT: lucky_all_time_max</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 xccitのblog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;CH_ywx
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>

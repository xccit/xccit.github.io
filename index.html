
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>xccitのblog</title>
    <meta name="author" content="CH_ywx" />
    <meta name="description" content="人生如逆旅,我亦是行人" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/myavatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XCCITのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XCCITのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>xccitのblog</h1>
                <h3>like life | like myself</h3>
                <h5>人生如逆旅,我亦是行人</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/10/27/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
        <h2 class="post-title">常用开发环境搭建</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <blockquote>
<p><code>注意</code>:MySQL集群不用管,直接本机安装MySQL即可。Windows能安装对应的服务就直接安装，安装不了的用<code>WSL</code>，<code>不要用Docker</code>,<code>不要用Docker</code>,<code>不要用Docker</code></p>
</blockquote>
<h2 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1.基础环境搭建"></a>1.基础环境搭建</h2><h3 id="1-1虚拟机-云服务器"><a href="#1-1虚拟机-云服务器" class="headerlink" title="1.1虚拟机&#x2F;云服务器"></a>1.1虚拟机&#x2F;云服务器</h3><h4 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h4><p>开启安全组规则</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023233422392.png" alt="image-20241023233422392"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023233447431.png" alt="image-20241023233447431"></p>
<p><code>redis:6379</code></p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul>
<li><p>创建CentOS7镜像</p>
</li>
<li><p>NAT网络连接</p>
</li>
<li><p>端口转发规则</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023233646668.png" alt="image-20241023233646668"></p>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023233721797.png" alt="image-20241023233721797"></p>
<p><code>主要注意5022到22的映射,其他端口都是一致的,按照安全组规则的端口进行转发即可</code></p>
<ul>
<li><p>使用MobaXterm连接虚拟机,IP填localhost,端口5022,能连接成功则代表端口转发成功</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023234130998.png" alt="image-20241023234130998"></p>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241023234213481.png" alt="image-20241023234213481"></p>
<ul>
<li>基础的环境设置基本完成,关于<code>MobaXterm</code>的更多使用方式参考官网即可。<a target="_blank" rel="noopener" href="https://mobaxterm.mobatek.net/">MobaXterm free Xserver and tabbed SSH client for Windows</a></li>
</ul>
<h3 id="1-2安装Docker"><a href="#1-2安装Docker" class="headerlink" title="1.2安装Docker"></a>1.2安装Docker</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024080824446.png" alt="image-20241024080824446"></p>
<blockquote>
<p> 为了节省时间(避免在物理机上安装时繁琐的配置)以及避免程序间冲突,使用Docker来安装开发环境需要使用到的软件以及服务</p>
</blockquote>
<h4 id="1-2-1关闭SELINUX"><a href="#1-2-1关闭SELINUX" class="headerlink" title="1.2.1关闭SELINUX"></a>1.2.1关闭SELINUX</h4><pre><code class="shell">vim /etc/sysconfig/selinux
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024082216153.png" alt="image-20241024082216153"></p>
<pre><code class="shell">esc---&gt;:wq
</code></pre>
<p><code>重启CentOS</code></p>
<h4 id="1-2-2更新yum"><a href="#1-2-2更新yum" class="headerlink" title="1.2.2更新yum"></a>1.2.2更新yum</h4><pre><code class="shell">yum update -y
</code></pre>
<h4 id="1-2-3安装docker"><a href="#1-2-3安装docker" class="headerlink" title="1.2.3安装docker"></a>1.2.3安装docker</h4><pre><code class="shell">yum install docker -y
</code></pre>
<h4 id="1-2-4启动-停止docker"><a href="#1-2-4启动-停止docker" class="headerlink" title="1.2.4启动&#x2F;停止docker"></a>1.2.4启动&#x2F;停止docker</h4><pre><code class="shell"># 启动
service docker start
# 停止
service docker stop
</code></pre>
<h4 id="1-2-5镜像命令"><a href="#1-2-5镜像命令" class="headerlink" title="1.2.5镜像命令"></a>1.2.5镜像命令</h4><pre><code class="shell"># 查看所有镜像
docker images
# 删除镜像,前提:镜像已关闭
docker rmi 镜像名
# 拉取镜像
docker pull 镜像名
</code></pre>
<h2 id="2-MySQL集群读写分离与主从同步原理"><a href="#2-MySQL集群读写分离与主从同步原理" class="headerlink" title="2.MySQL集群读写分离与主从同步原理"></a>2.MySQL集群读写分离与主从同步原理</h2><p>一个<code>高可用、高负载、高性能</code>的<code>三高</code>MySQL集群，至少需要<code>12</code>个MySQL节点。为什么需要这么多节点呢?</p>
<h3 id="2-1数据同步"><a href="#2-1数据同步" class="headerlink" title="2.1数据同步"></a>2.1数据同步</h3><p>单节点的MySQL抗风险性很差，就这么一个MySQL，如果遇上故障数据库挂了，咱们开发的软件项目也就没法用<br>了。不管做的是电商、医疗、外卖、出行业务，软件系统全都歇菜了。俗话说鸡蛋不要放在一个篮子里，我们的<br>MySQL要有冗余节点。<br>既然要添加冗余节点，就必须借助于<code>数据同步</code>，保证两个MSQL节点数据完全一致。这样挂掉任何一个节点，另一个节点都能立即接替工作。MySQL白带了Master-Slave数据同步模式，也被称作主从同步模式。例如:MySQL A节点开启了binlog日志文件之后，MySQL A上面执行SQL语句(查询语句除外)都会被记录在binlog日志里面。MySQL B节点通过订阅MySOL A的binlog文件，能实时下载到这个日志文件，然后在MySOL B节点上运行这些SQL语句，于是就保证了自己的数据和MySQL A节点一致。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024090251808.png" alt="image-20241024090251808" style="zoom:50%;" />

<h3 id="2-2读写分离"><a href="#2-2读写分离" class="headerlink" title="2.2读写分离"></a>2.2读写分离</h3><p>绝大多数Web系统都是读多写少的，比如电商网站，我们都是要货比三家，然后再下单购买。无论MySQL A还是<br>MySQL B单独工作的时候，读写操作都由一个节点执行，压力确实很大，所以我们可以给MySQL找帮手。于是搭<br>建MySQL集群的时候，我划定MySQL A用来处理写任务，MySQL B和MySQL C负责处理读请求。原来一个节点处理所有SQL语句变成三个节点来分担，MySQL集群的读写性能比单节点MySQL是翻倍的，能并发执行的SQL语句条数也翻倍了。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024091454057.png" alt="image-20241024091454057" style="zoom:50%;" />

<p>上面的方案是”一主两从”，MySQL A节点负责写任务，MySQL B和MySQL C来处理读请求,但A和B、C的<code>主仆</code>身份是固定的,假如MySQL A宕机,那B和C都不能升级为写节点。解决这种困难的方式就是给MySQL A添加一个<code>双向同步</code>的MySQL D节点。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024121755795.png" alt="image-20241024121755795" style="zoom:50%;" />

<p>这种双向同步的解决方案,会在MySQL A宕机后,MySQL D接替MySQL A的写任务,并且由于MySQL A宕机,MySQL B与C的数据也无法同步,这个时候的读节点就会使用到MySQL E与F,因为MySQL B与C无法自动切换到MySQL D节点下同步,所以给MySQL D配置了两个读节点:MySQL E与F。反之如果MySQL D宕机,那么写节点为MySQL A,读节点为MySQL B与C。</p>
<p>通俗来说,封建时期的帝王家族,如果兄弟或者亲人之间篡位成功,势必要干掉旧皇帝的老臣,让自己的部下来弥补,读写分离的主节点切换亦是如此。</p>
<h3 id="2-3数据切分"><a href="#2-3数据切分" class="headerlink" title="2.3数据切分"></a>2.3数据切分</h3><p>以中型电商系统为例,如果一张表的数据量达到2000万行,读写性能会急剧下降,这个时候就需要分库分表(数据切分),一个中型电商系统以订单表为例,每天大概会有2w条数据,一年就是大概730w条数据,一个MySQL节点肯定是不太够用的,我们以10个节点来存储的话,一个节点每年有73w条数据,这个时候数据库的压力就很小了。</p>
<p>数据切分最基本的实现方式是对<code>表的主键取余</code>,以10个节点为例,每次数据库进行<code>INSERT</code>操作时,将主键对10取余,余数必然在0~9之间,以余数的值为参照,余数为0则MyCat将INSERT语句发送给MySQL A节点执行,1为MySQL B,以此类推。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024172724194.png" alt="image-20241024172724194" style="zoom:50%;" />

<h3 id="2-4数据切分架构优化"><a href="#2-4数据切分架构优化" class="headerlink" title="2.4数据切分架构优化"></a>2.4数据切分架构优化</h3><p>数据切分也要满足<code>三高</code>–&gt;<code>高性能,高负载,高可用</code></p>
<p>由于上面的架构中,MyCat下面有10个<code>切片</code>(A~J),但是以A为例,如果宕机,那没有能够接替A工作的切片,这个时候就要考虑对A进行优化了,以下图为例,将A分为A1和B1两个主节点,有A2,A3,B2,B3四个从节点,A1与B1之间双向同步,如果A1宕机,B1马上接替A1的工作。也就是说，这一个中型电商网站总共需要<code>60</code>个MySQL节点。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024174647292.png" alt="image-20241024174647292"></p>
<p>当然，如果60个节点还不够用，后期要么使用<code>增加切片</code>的方案,但是增加切片又要重新牵扯到数据切分与数据迁移,这个成本还是很高的,第二种方案就是使用<code>定期缩表</code>的方式,例如将几年前的数据迁移到HBase或者MongoDB这种大数据平台中,对于它们来说,缓存这些数据毫无压力,MySQL中只存储近几年的数据即可。</p>
<h3 id="2-5本项目的解决方案"><a href="#2-5本项目的解决方案" class="headerlink" title="2.5本项目的解决方案"></a>2.5本项目的解决方案</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241024175516493.png" alt="image-20241024175516493"></p>
<p>数据量不会太大,即使商用,每天可能几百条数据顶天了,使用读写分离+双向同步,也就是<code>主2从4</code>的MySQL集群方案即可。</p>
<h3 id="2-6选用的版本"><a href="#2-6选用的版本" class="headerlink" title="2.6选用的版本"></a>2.6选用的版本</h3><p>使用MySQL<code>5.7</code>版本,因为<code>8.0</code>版本在某个主节点宕机修复完成之后,需要人工对比日志和维护,才能重新实现数据同步。比如A和B为<code>双向主动同步</code>,但是A节点宕机修复后,按道理A节点应该主动去B节点处同步数据,但是MySQL8.0无法自动完成。人工对比日志时，MySQL B节点必然还会有数据涌入，这个时候就不得不停掉整个后端业务来进行日志比对，然后再执行若干命令帮助MySQL A节点从MySQL B节点处同步数据，然后实现数据同步之后重新启动后端，这个成本实在是太高，所以使用MySQL5.7这种稳定的版本才更为可靠。</p>
<h3 id="2-7中间件对比"><a href="#2-7中间件对比" class="headerlink" title="2.7中间件对比"></a>2.7中间件对比</h3><table>
<thead>
<tr>
<th>中间件</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>MyCat</td>
<td>- 支持多种分片策略<br>- 提供了丰富的SQL优化功能<br>- 具有良好的可扩展性</td>
<td>- 配置相对复杂<br>- 社区支持不如其他两种广泛</td>
</tr>
<tr>
<td>ShardingSphere</td>
<td>- 完全兼容MySQL语法<br>- 提供了强大的数据治理能力<br>- 可以在应用层实现数据分片</td>
<td>- 性能可能略低于原生数据库<br>- 对于一些复杂的查询可能需要手动编写SQL</td>
</tr>
<tr>
<td>ProxySQL</td>
<td>- 高性能，低延迟<br>- 支持读写分离和负载均衡<br>- 管理界面友好，易于配置</td>
<td>- 不支持所有类型的数据库（主要针对MySQL）<br>- 对于某些高级特性如事务处理的支持有限</td>
</tr>
</tbody></table>
<p>即便<code>MyCat</code>每年只更新一个版本，也可以了。毕竟数据库产品本身变化就不大，每年出一个版本修补一<br>下BUG就够了。MyCat是阿里巴巴的产品，大家可以放心使用。而且MyCat有非常完备的资料，官方提供了400多页的《MyCat权威指南》，几乎把MyCat给讲透彻了，就凭这一点绝对给好评。</p>
<p>根据现有的信息，MyCat的1.6系列版本中，1.6.5及之后的版本被认为是比较稳定的。特别是，有提到1.6.7.x版本也是稳定的选择，例如1.6.7.6版本被特定提及作为一个稳定版本。因此，在当前情况下，如果您正在寻找一个较为稳定的Mycat版本，可以考虑使用1.6.5或更高版本，如1.6.7.6。不过，最稳妥的做法是访问Mycat的官方资源或GitHub页面来获取最新版本的信息和确认其稳定性。此外，确保查阅相关的变更日志和社区反馈，以便了解任何潜在的问题或更新。<a target="_blank" rel="noopener" href="http://www.mycat.org.cn/">| MYCAT官方网站—中国第一开源分布式数据库中间件</a></p>
<h2 id="3-搭建MySQL集群"><a href="#3-搭建MySQL集群" class="headerlink" title="3.搭建MySQL集群"></a>3.搭建MySQL集群</h2><blockquote>
<p><code>Linux基础命令与vim的基本使用需要熟练掌握</code></p>
<p>补充内容：<code>推荐的方式是：启动1--&gt;加1用户--&gt;关闭1--&gt;改1配置--&gt;启动1--&gt;启动2--&gt;关闭2--&gt;改2配置--&gt;启动2--&gt;启动3--&gt;关闭3--&gt;改3配置--&gt;启动3--&gt;开启2,3与1的主从同步</code></p>
<p>按照以上步骤,执行4,5,6(特别注意<code>4</code>与<code>1</code>的操作要如出一辙)</p>
<p><code>最后开启1与4的双向数据同步</code></p>
</blockquote>
<p>目前Docker已无法正常访问,使用:</p>
<pre><code class="shell">docker pull m.daocloud.io/docker.io/library/mysql:5.7.41
</code></pre>
<p>来下载镜像。</p>
<h3 id="3-1配置docker网段"><a href="#3-1配置docker网段" class="headerlink" title="3.1配置docker网段"></a>3.1配置docker网段</h3><p>由于Docker容器的IP地址是动态分配的，每次启动相同容器，它的IP地址都会有变化。这就非常影响数据库集群<br>的搭建，比如说MySQL B要同步MySQL A的数据，MySOL A容器的IP地址经常变来变去肯定是不行的，所以我<br>们要给每个Docker容器都分配固定的IP地址。<br>Docker默认的网段是 172.17.0.x的，有时候不同项目用到的容器都在同一个网段里面，难免我们使用的时候会<br>弄混淆了。所以不同项目用到的容器最好放在不同的网段。于是我们要为咱们的项目创建一个新的网段，创建容器<br>的时候，把它们的IP地址绑定到该网段。执行下面的命令，创建新的网段:</p>
<pre><code class="shell">docker network create --subnet=172.18.0.0/18 customnet
</code></pre>
<h3 id="3-2创建MySQL节点"><a href="#3-2创建MySQL节点" class="headerlink" title="3.2创建MySQL节点"></a>3.2创建MySQL节点</h3><p>MySQL运行镜像创建一个容器的命令为:</p>
<pre><code class="shell">docker run -it -d --name mysql_1 -p 7001:3306 \
  --net customnet --ip 172.18.0.2 \
  -m 400m -v /root/mysql_1/data:/var/lib/mysql \
  -v /root/mysql_1/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<blockquote>
<ul>
<li><code>docker run</code>: 创建并运行一个新的容器。</li>
<li><code>-it</code>: 使容器在交互模式下运行，并分配一个伪TTY（即使没有附加到终端也允许容器接收输入）。但是，因为后面有 <code>-d</code> 参数，<code>-it</code> 在这里不会生效，因为 <code>-d</code> 会使容器在后台运行。</li>
<li><code>-d</code>: 在后台运行容器。</li>
<li><code>--name mysql_1</code>: 给容器指定一个名字<code>mysql_1</code>。</li>
<li><code>-p 7001:3306</code>: 将宿主机的7001端口映射到容器内的3306端口。</li>
<li><code>--net customnet --ip 172.18.0.2</code>: 将容器连接到名为<code>customnet</code>的自定义网络，并且在这个网络中使用固定的IP地址<code>172.18.0.2</code>。</li>
<li><code>-m 400m</code>: 设置容器的最大可用内存为400MB。</li>
<li><code>-v /root/mysql_1/data:/var/lib/mysql</code>: 将宿主机上的<code>/root/mysql_1/data</code>目录挂载到容器内的<code>/var/lib/mysql</code>目录，用来持久化MySQL的数据文件。</li>
<li><code>-v /root/mysql_1/config:/etc/mysql/conf.d</code>: 将宿主机上的<code>/root/mysql_1/config</code>目录挂载到容器内的<code>/etc/mysql/conf.d</code>目录，用来放置MySQL的额外配置文件。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=1209</code>: 设置MySQL的root用户的密码为<code>1209</code>。</li>
<li><code>-e TZ=Asia/Shanghai</code>: 设置容器内部的时间区域为上海（Asia&#x2F;Shanghai）。</li>
<li><code>--privileged=true</code>: 提供更多的权限给容器，允许容器执行某些需要root权限的操作。这通常是不必要的，除非你需要访问底层系统的特定功能。</li>
<li><code>mysql:5.7.41</code>: 使用名为<code>mysql:5.7.41</code>的镜像来创建容器。</li>
<li><code>--lower_case_table_names=1</code>: 传递给MySQL服务的启动参数，设置表名和列名在Linux系统上为小写敏感（即所有表名和列名都会转换为小写）。</li>
</ul>
<p>请注意，<code>--privileged</code>标志应该谨慎使用，因为它可能增加安全风险。只有当确实需要时才应启用该选项。此外，如果你不需要与容器进行交互，可以去掉<code>-it</code>选项。</p>
</blockquote>
<ul>
<li><p>mysql_1</p>
<blockquote>
<p><code>注意</code>：咱们的镜像名应该是m.daocloud.io&#x2F;library&#x2F;mysql:5.7.41,使用</p>
<pre><code class="shell">docker tag m.daocloud.io/library/mysql:5.7.41 mysql:5.7.41
</code></pre>
<p>改名之后使用</p>
<pre><code class="shell">docker rmi m.daocloud.io/library/mysql:5.7.41
</code></pre>
<p>删掉原来的镜像即可，后续如果有新的镜像，一律如此操作。</p>
</blockquote>
<pre><code class="shell">docker run -it -d --name mysql_1 -p 7001:3306 \
  --net customnet --ip 172.18.0.2 \
  -m 400m -v /root/mysql_1/data:/var/lib/mysql \
  -v /root/mysql_1/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
</li>
</ul>
<h3 id="3-3创建用户"><a href="#3-3创建用户" class="headerlink" title="3.3创建用户"></a>3.3创建用户</h3><p>使用<code>Navicat</code>或其他可视化工具,新建用户:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025084734925.png" alt="image-20241025084734925"></p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025084527398.png" alt="image-20241025084527398" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025084651619.png" alt="image-20241025084651619" style="zoom:50%;" />

<p><code>使用刚才创建的sync用户连接MySQL_1容器</code></p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025085111621.png" alt="image-20241025085111621" style="zoom:50%;" />

<p>测试连接能成功则代表操作是对的,否则需要检查刚才的操作。</p>
<h3 id="3-4修改配置文件"><a href="#3-4修改配置文件" class="headerlink" title="3.4修改配置文件"></a>3.4修改配置文件</h3><blockquote>
<p>首先需要停止mysql_1:</p>
<pre><code class="shell">docker stop mysql_1
</code></pre>
</blockquote>
<p>在<code>/root/mysql_1/config/</code>里创建<code>my.cnf</code>文件:</p>
<pre><code class="shell">vim /root/mysql_1/config/my.cnf
</code></pre>
<p>文件内容为:</p>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号(只能是数字)
server_id=1
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#从库的写操作是否写入binlog
log-slave-updates=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
<p>编辑完成后按<code>ESC</code>输入<code>:wq</code>写入并退出</p>
<p>然后重启mysql_1容器:</p>
<pre><code class="shell">docker start mysql_1
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025131104896.png" alt="image-20241025131104896"></p>
<h3 id="3-5创建其他MySQL节点及配置"><a href="#3-5创建其他MySQL节点及配置" class="headerlink" title="3.5创建其他MySQL节点及配置"></a>3.5创建其他MySQL节点及配置</h3><ul>
<li><p><em>mysql_2</em></p>
<pre><code class="shell">docker run -it -d --name mysql_2 -p 7002:3306 \
  --net customnet --ip 172.18.0.3 \
  -m 400m -v /root/mysql_2/data:/var/lib/mysql \
  -v /root/mysql_2/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号,只能是数字
server_id=2
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#限制普通账户无法使用INSERT UPDATE DELETE语句,但是该配置对管理员无效
read-only=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
</li>
<li><p><em>mysql_3</em></p>
<pre><code class="shell">docker run -it -d --name mysql_3 -p 7003:3306 \
  --net customnet --ip 172.18.0.4 \
  -m 400m -v /root/mysql_3/data:/var/lib/mysql \
  -v /root/mysql_3/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号,只能是数字
server_id=3
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#限制普通账户无法使用INSERT UPDATE DELETE语句,但是该配置对管理员无效
read-only=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
</li>
<li><p><em>mysql_4</em></p>
<blockquote>
<p>注意:mysql_4也是主节点,需要添加一个用户(sync—&gt;123456)</p>
<p>添加完用户后关闭,写配置,然后再启动</p>
</blockquote>
<pre><code class="shell">docker run -it -d --name mysql_4 -p 7004:3306 \
  --net customnet --ip 172.18.0.5 \
  -m 400m -v /root/mysql_4/data:/var/lib/mysql \
  -v /root/mysql_4/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号,只能是数字
server_id=4
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#从库的写操作是否写入binlog
log-slave-updates=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
</li>
<li><p><em>mysql_5</em></p>
<pre><code class="shell">docker run -it -d --name mysql_5 -p 7005:3306 \
  --net customnet --ip 172.18.0.6 \
  -m 400m -v /root/mysql_5/data:/var/lib/mysql \
  -v /root/mysql_5/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号,只能是数字
server_id=5
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#限制普通账户无法使用INSERT UPDATE DELETE语句,但是该配置对管理员无效
read-only=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
</li>
<li><p><em>mysql_6</em></p>
<pre><code class="shell">docker run -it -d --name mysql_6 -p 7006:3306 \
  --net customnet --ip 172.18.0.7 \
  -m 400m -v /root/mysql_6/data:/var/lib/mysql \
  -v /root/mysql_6/config:/etc/mysql/conf.d \
  -e MYSQL_ROOT_PASSWORD=1209 \
  -e TZ=Asia/Shanghai --privileged=true \
  mysql:5.7.41 \
  --lower_case_table_names=1
</code></pre>
<pre><code class="ini">[mysqld]
#字符集
character_set_server=utf8
#mysql编号,只能是数字
server_id=6
#开启binlog,规定文件名称
log_bin=mysql_bin
#开启relaylog,规定文件名称
relay_log=relay_bin
#限制普通账户无法使用INSERT UPDATE DELETE语句,但是该配置对管理员无效
read-only=1
#采用严格的SQL语句模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></pre>
<blockquote>
<p>注意：需要重启每一个节点</p>
<pre><code class="shell">docker restart mysql_x(替换数字)
</code></pre>
<p>1,4为主节点,2,3为1的从节点,5,6为4的从节点</p>
<p>关于2,3,5,6从节点为何开启了binlog日志?这是为了后续业务需求扩大后配置更多的从节点,如果节点过多,两个主节点的网络和磁盘压力都很大,这个时候就需要从节点跟从节点直接同步数据,为了完成这一步骤,从节点也必须开启binlog日志才行。</p>
</blockquote>
</li>
</ul>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025134017564.png" alt="image-20241025134017564" style="zoom:50%;" />

<p>如图，F节点若要挂载更多的节点，就需要开启binlog日志，然后G与H从F同步数据。</p>
<h3 id="3-6开启主从同步"><a href="#3-6开启主从同步" class="headerlink" title="3.6开启主从同步"></a>3.6开启主从同步</h3><p>使用Navicat在<code>mysql_2</code>节点上执行如下SQL语句：</p>
<pre><code class="sql">#关闭主从同步
stop slave;
#设置同步主节点的IP，端口，用户，密码
change master to master_host=&#39;172.18.0.2&#39;,master_port=3306,master_user=&#39;sync&#39;,master_password=&#39;123456&#39;;
#开启主从同步
start slave;
#查询数据同步状态
show slave status;
</code></pre>
<blockquote>
<p>注意：如果成功，上述SQL执行完之后应该会打印两次<code>YES</code>，否则就是失败了，认真检查配置以及容器是否正常。如果不行，停止容器，删除容器,删除<code>/root</code>下该mysql容器映射的文件夹从头再来。也有可能会受本机的配置影响，在执行完第三条语句后等待<code>5~10s</code>之后再执行第四条看结果是否一致。</p>
<pre><code class="shell">#停止容器
docker stop 容器名（例如：mysql_2）
#删除容器
docker rmi 容器名（例如：mysql_2）
</code></pre>
</blockquote>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025140142354.png" alt="image-20241025140142354" style="zoom:50%;" />

<blockquote>
<p>mysql_2，mysql_3容器执行的四条SQL一致</p>
<p>mysql_5，mysql_6容器执行的四条SQL一致，并且需要改一下master_host参数的值，使用mysql_4容器的IP地址，这个IP地址看你的mysql_4容器启动时使用了哪个IP，如果跟如上的配置一致，那就直接复制下面的SQL。</p>
</blockquote>
<pre><code class="sql">#关闭主从同步
stop slave;
#设置同步主节点的IP，端口，用户，密码
change master to master_host=&#39;172.18.0.5&#39;,master_port=3306,master_user=&#39;sync&#39;,master_password=&#39;123456&#39;;
#开启主从同步
start slave;
#查询数据同步状态
show slave status;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025141112039.png" alt="image-20241025141112039"></p>
<p>也可以配置完成之后批量重启:</p>
<pre><code class="shell">docker restart $&#123;docker ps -q&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025142632605.png" alt="image-20241025142632605"></p>
<blockquote>
<p>特别需要注意的是:mysql_1节点配置了一个用户:sync</p>
<p>在mysql_4节点中也同样需要,如果mysql_4节点不配置用户,则mysql_5与mysql_6配置主从同步后查询结果如下:</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025143651820.png" alt="image-20241025143651820"></p>
<p>如果是以上结果,给mysql_4节点创建sync用户后再执行一次查询即可。</p>
<h3 id="3-7双向数据同步"><a href="#3-7双向数据同步" class="headerlink" title="3.7双向数据同步"></a>3.7双向数据同步</h3><p>双向数据同步是针对两个主节点的配置操作，希望两个主节点在运行中能够相互同步数据。</p>
<blockquote>
<p>使用<code>mysql_1</code>节点执行四条SQL：</p>
<pre><code class="sql">stop slave;
change master to master_host=&#39;172.18.0.5&#39;,master_port=3306,master_user=&#39;sync&#39;,master_password=&#39;123456&#39;;
start slave;
show slave status;
</code></pre>
</blockquote>
<blockquote>
<p>接着使用<code>mysql_4</code>节点来执行四条SQL：</p>
<pre><code class="sql">stop slave;
change master to master_host=&#39;172.18.0.2&#39;,master_port=3306,master_user=&#39;sync&#39;,master_password=&#39;123456&#39;;
start slave;
show slave status;
</code></pre>
</blockquote>
<blockquote>
<p>注意:如果这一步不成功,关闭容器,观察配置文件,再次启动容器。</p>
<p>然后执行:</p>
<pre><code class="sql">SHOW MASTER STATUS;
</code></pre>
<p>分别选中mysql_1与mysql_4执行,看File与Position的值</p>
<p>然后重新执行上面的四条SQL,但是需要将第二条换一下:</p>
<pre><code class="shell">change master to master_host=&#39;172.18.0.2&#39;,master_port=3306,master_user=&#39;sync&#39;,master_password=&#39;123456&#39;,MASTER_LOG_FILE=&#39;mysql_bin.000001&#39;,MASTER_LOG_POS=622;
</code></pre>
<p>其中MASTER_LOG_FILE为你查出来对方节点的File值,MASTER_LOG_POS为你查出来的对方节点的Position</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241025184648949.png" alt="image-20241025184648949"></p>
<p>最终结果如上图所示就是对的。</p>
<h3 id="3-8测试数据同步"><a href="#3-8测试数据同步" class="headerlink" title="3.8测试数据同步"></a>3.8测试数据同步</h3><ul>
<li><p>导入SQL脚本到<code>mysql_1</code>或者<code>mysql_4</code>,观察其他mysql环境是否自动同步数据</p>
</li>
<li><p>执行docker stop mysql_2,模拟mysql_2宕机</p>
</li>
<li><p>在mysql_1中随便找一张表添加数据,过一会儿再启动mysql_2,看数据是否会自动同步</p>
</li>
</ul>
<h3 id="3-9使用MyCat管理MySQL集群"><a href="#3-9使用MyCat管理MySQL集群" class="headerlink" title="3.9使用MyCat管理MySQL集群"></a>3.9使用MyCat管理MySQL集群</h3><blockquote>
<p>Windows主机安装MyCat自行配置</p>
</blockquote>
<h3 id="3-10其他中间件"><a href="#3-10其他中间件" class="headerlink" title="3.10其他中间件"></a>3.10其他中间件</h3><ul>
<li>MinIO 图片&#x2F;视频等静态资源存储</li>
<li>Redis  数据缓存,降低MySQL读次数</li>
<li>MongoDB 存储商品快照</li>
<li>RabbitMQ 消息队列</li>
</ul>
<blockquote>
<p>本项目用MongoDB数据库存储商品快照。这里我解释一下什么是商品快照。比如说订单记录直接关联商品id，如果你买的是苹果手机。店家修改了商品信息，苹果手机变成了小米手机，那么我们用表连接查询出来的该订单买的就是小米手机，你觉得你能容忍么?肯定不能。为了避免店家修改商品信息影响到已有的订单，所以我在项目中引入了商品快照。简单的说，就是店家每次修改商品信息，都会产生一个商品快照记录。买家的订单关联的是快照记录ID。店家不管怎么修改商品信息，都只生成新的快照记录，但是该订单关联的原有快照记录是不会改变的。其实具体过程要比这复杂很多，等我们写到这部分代码的时候，我再详细说明。<br>由于店家修改商品记录会产生新的快照记录，那么日积月累下来快照表保存的记录就会很多，所以用MySQL保存快照记录就不太适合了。我们可以用MongoDB或者HBase来存储。这两个数据库都适合保存海量数据，MongoDB可以存储TB级别的数据，HBase更是可以保存PB级别的记录。至于它们两个该选择哪一个也是有<br>参考标准的。如果需要对保存的数据做复杂条件查询，建议用HBase数据库。HBase挂载了Phoenix之后，可以支持SQL语句，各种复杂的CRUD操作都不在话下。由于MongoDB不支持SQL语句，所以MongoDB只适合数据的<br>简单读写，太复杂的查询条件是不可以的。本项目保存的商品快照，需要的查询条件并不复杂，所以用<br>MongoDB就够了。</p>
</blockquote>
<p>推荐<code>MySQL、MinIO、MongoDB</code>使用Windows主机来自行安装，由于<code>Redis</code>没有适用于Windows的二进制文件安装包，所以使用<code>WSL</code>子系统来安装配置，<code>RabbitMQ</code>同样使用wsl子系统。这里需要提醒：<code>MySQL集群环境做了解即可，目前Docker已经无法正常使用，我也实在是没有找到MyCat的image</code></p>
<p>关于<code>wsl</code>如何使用，我不再赘述，建议安装后迁移到其他盘</p>
<p><code>基本的wsl安装</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026151947279.png" alt="image-20241026151947279"></p>
<pre><code class="shell">wsl --install
wsl --set-default-version 2
wsl --list --online
wsl --install -d 镜像名
wsl
#运行完以上命令，会进行第一次运行初始化，然后创建一个用户，填写用户名和密码，Linux系统密码不会显示，输入即可
#为root账户设置密码
sudo passwd root
#输入密码
su root
#输入密码，如果成功则会切换到root账户
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026151413848.png" alt="image-20241026151413848"></p>
<pre><code class="shell">#关闭wsl
wsl --shutdown
#导出Ubuntu镜像为E:\wsl\ubuntu\ubuntu.tar
wsl --export Ubuntu E:\wsl\ubuntu\ubuntu.tar
#注销原本的Ubuntu子系统
wsl --unregister Ubuntu
#导入Ubuntu到E盘该目录
wsl --import Ubuntu E:\wsl\ubuntu E:\wsl\ubuntu\ubuntu.tar
#恢复Ubuntu原有的账户
Ubuntu config --default-user xccit
#启动ubuntu
wsl
</code></pre>
<p>完成之后清理C盘冗余的垃圾文件即可。</p>
<blockquote>
<ul>
<li><code>redis</code>配置：</li>
</ul>
<pre><code class="shell">apt install redis-server
systemctl start redis-server
systemctl enable redis-server
vim /etc/redis/redis.conf
</code></pre>
<p>添加<code>requirepass 密码</code>，如果<code>protected mode yes</code>被注释或者值为no，则改为yes并取消注释即可</p>
<pre><code class="shell">systemctl restart redis-server
</code></pre>
<ul>
<li><code>rabbitmq</code>配置：</li>
</ul>
<pre><code class="shell">sudo apt install rabbitmq-server
sudo systemctl start rabbitmq-server
sudo systemctl enable rabbitmq-server
#(可选）启用RabbitMQ管理插件来获取一个基于Web的UI
#（可选）创建用户和设置权限（替换xccit和1209为你想设置的用户名和密码）
sudo rabbitmqctl add_user xccit 1209
sudo rabbitmqctl set_user_tags xccit administrator
sudo rabbitmqctl set_permissions -p / xccit &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026161231044.png" alt="image-20241026161231044"></p>
<p>访问：<code>localhost:15672</code></p>
<p>使用<code>xccit 1209</code>登录</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026161314375.png" alt="image-20241026161314375"></p>
<p><code>完成</code></p>
<ul>
<li><p><code>minio</code>配置：</p>
<p>假设我的minio文件夹布局为：</p>
<pre><code class="txt">D:\minio
└─data
|--bin
    |--minio.exe
|--logs
</code></pre>
<p>启动命令为（进入bin目录）:</p>
<pre><code class="shell">minio server D:\minio\data
</code></pre>
<p>然后浏览器输入:<code>localhost:9000</code>,使用默认的<code>minioadmin minioadmin</code>登录</p>
<p>创建存储桶，名称为<code>his</code>,接下来需要为存储桶设置权限：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026165259458.png" alt="image-20241026165259458" style="zoom:50%;" />

<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241026165459494.png" alt="image-20241026165459494"></p>
</li>
</ul>
</blockquote>
<p>关于MySQL、MongoDB、MinIO，下载对应的Windows安装包或者可执行文件，自行启动并测试即可</p>
<h3 id="3-11前端开发环境"><a href="#3-11前端开发环境" class="headerlink" title="3.11前端开发环境"></a>3.11前端开发环境</h3><ul>
<li>Vscode&#x2F;HBuilder</li>
<li>Node.js LTS版本,不宜过高</li>
<li>Chrome&#x2F;Edge</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/docker/" style="color: #ff7d73">docker</a>
        </span>
        
    </div>
    <a href="/2024/10/27/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/10/07/JDBC%E6%B5%85%E6%9E%90/">
        <h2 class="post-title">JDBC浅析</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/7
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="浅析JDBC"><a href="#浅析JDBC" class="headerlink" title="浅析JDBC"></a>浅析JDBC</h1><blockquote>
<p>基于MySQL8.0,聊一聊JDBC技术</p>
</blockquote>
<h2 id="JDBC定义"><a href="#JDBC定义" class="headerlink" title="JDBC定义"></a>JDBC定义</h2><blockquote>
<p>JDBC（Java Database Connectivity，Java数据库连接）是Java语言中用于规范客户端程序如何访问数据库的应用程序接口。它提供了一套完整的机制，允许Java程序与各种关系型数据库进行交互。以下是关于JDBC的详细讨论：</p>
</blockquote>
<h3 id="1-JDBC的定义和作用"><a href="#1-JDBC的定义和作用" class="headerlink" title="1. JDBC的定义和作用"></a>1. JDBC的定义和作用</h3><ul>
<li>JDBC是Sun Microsystems（现已被Oracle收购）制定的一个API规范，它定义了一组Java类和方法，用于执行SQL语句、处理查询结果以及管理数据库连接。</li>
<li>JDBC的主要作用是提供一个通用的访问关系型数据库的接口，使得Java程序能够连接并操作各种不同的数据库，如MySQL、Oracle、SQL Server等。</li>
</ul>
<h3 id="2-JDBC的组成部分"><a href="#2-JDBC的组成部分" class="headerlink" title="2. JDBC的组成部分"></a>2. JDBC的组成部分</h3><ul>
<li>JDBC API主要位于Java的<code>java.sql</code>包中，包含诸如<code>DriverManager</code>、<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code>等核心类和接口。</li>
<li><code>DriverManager</code>负责管理数据库驱动程序，<code>Connection</code>代表与数据库的连接，<code>Statement</code>用于执行SQL语句，而<code>ResultSet</code>则用于存储和处理查询结果。</li>
</ul>
<h3 id="3-JDBC的工作原理"><a href="#3-JDBC的工作原理" class="headerlink" title="3. JDBC的工作原理"></a>3. JDBC的工作原理</h3><ul>
<li>JDBC通过驱动程序与数据库进行交互。驱动程序是一个实现了JDBC API规定的接口的Java类库，它负责将Java方法调用转换为对应的数据库操作。</li>
<li>当Java程序需要与数据库通信时，它首先通过<code>DriverManager</code>获取一个<code>Connection</code>对象，然后使用这个对象创建一个或多个<code>Statement</code>对象来执行SQL语句。查询结果通过<code>ResultSet</code>对象返回给Java程序。</li>
</ul>
<h3 id="4-JDBC的应用场景"><a href="#4-JDBC的应用场景" class="headerlink" title="4. JDBC的应用场景"></a>4. JDBC的应用场景</h3><ul>
<li>JDBC在Java Web开发中被广泛应用，用于实现数据库连接、数据查询、数据更新以及事务管理等功能。</li>
<li>它允许开发人员通过编写Java代码来直接操作数据库，从而提高了应用程序的性能和可靠性。</li>
</ul>
<h3 id="5-JDBC的优势和局限性"><a href="#5-JDBC的优势和局限性" class="headerlink" title="5. JDBC的优势和局限性"></a>5. JDBC的优势和局限性</h3><ul>
<li>优势：JDBC提供了一个统一的接口来访问多种关系型数据库，具有跨平台性和可移植性。此外，它还支持事务处理和连接池等高级功能。</li>
<li>局限性：虽然JDBC提供了强大的功能，但在某些情况下，它可能不是最优的解决方案。例如，对于复杂的数据持久化需求，可能需要使用更高级的框架如Hibernate或MyBatis。</li>
</ul>
<h3 id="6-JDBC的常见错误及解决方案"><a href="#6-JDBC的常见错误及解决方案" class="headerlink" title="6. JDBC的常见错误及解决方案"></a>6. JDBC的常见错误及解决方案</h3><ul>
<li>在使用JDBC时，可能会遇到诸如<code>ClassNotFoundException</code>、<code>SQLException</code>等异常。这些异常通常是由于驱动程序未正确加载、数据库连接信息错误或SQL语句语法错误等原因引起的。</li>
<li>解决这些问题的方法包括确保驱动程序已正确添加到项目依赖中、检查数据库连接字符串和凭证是否有效以及验证SQL语句的语法等。</li>
</ul>
<p>总的来说，JDBC是Java程序与关系型数据库进行交互的重要桥梁，它提供了灵活且强大的功能来满足各种数据库操作需求。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><code>SQL</code></p>
<pre><code class="sql">/*
 Navicat Premium Dump SQL

 Source Server         : localhost_mysql
 Source Server Type    : MySQL
 Source Server Version : 80027 (8.0.27)
 Source Host           : localhost:3306
 Source Schema         : jdbc-demo

 Target Server Type    : MySQL
 Target Server Version : 80027 (8.0.27)
 File Encoding         : 65001

 Date: 08/10/2024 00:31:48
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_department
-- ----------------------------
DROP TABLE IF EXISTS `t_department`;
CREATE TABLE `t_department`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `dept_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;部门名称&#39;,
  `dept_code` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;部门编码&#39;,
  `dept_base_salary` decimal(10, 2) NOT NULL COMMENT &#39;部门基础工资&#39;,
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#39;部门简介&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_department
-- ----------------------------
INSERT INTO `t_department` VALUES (1, &#39;法务部&#39;, &#39;FWB&#39;, 5000.00, &#39;法务部&#39;);
INSERT INTO `t_department` VALUES (2, &#39;运营部&#39;, &#39;YYB&#39;, 5000.00, &#39;运营部&#39;);
INSERT INTO `t_department` VALUES (3, &#39;开发部&#39;, &#39;KFB&#39;, 7000.00, &#39;开发部&#39;);
INSERT INTO `t_department` VALUES (4, &#39;宣传部&#39;, &#39;XCB&#39;, 4500.00, &#39;宣传部&#39;);
INSERT INTO `t_department` VALUES (5, &#39;销售部&#39;, &#39;XSB&#39;, 3900.00, &#39;销售部&#39;);

-- ----------------------------
-- Table structure for t_employee
-- ----------------------------
DROP TABLE IF EXISTS `t_employee`;
CREATE TABLE `t_employee`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;姓名&#39;,
  `username` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;用户名&#39;,
  `password` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;密码&#39;,
  `nickname` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;昵称&#39;,
  `emp_id` int NOT NULL COMMENT &#39;部门主键&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_employee
-- ----------------------------
INSERT INTO `t_employee` VALUES (1, &#39;江杰宏&#39;, &#39;Don Ross&#39;, &#39;J9ep8yW38S&#39;, &#39;Miss.&#39;, 4);
INSERT INTO `t_employee` VALUES (2, &#39;袁云熙&#39;, &#39;Patrick Diaz&#39;, &#39;fht7Lu3AqX&#39;, &#39;Ms.&#39;, 1);
INSERT INTO `t_employee` VALUES (3, &#39;邱致远&#39;, &#39;Stanley Graham&#39;, &#39;cRQ1X2xSai&#39;, &#39;Mrs.&#39;, 2);
INSERT INTO `t_employee` VALUES (4, &#39;程安琪&#39;, &#39;Gary Tucker&#39;, &#39;tbRWPXTUg2&#39;, &#39;Miss.&#39;, 2);
INSERT INTO `t_employee` VALUES (5, &#39;龙安琪&#39;, &#39;Donna Miller&#39;, &#39;TTZxZnxLhk&#39;, &#39;Prof.&#39;, 5);
INSERT INTO `t_employee` VALUES (6, &#39;黄云熙&#39;, &#39;April Henderson&#39;, &#39;vEo0CYdokK&#39;, &#39;Miss.&#39;, 3);
INSERT INTO `t_employee` VALUES (7, &#39;崔睿&#39;, &#39;Louise Sanchez&#39;, &#39;eRBKITreqy&#39;, &#39;Ms.&#39;, 2);
INSERT INTO `t_employee` VALUES (8, &#39;卢杰宏&#39;, &#39;Lois Stephens&#39;, &#39;t9oRmXKPBb&#39;, &#39;Mr.&#39;, 2);
INSERT INTO `t_employee` VALUES (9, &#39;董宇宁&#39;, &#39;Henry Ferguson&#39;, &#39;gQ9cc4BTvO&#39;, &#39;Mrs.&#39;, 4);
INSERT INTO `t_employee` VALUES (10, &#39;阎宇宁&#39;, &#39;Jane Myers&#39;, &#39;HcbKG8mdpn&#39;, &#39;Prof.&#39;, 1);

SET FOREIGN_KEY_CHECKS = 1;

</code></pre>
<p><code>驱动版本</code></p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.33&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="JDBC入门代码"><a href="#JDBC入门代码" class="headerlink" title="JDBC入门代码"></a>JDBC入门代码</h2><pre><code class="java">public class JDBCDemo &#123;
    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;
        // 加载驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        // 连接数据库的参数
        String jdbcUrl = &quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;;
        String jdbcUser = &quot;root&quot;;
        String jdbcPass = &quot;1234546&quot;;
        // 获取连接对象
        Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPass);
        // 获取执行sql语句的处理对象
        Statement statement = connection.createStatement();
        // 执行sql语句
        String sql = &quot;select * from t_employee&quot;;
        ResultSet resultSet = statement.executeQuery(sql);
        while (resultSet.next()) &#123;
            int id = resultSet.getInt(&quot;id&quot;);
            String name = resultSet.getString(&quot;name&quot;);
            String username = resultSet.getString(&quot;username&quot;);
            String password = resultSet.getString(&quot;password&quot;);
            String nickname = resultSet.getString(&quot;nickname&quot;);
            int empId = resultSet.getInt(&quot;emp_id&quot;);
            System.out.println(id+&quot; &quot;+name+&quot; &quot;+username+&quot; &quot;+password+&quot; &quot;+nickname+&quot; &quot;+empId);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241008003315427.png" alt="image-20241008003315427"></p>
<h2 id="JDBC如何实现CRUD"><a href="#JDBC如何实现CRUD" class="headerlink" title="JDBC如何实现CRUD"></a>JDBC如何实现CRUD</h2><h3 id="导入Junit单元测试"><a href="#导入Junit单元测试" class="headerlink" title="导入Junit单元测试"></a>导入Junit单元测试</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.13.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>在JDK1.6之后,JDBC中不用再写加载驱动这一步骤,直接获取连接即可</code></p>
<pre><code class="java">@Test
public void testInsert() &#123;
    // 1.加载驱动(省略)
    try &#123;
        //2.获取连接
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;123456&quot;);
        //3.获取执行sql的对象
        Statement statement = connection.createStatement();
        // 3.执行sql
        int i = statement.executeUpdate(&quot;insert into t_employee(name,username,password,nickname,emp_id) values(&#39;张三&#39;,&#39;zhangsan&#39;,&#39;zhangsan123&#39;,&#39;张三&#39;,&#39;1&#39;)&quot;);
        if (i &gt; 0) &#123;
            System.out.println(&quot;插入成功&quot;);
        &#125; else &#123;
            System.out.println(&quot;插入失败&quot;);
        &#125;
    &#125; catch (SQLException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><pre><code class="java">@Test
public void testDelete() &#123;
    // 1.加载驱动(省略)
    try &#123;
        //2.获取连接
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;123456&quot;);
        //3.获取执行sql的对象
        Statement statement = connection.createStatement();
        // 3.执行sql
        int i = statement.executeUpdate(&quot;delete from t_employee where id=&#39;11&#39;&quot;);
        if (i &gt; 0) &#123;
            System.out.println(&quot;删除成功&quot;);
        &#125; else &#123;
            System.out.println(&quot;删除失败&quot;);
        &#125;
    &#125; catch (SQLException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code class="java">@Test
public void testUpdate() &#123;
    // 1.加载驱动(省略)
    try &#123;
        //2.获取连接
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;123456&quot;);
        //3.获取执行sql的对象
        Statement statement = connection.createStatement();
        // 3.执行sql
        int i = statement.executeUpdate(&quot;update t_employee set name=&#39;李四&#39;, username=&#39;lisi&#39;, password=&#39;lisi123&#39;, nickname=&#39;李四&#39;, emp_id=&#39;2&#39; where id=&#39;10&#39;&quot;);
        if (i &gt; 0) &#123;
            System.out.println(&quot;修改成功&quot;);
        &#125; else &#123;
            System.out.println(&quot;修改失败&quot;);
        &#125;
    &#125; catch (SQLException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>多行多列</code></p>
<pre><code class="java">@Test
public void testSelect1() &#123;
    // 1.加载驱动(省略)
    try &#123;
        //2.获取连接
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;123456&quot;);
        //3.获取执行sql的对象
        Statement statement = connection.createStatement();
        // 3.执行sql,获取结果集
        ResultSet resultSet = statement.executeQuery(&quot;SELECT * FROM t_employee&quot;);
        //4.处理结果集
        while (resultSet.next()) &#123;
            String name = resultSet.getString(&quot;name&quot;);
            String username = resultSet.getString(&quot;username&quot;);
            String password = resultSet.getString(&quot;password&quot;);
            String nickname = resultSet.getString(&quot;nickname&quot;);
            String empId = resultSet.getString(&quot;emp_id&quot;);
            System.out.println(name + &quot;\t&quot; + username + &quot;\t&quot; + password + &quot;\t&quot; + nickname + &quot;\t&quot; + empId);
        &#125;
    &#125; catch (SQLException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<p><code>单行多列</code></p>
<pre><code class="java">@Test
public void testSelect2() &#123;
    // 1.加载驱动(省略)
    try &#123;
        //2.获取连接
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;123456&quot;);
        //3.获取执行sql的对象
        Statement statement = connection.createStatement();
        // 3.执行sql,获取结果集
        int id = 1; // 假设用户输入的id为1
        ResultSet resultSet = statement.executeQuery(&quot;SELECT * FROM t_employee WHERE id = &quot; + id);
        //4.处理结果集
        while (resultSet.next()) &#123;
            int userId = resultSet.getInt(&quot;id&quot;);
            String name = resultSet.getString(&quot;name&quot;);
            String username = resultSet.getString(&quot;username&quot;);
            String password = resultSet.getString(&quot;password&quot;);
            String nickname = resultSet.getString(&quot;nickname&quot;);
            String empId = resultSet.getString(&quot;emp_id&quot;);
            System.out.println(userId + &quot;\t&quot; +name + &quot;\t&quot; + username + &quot;\t&quot; + password + &quot;\t&quot; + nickname + &quot;\t&quot; + empId);
        &#125;
    &#125; catch (SQLException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<h2 id="Statement对象的缺点及解决办法"><a href="#Statement对象的缺点及解决办法" class="headerlink" title="Statement对象的缺点及解决办法"></a>Statement对象的缺点及解决办法</h2><p>Statement对象的缺点主要包括<code>SQL拼接问题</code>和<code>SQL注入风险</code>。以下是详细的解释及解决办法：</p>
<h3 id="1-SQL拼接问题"><a href="#1-SQL拼接问题" class="headerlink" title="1.SQL拼接问题"></a>1.SQL拼接问题</h3><ul>
<li><p>问题描述：Statement对象在执行SQL语句时，需要通过字符串拼接的方式将变量值嵌入到SQL语句中。这种方式不仅繁琐，而且容易出错，特别是在处理复杂SQL语句或多个变量时。</p>
</li>
<li><p>解决办法：使用<code>PreparedStatement</code>对象替代Statement对象。PreparedStatement允许开发者通过占位符（?）来预编译SQL语句，并在执行前设置占位符的值。这种方式避免了繁琐的字符串拼接，提高了代码的可读性和可维护性。</p>
</li>
</ul>
<h3 id="2-SQL注入风险"><a href="#2-SQL注入风险" class="headerlink" title="2.SQL注入风险"></a>2.<code>SQL注入风险</code></h3><ul>
<li><p>问题描述：由于Statement对象通过字符串拼接的方式执行SQL语句，恶意用户可以利用这一点，通过输入特定的字符串来修改SQL语句的结构，从而执行非预期的数据库操作，这就是所谓的SQL注入攻击。SQL注入攻击可能导致数据泄露、数据篡改或数据库被非法控制等严重后果。</p>
</li>
<li><p>解决办法：同样，使用<code>PreparedStatement</code>对象可以有效防止SQL注入攻击。因为PreparedStatement对象在执行SQL语句前会对语句进行预编译，并将变量值与SQL语句分开处理。即使恶意用户输入了包含SQL关键词的字符串，这些字符串也只会被当作普通的变量值来处理，而无法改变SQL语句的结构。此外，数据库连接池等安全措施也可以进一步增强系统的安全性。</p>
</li>
</ul>
<p>综上所述，为了解决Statement对象的缺点，推荐使用PreparedStatement对象来执行SQL语句。PreparedStatement对象不仅提高了代码的可读性和可维护性，还能有效防止SQL注入攻击，保障数据库的安全性。</p>
<h3 id="SQL注入演示"><a href="#SQL注入演示" class="headerlink" title="SQL注入演示"></a>SQL注入演示</h3><pre><code class="java">public class SQLInjection &#123;
    public static void main(String[] args) throws Exception &#123;
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;1209&quot;);
        Statement statement = connection.createStatement();
        System.out.print(&quot;请输入用户名：&quot;);
        String input = new Scanner(System.in).nextLine();
        ResultSet resultSet = statement.executeQuery(&quot;SELECT * FROM t_employee WHERE username=&#39;&quot; + input + &quot;&#39;&quot;);
        while (resultSet.next()) &#123;
            System.out.println(resultSet.getString(&quot;username&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;password&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;name&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;nickname&quot;));
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241008090941689.png" alt="image-20241008090941689"></p>
<blockquote>
<p>只是拼接了一个 ‘or 1&#x3D;1’这个条件,全表的数据一次性都查了出来</p>
</blockquote>
<h3 id="SQL注入解决方案"><a href="#SQL注入解决方案" class="headerlink" title="SQL注入解决方案"></a>SQL注入解决方案</h3><pre><code class="java">public class SQLInjection &#123;
    public static void main(String[] args) throws Exception &#123;
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;1209&quot;);
        //使用PreparedStatement防止SQL注入
        PreparedStatement preparedStatement = connection.prepareStatement(&quot;SELECT * FROM t_employee WHERE username=?&quot;);
        System.out.print(&quot;请输入用户名：&quot;);
        String input = new Scanner(System.in).nextLine();
        //给占位符赋值
        preparedStatement.setString(1, input);
        ResultSet resultSet = preparedStatement.executeQuery();
        while (resultSet.next()) &#123;
            System.out.println(resultSet.getString(&quot;username&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;password&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;name&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;nickname&quot;));
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20241008091445507.png" alt="image-20241008091445507"></p>
<blockquote>
<p>成功解决</p>
</blockquote>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><blockquote>
<p>上述所有测试案例,代码都可以优化,并且没有进行<code>资源释放</code>这一操作</p>
</blockquote>
<p><code>优化后:</code></p>
<pre><code class="java">public class SQLInjection &#123;
    public static void main(String[] args) &#123;
        /*Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;1209&quot;);
        Statement statement = connection.createStatement();
        System.out.print(&quot;请输入用户名：&quot;);
        String input = new Scanner(System.in).nextLine();
        ResultSet resultSet = statement.executeQuery(&quot;SELECT * FROM t_employee WHERE username=&#39;&quot; + input + &quot;&#39;&quot;);
        while (resultSet.next()) &#123;
            System.out.println(resultSet.getString(&quot;username&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;password&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;name&quot;)+&quot; &quot;
                    +resultSet.getString(&quot;nickname&quot;));
        &#125;*/
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try &#123;
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbc-demo&quot;, &quot;root&quot;, &quot;1209&quot;);
            //使用PreparedStatement防止SQL注入
            preparedStatement = connection.prepareStatement(&quot;SELECT * FROM t_employee WHERE username=?&quot;);
            System.out.print(&quot;请输入用户名：&quot;);
            String input = new Scanner(System.in).nextLine();
            //给占位符赋值
            preparedStatement.setString(1, input);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) &#123;
                System.out.println(resultSet.getString(&quot;username&quot;)+&quot; &quot;
                        +resultSet.getString(&quot;password&quot;)+&quot; &quot;
                        +resultSet.getString(&quot;name&quot;)+&quot; &quot;
                        +resultSet.getString(&quot;nickname&quot;));
            &#125;
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            //关闭资源
            try &#123;
                if (resultSet != null) resultSet.close();
                if (preparedStatement != null) preparedStatement.close();
                if (connection != null) connection.close();
            &#125; catch (SQLException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>资源释放牢记<code>先开后关</code>的原则,案例中先开的Connection,最后开的是ResultSet,关闭时优先关闭ResultSet,然后PreparedStatement,最后Connection</p>
</blockquote>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/JavaWeb/" style="color: #ff7d73">JavaWeb</a>
        </span>
        
    </div>
    <a href="/2024/10/07/JDBC%E6%B5%85%E6%9E%90/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/29/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/">
        <h2 class="post-title">浅析数据脱敏</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="浅析数据脱敏"><a href="#浅析数据脱敏" class="headerlink" title="浅析数据脱敏"></a>浅析数据脱敏</h1><h2 id="数据脱敏的概念"><a href="#数据脱敏的概念" class="headerlink" title="数据脱敏的概念"></a>数据脱敏的概念</h2><p><strong>数据脱敏是一种保护敏感信息的技术，通过对原始数据进行变换或修改来隐藏敏感信息，从而在非生产环境中安全使用脱敏后的数据</strong>。以下是对数据脱敏概念的具体介绍：</p>
<ol>
<li><strong>基本概念</strong>：数据脱敏，也称为数据去隐私化或数据变形，是对敏感数据进行有策略的修改或替换的过程，旨在防止未经授权的访问或泄露。这种技术通过特定的规则和策略，将敏感信息转换为看似相似但不含真正敏感细节的数据副本，以供开发、测试、分析或培训等非生产环境使用。</li>
<li><strong>主要类型</strong>：静态数据脱敏通常在数据被提取并复制到非生产环境之前完成一次性脱敏处理，适用于数据外发场景，如提供给第三方或用于测试数据库。动态数据脱敏在数据查询过程中实时进行，当用户访问敏感数据时，系统自动对其进行脱敏处理，适用于直接连接生产数据库的场景。</li>
<li><strong>实现方式</strong>：包括使用脚本手动编写代码进行脱敏，以及利用专业的数据脱敏产品进行自动化脱敏，后者能够提高脱敏效率并节省操作时间。</li>
<li><strong>技术手段</strong>：常见的脱敏技术包括数据替换、屏蔽、加密、混淆和伪装等，这些方法可以根据实际业务场景选择，以满足数据一致性和可用性的需求。</li>
<li><strong>应用场景</strong>：数据脱敏广泛应用于金融、医疗、政府等领域，特别是在涉及个人身份信息、联系方式、银行卡信息等敏感数据的处理中。</li>
<li><strong>重要性</strong>：数据脱敏技术的重要性在于它能够在不降低数据价值的前提下，有效保护个人隐私和商业机密不被泄露。随着大数据和云计算的发展，数据脱敏成为了确保数据安全合规的关键措施之一。</li>
</ol>
<p>总的来说，数据脱敏是一种关键的信息安全技术，它通过多种手段和方法，有效地保护了敏感数据的安全，同时也支持了数据的有效利用。在实施数据脱敏时，需要综合考虑数据一致性、可用性和安全性的要求，选择合适的技术和方法来实现最佳的数据保护效果。</p>
<h2 id="数据脱敏的实现方式"><a href="#数据脱敏的实现方式" class="headerlink" title="数据脱敏的实现方式"></a>数据脱敏的实现方式</h2><h3 id="1-前端脱敏"><a href="#1-前端脱敏" class="headerlink" title="1.前端脱敏"></a>1.前端脱敏</h3><ul>
<li>后端返回的数据已经进行了脱敏处理</li>
<li>后端返回的数据没有脱敏处理,前端使用JavaScript等脚本进行脱敏</li>
</ul>
<h3 id="2-后端脱敏"><a href="#2-后端脱敏" class="headerlink" title="2.后端脱敏"></a>2.后端脱敏</h3><ul>
<li>数据存储时直接进行加密处理,例如AES、RSA等对称&#x2F;非对称加密方式</li>
<li>数据返回给前端时使用混淆&#x2F;替换</li>
</ul>
<h2 id="前后端脱敏各自的弊端"><a href="#前后端脱敏各自的弊端" class="headerlink" title="前后端脱敏各自的弊端"></a>前后端脱敏各自的弊端</h2><h3 id="1-前端脱敏的弊端"><a href="#1-前端脱敏的弊端" class="headerlink" title="1.前端脱敏的弊端"></a>1.前端脱敏的弊端</h3><h4 id="1-1-安全性不够"><a href="#1-1-安全性不够" class="headerlink" title="1.1 安全性不够"></a>1.1 安全性不够</h4><p>总的来说,数据脱敏就是对一些敏感数据进行保护,不想被用户看到,但是前端接收到的数据为原文的话,即使JS等脚本进行处理,原来的响应结果也不会变,只是页面显示的东西变了而已,没有实际意义。</p>
<h3 id="2-后端脱敏的弊端"><a href="#2-后端脱敏的弊端" class="headerlink" title="2.后端脱敏的弊端"></a>2.后端脱敏的弊端</h3><h4 id="2-1无法模糊检索"><a href="#2-1无法模糊检索" class="headerlink" title="2.1无法模糊检索"></a>2.1无法模糊检索</h4><p>如何理解检索呢?以查询用户信息为例,假如代入一个条件:<code>匹配手机号前三位为177,后四位为0000</code>的用户,假如是精确匹配,比如我就要<code>手机号为17799890000</code>这个用户的信息,那SQL可以是这样的:</p>
<p>假设自定义一个解密函数为<code>deenc(phone varchar(11))</code>,那么SQL为:</p>
<pre><code class="sql">SELECT username,nick_name,birthday,deenc(phone) as phone FROM t_user WHERE phone = &#39;edcXdejhopacahah89avavsaib&#39;;
</code></pre>
<p>其中,<code>edcXdejhopacahah89avavsaib</code>为前端传入的<code>17799890000</code>这条数据在后端被加密算法加密之后的数据,那么精确匹配的话,可以很快查询到这条数据,流程图可以是这样的:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240928235655491.png" alt="image-20240928235655491"></p>
<p>但是,精确匹配只需要后端的业务层对前端传过来的数据进行加密,交给dao去数据库精确匹配即可,只需要查询这一条数据,并且将手机号解密后返回给前端,如果是模糊查询呢?比如<code>匹配手机号前三位为177,后四位为0000</code>的用户,那么正常的SQL应该是:</p>
<pre><code class="sql">SELECT username,nick_name,birthday,deenc(phone) as phone FROM t_user WHERE deenc(phone) like &#39;177%0000&#39;;
</code></pre>
<p>首先,需要将所有数据进行解密之后再匹配<code>177%0000</code>,假设数据库中有10000w条数据,那么我们会解密到什么时候呢?这是一道送命题。我们必须在<code>数据安全</code>与<code>用户体验</code>中做出选择。所以在数据脱敏这个问题上,基本上不会有公司做得很好,经过撞库等操作用户敏感信息被泄漏的事情并不少,这里就不点名了,<code>d(懂)d(的)d(都)d(懂)</code></p>
<h2 id="优雅实现数据脱敏"><a href="#优雅实现数据脱敏" class="headerlink" title="优雅实现数据脱敏"></a>优雅实现数据脱敏</h2><blockquote>
<p>我们以SpringBoot为例,自行封装工具类,使用策略设计模式来写一个高拓展性的数据脱敏工具</p>
</blockquote>
<h3 id="1-搭建SpringBoot工程"><a href="#1-搭建SpringBoot工程" class="headerlink" title="1.搭建SpringBoot工程"></a>1.搭建SpringBoot工程</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.1&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.xccit&lt;/groupId&gt;
    &lt;artifactId&gt;data-sensitiation&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;description&gt;
        Java数据脱敏
    &lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--knife4j 文档增强--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;4.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">spring:
  application:
    name: data-desensitization
    version: 1.0.0
    description: 数据脱敏
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/data-sensitization?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
#mybatis配置
mybatis:
  type-aliases-package: io.xccit.domain
  mapper-locations: classpath:mapper/**/*.xml
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# springdoc-openapi项目配置
springdoc:
  swagger-ui:
    path: /swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha
  api-docs:
    path: /v3/api-docs
  group-configs:
    - group: &#39;default&#39;
      paths-to-match: &#39;/**&#39;
      packages-to-scan: io.xccit.controller
# knife4j的增强配置，不需要增强可以不配
knife4j:
  enable: true
  setting:
    language: zh_cn
    footer-custom-content: Apache License 2.0 | Copyright  2024-[xccit](https://xccit.github.io)
    swagger-model-name:
</code></pre>
<h3 id="2-准备数据模型"><a href="#2-准备数据模型" class="headerlink" title="2.准备数据模型"></a>2.准备数据模型</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240929112339500.png" alt="image-20240929112339500"></p>
<h3 id="3-封装统一返回结果"><a href="#3-封装统一返回结果" class="headerlink" title="3.封装统一返回结果"></a>3.封装统一返回结果</h3><pre><code class="java">package io.xccit.r;

import lombok.Builder;
import lombok.Data;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;全局返回对象&lt;/p&gt;
 */
@Data
@Builder
public class AjaxResult&lt;T&gt; &#123;
    private Integer code;
    private String message;
    private T data;

    public AjaxResult() &#123;&#125;
    public AjaxResult(ResultEnum resultEnum, T data)&#123;
        this.code = resultEnum.getCode();
        this.message = resultEnum.getMessage();
        this.data = data;
    &#125;
    public AjaxResult(Integer code, String message,T data) &#123;
        this.code = code;
        this.message = message;
        this.data = data;
    &#125;

    /**
     * 请求成功
     * @param data 数据
     * @return AjaxResult
     * @param &lt;T&gt; 参数类型
     */
    public static &lt;T&gt; AjaxResult success(T data)&#123;
        if (data != null)&#123;
            return AjaxResult.builder().code(200).message(&quot;SUCCESS&quot;).data(data).build();
        &#125;
        return AjaxResult.builder().code(200).message(&quot;SUCCESS&quot;).build();
    &#125;

    /**
     * 请求成功
     * @param resultEnum 返回类型枚举
     * @param data 数据
     * @return AjaxResult
     * @param &lt;T&gt; 参数类型
     */
    public static &lt;T&gt; AjaxResult success(ResultEnum resultEnum,T data)&#123;
        if (data != null)&#123;
            return AjaxResult.builder().code(resultEnum.getCode()).message(resultEnum.getMessage()).data(data).build();
        &#125;
        return AjaxResult.builder().code(resultEnum.getCode()).message(resultEnum.getMessage()).build();
    &#125;

    /**
     * 请求失败
     * @return AjaxResult
     * @param &lt;T&gt; 参数类型
     */
    public static &lt;T&gt; AjaxResult fail()&#123;
        return new AjaxResult(ResultEnum.SERVER_ERROR,null);
    &#125;

    /**
     * 请求失败
     * @param resultEnum 返回类型枚举
     * @return AjaxResult
     * @param &lt;T&gt; 参数类型
     */
    public static &lt;T&gt; AjaxResult fail(ResultEnum resultEnum)&#123;
        return new AjaxResult(resultEnum,null);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package io.xccit.r;

import lombok.Getter;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;返回类型枚举&lt;/p&gt;
 */
@Getter
public enum ResultEnum &#123;
    SUCCESS(200,&quot;SUCCESS&quot;),
    SERVER_ERROR(500,&quot;SERVER ERROR&quot;),
    NOT_FOUND(404,&quot;NOT FOUND&quot;),
    BAD_REQUEST(400,&quot;BAD REQUEST&quot;),
    UNAUTHORIZED(401,&quot;UNAUTHORIZED&quot;),
    FORBIDDEN(403,&quot;FORBIDDEN&quot;),
    NOT_SUPPORT(405,&quot;NOT SUPPORT&quot;),
    NOT_ACCEPTABLE(406,&quot;NOT ACCEPTABLE&quot;),
    UNSUPPORTED_MEDIA_TYPE(415,&quot;UNSUPPORTED MEDIA TYPE&quot;);
    private final Integer code;
    private final String message;

    ResultEnum(Integer code, String message) &#123;
        this.code = code;
        this.message = message;
    &#125;
&#125;
</code></pre>
<h3 id="4-编写控制器-业务-数据访问"><a href="#4-编写控制器-业务-数据访问" class="headerlink" title="4.编写控制器,业务,数据访问"></a>4.编写控制器,业务,数据访问</h3><blockquote>
<p>完整代码访问github: <a target="_blank" rel="noopener" href="https://github.com/xccit/data-sensitiation">xccit&#x2F;data-sensitiation: 数据脱敏demo (github.com)</a></p>
</blockquote>
<h3 id="5-核心逻辑代码"><a href="#5-核心逻辑代码" class="headerlink" title="5.核心逻辑代码"></a>5.核心逻辑代码</h3><pre><code class="java">package io.xccit.desensitization;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;脱敏注解&lt;/p&gt;
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Desensitization &#123;

    SensitiveType type();
&#125;
</code></pre>
<pre><code class="java">package io.xccit.desensitization;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;脱敏类型&lt;/p&gt;
 */
public enum SensitiveType &#123;
    BANK_CARD,
    PHONE,
    ID_CARD;
&#125;
</code></pre>
<pre><code class="java">package io.xccit.desensitization.strategy;

import io.xccit.desensitization.SensitiveType;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;脱敏策略&lt;/p&gt;
 */
public interface IDesensitizationStrategy &#123;

    /**
     * 判断是否支持脱敏
     * @param type 待脱敏的类型
     * @return 是否支持
     */
    boolean support(SensitiveType type);

    /**
     * 脱敏
     * @param value 待脱敏的值
     * @return 脱敏后的值
     */
    String desensitize(String value);
&#125;
</code></pre>
<pre><code class="java">package io.xccit.desensitization.strategy.impl;

import io.xccit.desensitization.SensitiveType;
import io.xccit.desensitization.strategy.IDesensitizationStrategy;
import org.springframework.stereotype.Component;

/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/29
 * &lt;p&gt;银行卡脱敏&lt;/p&gt;
 */
@Component
public class BankCardDesensitization implements IDesensitizationStrategy &#123;
    /**
     * 判断是否支持脱敏
     *
     * @param type 待脱敏的类型
     * @return 是否支持
     */
    @Override
    public boolean support(SensitiveType type) &#123;
        return type.equals(SensitiveType.BANK_CARD);
    &#125;

    /**
     * 脱敏
     *
     * @param value 中国所有银行支持的银行卡号
     * @return 脱敏后的值
     */
    @Override
    public String desensitize(String value) &#123;
        if (value != null &amp;&amp; value.length() == 19)&#123;
            return &quot;**** **** **** &quot; + value.substring(12,19);
        &#125;
        return &quot;不支持的类型&quot;;
    &#125;
&#125;
</code></pre>
<p><code>......</code></p>
<blockquote>
<p>完整代码访问github即可</p>
</blockquote>
<h2 id="测试数据脱敏"><a href="#测试数据脱敏" class="headerlink" title="测试数据脱敏"></a>测试数据脱敏</h2><h3 id="1-脱敏前"><a href="#1-脱敏前" class="headerlink" title="1.脱敏前"></a>1.脱敏前</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240929113727280.png" alt="image-20240929113727280"></p>
<pre><code class="java">/**
     * 根据id查询用户,脱敏后返回
     *
     * @param id 用户id
     * @return 用户信息
     */
    @Override
    public UserVO getUser(Long id) &#123;
        User user = userMapper.getUser(id);
        UserVO vo = new UserVO();
        /*try &#123;
            return (UserVO) desensitizationUtil.desensitize(user, vo);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;*/
        BeanUtils.copyProperties(user, vo);
        return vo;
    &#125;
</code></pre>
<h3 id="2-脱敏后"><a href="#2-脱敏后" class="headerlink" title="2.脱敏后"></a>2.脱敏后</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240929113901034.png" alt="image-20240929113901034"></p>
<pre><code class="java">/**
     * 根据id查询用户,脱敏后返回
     *
     * @param id 用户id
     * @return 用户信息
     */
    @Override
    public UserVO getUser(Long id) &#123;
        User user = userMapper.getUser(id);
        UserVO vo = new UserVO();
        try &#123;
            return (UserVO) desensitizationUtil.desensitize(user, vo);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
/*        BeanUtils.copyProperties(user, vo);
        return vo;*/
    &#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之,代码有多种不同的设计方法来实现需求,并且需求永远是写不完的,总会有一个场景让你不得不改变部分需求。本案例的代码可以加入Spring Security进行权限校验,并且用户密码也没有写加密方法,可以自行实现一下,如需更多脱敏类型,只需在类型的<code>枚举</code>中加入类型字段,然后再编写实现类实现<code>IDesensitizationStrategy</code>接口,编写自己的业务逻辑即可,后续在<code>vo或do</code>中字段标注该注解即可。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" style="color: #03a9f4">Java开发技巧</a>
        </span>
        
    </div>
    <a href="/2024/09/29/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/19/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/">
        <h2 class="post-title">Spring快速入门2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Spring快速入门2"><a href="#Spring快速入门2" class="headerlink" title="Spring快速入门2"></a>Spring快速入门2</h1><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="构造方法赋值"><a href="#构造方法赋值" class="headerlink" title="构造方法赋值"></a>构造方法赋值</h3><h4 id="1-更改实体类"><a href="#1-更改实体类" class="headerlink" title="1.更改实体类"></a>1.更改实体类</h4><p><code>Person.java</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private Cat cat;
&#125;
</code></pre>
<h4 id="2-更改配置文件"><a href="#2-更改配置文件" class="headerlink" title="2.更改配置文件"></a>2.更改配置文件</h4><pre><code class="xml">    &lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
        &lt;constructor-arg name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Jackson&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;cat&quot; ref=&quot;cat&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
</code></pre>
<h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><pre><code class="java">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person)context.getBean(&quot;person2&quot;);
        System.out.println(person);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919132608571.png" alt="image-20240919132608571"></p>
<blockquote>
<p>Tips:配置文件中,使用构造方法赋值必须确保有该构造方法,如添加了带参构造,必须添加无参构造,不然会报错。另外<code>name</code>属性可以去掉,确保value或ref的顺序与构造方法参数的顺序一致,如顺序不一致,也会导致因类型转换问题报错,此时可以使用<code>index</code>属性解决,只需要在<code>constructor-arg</code>标签中添加<code>index</code>,属性,值为该参数所在的索引,例如(int id,String name),此时id的索引应该为0,name应该为1</p>
</blockquote>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="复杂类型注入"><a href="#复杂类型注入" class="headerlink" title="复杂类型注入"></a>复杂类型注入</h3><blockquote>
<p>使用<code>ref</code>可以给单个引用类型赋值,如果一个对象与另外一个对象是<code>一对多</code>的关系,需要使用到集合又该怎么赋值呢?</p>
</blockquote>
<h4 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h4><pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;母&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;lucky&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;公&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919133548992.png" alt="image-20240919133548992"></p>
<h4 id="2-Map"><a href="#2-Map" class="headerlink" title="2.Map"></a>2.Map</h4><pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope 作用域"></a>scope 作用域</h3><blockquote>
<p>Spring管理的bean的作用域需要使用scope属性来进行管理,分别有四个值:</p>
<ul>
<li>singleton:单例模式,通过ioc获取的bean唯一。(默认值)</li>
<li>prototype:多例模式，通过ioc获取的bean不唯一。</li>
<li>request:请求有效，在一次Http请求中有效。</li>
<li>session:会话有效，在一个用户会话内有效。</li>
</ul>
<p><code>request</code>和<code>session</code>仅适用于web项目,多数情况下使用<code>singleton</code>和<code>prototype</code></p>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>分别配置一个scope为<code>singleton</code>和<code>prototype</code>的bean</p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
Person person1 = (Person) context.getBean(&quot;person&quot;);
System.out.println(person == person1);

Person person2 = (Person) context.getBean(&quot;person2&quot;);
Person person3 = (Person) context.getBean(&quot;person2&quot;);
System.out.println(person2 == person3);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919135020404.png" alt="image-20240919135020404"></p>
<blockquote>
<p>测试可得:单例模式下,获取的bean唯一,而多例模式下,获取的bean确实不唯一。并且创建对象的方式也不同,singleton会在加载配置文件时创建bean,而prototype在获取bean时才会创建bean,之后每一次获取时都会创建一次,通过无参构造创建。</p>
</blockquote>
<h2 id="Spring继承机制"><a href="#Spring继承机制" class="headerlink" title="Spring继承机制"></a>Spring继承机制</h2><p>Spring的继承主要在对象层面,可以实现子对象对父对象的属性继承,不同于Java层面的是,Java是子类对父类结构的继承。</p>
<p><code>Java层面继承:</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919191459330.png" alt="image-20240919191459330"></p>
<p><code>Spring层面继承:</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919191909763.png" alt="image-20240919191909763"></p>
<h3 id="使用继承机制"><a href="#使用继承机制" class="headerlink" title="使用继承机制"></a>使用继承机制</h3><p><code>配置两个Person</code></p>
<pre><code class="xml">&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;Kitty&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cat&quot;&gt;
        &lt;list value-type=&quot;io.xccit.entity.Cat&quot;&gt;
            &lt;ref bean=&quot;cat&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;cat2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;others&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;address&quot; value=&quot;北京市&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;phone&quot; value=&quot;18099565699&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;email&quot; value=&quot;123456@qq.com&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person2&quot; class=&quot;io.xccit.entity.Person&quot; parent=&quot;person&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><code>测试代码</code></p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        Person person1 = (Person) context.getBean(&quot;person2&quot;);
        System.out.println(person);
        System.out.println(person1);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919194047771.png" alt="image-20240919194047771"></p>
<blockquote>
<p>使用<code>parent</code>属性可快速为bean指定父对象。</p>
<p>值得一提的是，在Spring中，即使该类没有继承自<code>parent</code>指定的对象对应的类,属性值依然可以继承。只要确保该类定义时,与<code>parent</code>指定的bean所对应的类属性结构一致,才可以继承,否则会报错。</p>
</blockquote>
<p><code>测试使用不同类型的bean继承该bean是否可以</code></p>
<p><code>User.java</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
&#125;
</code></pre>
<p><code>applicationContext.xml</code></p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot; parent=&quot;person2&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919195900842.png" alt="image-20240919195900842"></p>
<p><code>tips:</code>如果User定义的属性结构中,<code>不包含</code>Person的某个属性,则继承会<code>失败</code></p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919200052736.png" alt="image-20240919200052736"></p>
<pre><code class="java">9月 19, 2024 8:00:28 下午 org.springframework.context.support.AbstractApplicationContext refresh
警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;user&#39; defined in class path resource [applicationContext.xml]: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;user&#39; defined in class path resource [applicationContext.xml]: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1740)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1454)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:599)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)
    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:85)
    at io.xccit.App.main(App.java:38)
Caused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;cat&#39; of bean class [io.xccit.entity.User]: Bean property &#39;cat&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:209)
    at org.springframework.beans.AbstractNestablePropertyAccessor.processLocalProperty(AbstractNestablePropertyAccessor.java:430)
    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:278)
    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:269)
    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:104)
    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:79)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1737)
    ... 13 more
</code></pre>
<p>但是如果<code>User有自己的专属属性</code>,并且<code>还有Person的所有属性</code>,这是可以成功的</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    private String address;
&#125;
</code></pre>
<pre><code class="java">Person(id=1, name=Kitty, age=18, gender=女, cat=[Cat(id=1, name=mimi, age=3, gender=母, breed=英国短毛猫), Cat(id=2, name=lucky, age=3, gender=公, breed=英国短毛猫)], others=&#123;address=北京市, phone=18099565699, email=123456@qq.com&#125;)
User(id=1, name=Kitty, age=18, gender=女, cat=[Cat(id=1, name=mimi, age=3, gender=母, breed=英国短毛猫), Cat(id=2, name=lucky, age=3, gender=公, breed=英国短毛猫)], others=&#123;address=北京市, phone=18099565699, email=123456@qq.com&#125;, address=null)
</code></pre>
<blockquote>
<p>上面为输出结果,截图截不全,所以直接贴文字</p>
</blockquote>
<h2 id="Spring依赖机制"><a href="#Spring依赖机制" class="headerlink" title="Spring依赖机制"></a>Spring依赖机制</h2><blockquote>
<p>描述<code>对象(bean)</code>与<code>对象(bean)</code>之间的依赖关系,被依赖的bean先在ioc容器中创建,依赖其他bean的bean后创建</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">@Data
//@NoArgsConstructor
//@AllArgsConstructor
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    public Person()&#123;
        System.out.println(&quot;Person() invoked&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Data
//@NoArgsConstructor
//@AllArgsConstructor
public class User &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private List&lt;Cat&gt; cat;
    private Map&lt;String,Object&gt; others;
    private String address;
    public User()&#123;
        System.out.println(&quot;User() invoked)&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
User user = (User) context.getBean(&quot;user&quot;);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919205414582.png" alt="image-20240919205414582"></p>
<blockquote>
<p>无依赖关系时,按照xml中的配置自上而下依次创建</p>
</blockquote>
<h3 id="使用依赖机制"><a href="#使用依赖机制" class="headerlink" title="使用依赖机制"></a>使用依赖机制</h3><pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;io.xccit.entity.User&quot; depends-on=&quot;person&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>使用<code>depends-on</code>属性来指定该bean依赖于哪个bean,被依赖的bean会先创建</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240919210407806.png" alt="image-20240919210407806"></p>
<p>这次<code>person</code>的创建优先级高于<code>user</code></p>
<h2 id="Spring配置的命名空间"><a href="#Spring配置的命名空间" class="headerlink" title="Spring配置的命名空间"></a>Spring配置的命名空间</h2><blockquote>
<p>使用命名空间可以<code>简化配置文件</code>中bean与bean之间<code>关系的配置</code>以及<code>依赖注入</code></p>
</blockquote>
<h3 id="p名称空间"><a href="#p名称空间" class="headerlink" title="p名称空间"></a>p名称空间</h3><p>要使用p命名空间,首先xml的dtd中必须要有p命名空间的<code>schema</code></p>
<pre><code class="xml-dtd">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
</code></pre>
<p>完整的<code>xml-dtd</code>应该为:</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="使用p名称空间"><a href="#使用p名称空间" class="headerlink" title="使用p名称空间"></a>使用p名称空间</h3><pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot; p:id=&quot;1&quot; p:name=&quot;mimi&quot; p:age=&quot;3&quot; p:gender=&quot;母&quot; p:breed=&quot;英国短毛猫&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot; p:id=&quot;1&quot; p:name=&quot;张三&quot; p:cat-ref=&quot;cat&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;person1&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>上面的案例中,person对应的bean的属性值与person1一致,只不过<code>赋值方法</code>不同,一个使用了property,一个使用了p名称空间</p>
</blockquote>
<p><code>直接加载配置文件,不做其他操作:</code></p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240920151821582.png" alt="image-20240920151821582"></p>
<p><code>创建了两个Person对象</code></p>
<p>如需获取属性,直接获取该bean打印即可</p>
<pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = (Person) context.getBean(&quot;person&quot;);
Person person1 = (Person) context.getBean(&quot;person1&quot;);
System.out.println(person);
System.out.println(person1);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240920152018747.png" alt="image-20240920152018747"></p>
<p><code>完全一致</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #00bcd4">SSM</a>
        </span>
        
    </div>
    <a href="/2024/09/19/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/17/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">
        <h2 class="post-title">Spring快速入门</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/17
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h1><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring框架是一个开源的J2EE应用程序框架，由Rod Johnson发起，旨在解决开发者在J2EE开发中遇到的常见问题。它提供了一个轻量级的容器，通过<code>控制反转IoC</code>和<code>面向切面编程（AOP)</code>等核心机制，简化了企业级应用程序的开发。Spring框架不仅限于服务器端开发，而且由于其简单性、可测试性和松耦合性，可以应用于绝大部分Java应用中。</p>
<h2 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h2><p>Spring框架的主要特性包括：</p>
<ol>
<li>‌<strong>轻量级</strong>‌：Spring的核心jar包很小，对代码几乎无污染，提供了轻量级的解决方案。</li>
<li>‌<strong>面向接口编程</strong>‌：Spring底层设计遵循面向接口的开发规范，通过接口定义实现类的行为，提高了代码的灵活性和可扩展性。</li>
<li>‌<strong>AOP支持</strong>‌：Spring提供了强大的AOP支持，使得开发者可以方便地处理日志、事务、权限验证等公共功能。</li>
<li>‌<strong>整合其他框架</strong>‌：Spring可以单独使用，也可以与其他框架（如Struts、Hibernate等）无缝集成，降低了使用难度。</li>
<li>‌<strong>降低API使用难度</strong>‌：Spring对Java EE API进行了封装，使其更易于使用，同时也降低了开发难度。</li>
</ol>
<p>Spring框架的架构包括多个模块，如Core模块提供基本的IOC和AOP功能，Data模块提供持久化数据的访问框架，而Web模块则提供Web应用程序的基础功能和编程框架。Spring框架的工作流程涉及嵌入容器中运行，通过定义Bean和配置XML文件来实现应用程序的启动和Bean的管理。</p>
<p>总的来说，Spring框架通过其简洁的设计、强大的功能和灵活的扩展性，成为了Java企业级应用开发的首选框架之一‌。</p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><code>IOC</code>全称<code>Inverse Of Control</code>,中文翻译为<code>控制反转</code>,是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（<code>Dependency Injection</code>，依赖注入）来实现的。</p>
<h3 id="IoC初体验"><a href="#IoC初体验" class="headerlink" title="IoC初体验"></a>IoC初体验</h3><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><ul>
<li><p>创建Maven工程</p>
</li>
<li><p>引入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;6.1.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>创建实体类</p>
<pre><code class="java">@Data
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
&#125;
</code></pre>
</li>
<li><p>简化实体类操作</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;version&gt;1.18.34&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>Spring配置文件</p>
<p><code>applicationContext.xml</code></p>
<p>命名并不是统一的,有些开发会习惯性的命名为<code>spring.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;lucy&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
        &lt;property name=&quot;gender&quot; value=&quot;女&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">public class App &#123;
    public static void main( String[] args ) &#123;
/*        Person person = new Person();
        person.setId(1);
        person.setName(&quot;张三&quot;);
        person.setAge(20);
        person.setGender(&quot;男&quot;);
        System.out.println(person);*/
        //ioc
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>使用<code>ApplicationContext</code>来new实现类<code>ClassPathXmlApplicationContext</code>来加载配置文件,还有<code>FileSystemXmlApplicationContext</code>可加载非本项目的配置文件,只需全路径即可。获取Bean的方式也并不是只有使用配置文件的<code>id属性值</code>一种,还可以直接用<code>Xxx.class</code></p>
</blockquote>
</li>
</ul>
<p>输出结果:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240917224205210.png" alt="image-20240917224205210"></p>
<h4 id="2-配置文件详解"><a href="#2-配置文件详解" class="headerlink" title="2.配置文件详解"></a>2.配置文件详解</h4><ul>
<li><p><code>beans</code>:根标签,管理所有的bean</p>
</li>
<li><p><code>bean</code>:配置每一个需要被Spring管理的bean</p>
<ul>
<li><p><code>name</code>:给bean起一个名字,值不唯一</p>
</li>
<li><p><code>id</code>属性:给bean起一个名字,值唯一</p>
</li>
<li><p><code>class</code>属性:bean的全路径</p>
</li>
<li><p><code>property</code>标签:bean的属性</p>
<p>​	<code>name</code>: 属性名</p>
<p>​	<code>value</code>:属性值,只能写基本类型及字符串String</p>
<p>​	<code>ref</code>:属性值,可以写引用类型,引用另外一个bean</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-复杂类型配置"><a href="#3-复杂类型配置" class="headerlink" title="3.复杂类型配置"></a>3.复杂类型配置</h4><h5 id="新建Cat类"><a href="#新建Cat类" class="headerlink" title="新建Cat类"></a>新建Cat类</h5><pre><code class="java">@Data
public class Cat &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private String breed;
&#125;
</code></pre>
<h5 id="改变Person"><a href="#改变Person" class="headerlink" title="改变Person"></a>改变Person</h5><pre><code class="java">@Data
public class Person &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    private Cat cat;
&#125;
</code></pre>
<h5 id="配置person和cat"><a href="#配置person和cat" class="headerlink" title="配置person和cat"></a>配置person和cat</h5><pre><code class="xml">&lt;bean id=&quot;cat&quot; class=&quot;io.xccit.entity.Cat&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;母&quot;/&gt;
    &lt;property name=&quot;breed&quot; value=&quot;英国短毛猫&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;person&quot; class=&quot;io.xccit.entity.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;lucy&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
    &lt;property name=&quot;gender&quot; value=&quot;女&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Person person = context.getBean(Person.class);
System.out.println(person);
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240917225416370.png" alt="image-20240917225416370"></p>
<h3 id="Ioc底层原理"><a href="#Ioc底层原理" class="headerlink" title="Ioc底层原理"></a>Ioc底层原理</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>1.读取配置文件,解析</li>
<li>2.通过反射机制实例化配置文件中的bean</li>
</ul>
<h4 id="手写Ioc"><a href="#手写Ioc" class="headerlink" title="手写Ioc"></a>手写Ioc</h4><h5 id="1-创建Maven工程"><a href="#1-创建Maven工程" class="headerlink" title="1.创建Maven工程"></a>1.创建Maven工程</h5><h5 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2.引入依赖"></a>2.引入依赖</h5><pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;version&gt;1.18.34&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- dom4j 解析xml --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dom4j&lt;/groupId&gt;
  &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="3-复制上一份代码中的配置文件及实体类"><a href="#3-复制上一份代码中的配置文件及实体类" class="headerlink" title="3.复制上一份代码中的配置文件及实体类"></a>3.复制上一份代码中的配置文件及实体类</h5><h5 id="4-定义ApplicationContext接口"><a href="#4-定义ApplicationContext接口" class="headerlink" title="4.定义ApplicationContext接口"></a>4.定义ApplicationContext接口</h5><pre><code class="java">public interface ApplicationContext &#123;
    
&#125;
</code></pre>
<h5 id="5-定义ClassPathXmlApplicationContext实现类"><a href="#5-定义ClassPathXmlApplicationContext实现类" class="headerlink" title="5.定义ClassPathXmlApplicationContext实现类"></a>5.定义ClassPathXmlApplicationContext实现类</h5><pre><code class="java">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;

&#125;
</code></pre>
<h5 id="6-定义-实现方法"><a href="#6-定义-实现方法" class="headerlink" title="6.定义&#x2F;实现方法"></a>6.定义&#x2F;实现方法</h5><pre><code class="java">public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;
    private String configPath;
    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();
    public ClassPathXmlApplicationContext() &#123;
        //指定默认的配置文件
        this.configPath = &quot;spring02-custom-ioc\\src\\main\\resources\\applicationContext.xml&quot;;
        analysisConfig(this.configPath);
    &#125;
    public ClassPathXmlApplicationContext(String configPath) &#123;
        analysisConfig(configPath);
    &#125;

    /**
     * 解析配置文件，将配置文件中的bean标签解析为bean对象，并放入beanMap中
     * @param configPath 配置文件
     */
    public void analysisConfig(String configPath)&#123;
        SAXReader saxReader = new SAXReader();
        try &#123;
            Document document = saxReader.read(configPath);
            Element root = document.getRootElement();
            Iterator&lt;Element&gt; elementIterator = root.elementIterator();
            while(elementIterator.hasNext())&#123;
                Element element = elementIterator.next();
                if(&quot;bean&quot;.equals(element.getName()))&#123;
                    String id = element.attributeValue(&quot;id&quot;);
                    String className = element.attributeValue(&quot;class&quot;);
                    Class&lt;?&gt; clazz = Class.forName(className);
                    Object bean = clazz.newInstance();
                    //给对象赋值
                    Iterator&lt;Element&gt; propertyIterator = element.elementIterator();
                    while(propertyIterator.hasNext())&#123;
                        Element propertyElement = propertyIterator.next();
                        String propertyName = propertyElement.attributeValue(&quot;name&quot;);
                        String propertyValue = propertyElement.attributeValue(&quot;value&quot;);
                        Field field = clazz.getDeclaredField(propertyName);
                        String methodName = &quot;set&quot; + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
                        Method declaredMethod = clazz.getDeclaredMethod(methodName, field.getType());
                        String typeName = field.getType().getName();
                        //如果该对象的property有ref属性,则赋值为对应的bean对象
                        if(propertyElement.attributeValue(&quot;ref&quot;) != null)&#123;
                            Object refBean = beanMap.get(propertyElement.attributeValue(&quot;ref&quot;));
                            declaredMethod.invoke(bean, refBean);
                            continue;
                        &#125;
                        //调用set方法, 将属性值注入到对象中
                        if (typeName.equals(&quot;int&quot;) || typeName.equals(&quot;java.lang.Integer&quot;))&#123;
                            declaredMethod.invoke(bean, Integer.parseInt(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;java.lang.String&quot;))&#123;
                            declaredMethod.invoke(bean, propertyValue);
                        &#125;
                        if (typeName.equals(&quot;boolean&quot;) || typeName.equals(&quot;java.lang.Boolean&quot;))&#123;
                            declaredMethod.invoke(bean, Boolean.parseBoolean(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;double&quot;) || typeName.equals(&quot;java.lang.Double&quot;))&#123;
                            declaredMethod.invoke(bean, Double.parseDouble(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;float&quot;) || typeName.equals(&quot;java.lang.Float&quot;))&#123;
                            declaredMethod.invoke(bean, Float.parseFloat(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;long&quot;) || typeName.equals(&quot;java.lang.Long&quot;))&#123;
                            declaredMethod.invoke(bean, Long.parseLong(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;char&quot;) || typeName.equals(&quot;java.lang.Character&quot;))&#123;
                            declaredMethod.invoke(bean, propertyValue.charAt(0));
                        &#125;
                        if (typeName.equals(&quot;short&quot;) || typeName.equals(&quot;java.lang.Short&quot;))&#123;
                            declaredMethod.invoke(bean, Short.parseShort(propertyValue));
                        &#125;
                        if (typeName.equals(&quot;byte&quot;) || typeName.equals(&quot;java.lang.Byte&quot;))&#123;
                            declaredMethod.invoke(bean, Byte.parseByte(propertyValue));
                        &#125;
                    &#125;
                    beanMap.put(id,bean);
                &#125;
            &#125;
        &#125; catch (DocumentException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchFieldException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    @Override
    public Object getBean(String beanId) &#123;
        return beanMap.get(beanId);
    &#125;
&#125;
</code></pre>
<h5 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h5><pre><code class="java">public class App &#123;
    public static void main( String[] args ) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240918212023333.png" alt="image-20240918212023333"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ffa2c4">SSM</a>
        </span>
        
    </div>
    <a href="/2024/09/17/Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/02/SpringAI%E5%88%9D%E4%BD%93%E9%AA%8C/">
        <h2 class="post-title">SpringAI初体验</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SpringAI简介"><a href="#SpringAI简介" class="headerlink" title="SpringAI简介"></a>SpringAI简介</h1><p>Spring AI是一个<code>基于Spring Boot</code>框架的AI应用开发工具包。它旨在简化A!模型的集成和部署，使开发者能够更快地构建智能应用。SpringAI提供了一系列功能，包括对话管理、自然语言处理、图像识别等，其中<code>ChatGPT</code>就是其中之一。</p>
<h1 id="SpringAI环境搭建"><a href="#SpringAI环境搭建" class="headerlink" title="SpringAI环境搭建"></a>SpringAI环境搭建</h1><h2 id="1-创建SpringBoot工程"><a href="#1-创建SpringBoot工程" class="headerlink" title="1.创建SpringBoot工程"></a>1.创建SpringBoot工程</h2><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902223807549.png" alt="image-20240902223807549"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902223945095.png" alt="image-20240902223945095"></p>
<blockquote>
<p><code>Tips:</code>SpringBoot3必须使用JDK17及以上版本,请求接口需要使用到WEB模块,所以导入Spring Web,我们选择使用ChatGpt,所以导入openai依赖</p>
</blockquote>
<p>创建完成的项目依赖应该如下:</p>
<pre><code class="xml">    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;spring-ai.version&gt;1.0.0-M2&lt;/spring-ai.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<blockquote>
<p><code>Tips:</code>由于阿里等maven仓库未能及时更新SpringAI的依赖,所以Maven配置阿里仓库等国内源会导致依赖下载失败,可以使用maven公共仓库以及配合科学上网解决此问题</p>
</blockquote>
<h2 id="2-接口申请"><a href="#2-接口申请" class="headerlink" title="2.接口申请"></a>2.接口申请</h2><p>由于ChatGpt需要使用<code>科学上网</code>外加<code>$</code>支付,可以使用国内的OpenAI中转站,这里使用<a target="_blank" rel="noopener" href="https://api.xty.app/">https://api.xty.app/</a></p>
<h3 id="2-1-注册"><a href="#2-1-注册" class="headerlink" title="2.1 注册"></a>2.1 注册</h3><p>使用<code>https://api.xty.app/register?aff=iz9s</code>链接进行注册,可以获得<code>1.0$</code>的免费额度</p>
<h3 id="2-2-生成令牌"><a href="#2-2-生成令牌" class="headerlink" title="2.2 生成令牌"></a>2.2 生成令牌</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902224738699.png" alt="image-20240902224738699"></p>
<p>点击此处使用账户送的<code>1.0$</code>申请令牌即可</p>
<h2 id="3-接口开发"><a href="#3-接口开发" class="headerlink" title="3.接口开发"></a>3.接口开发</h2><h3 id="3-1-配置AI参数"><a href="#3-1-配置AI参数" class="headerlink" title="3.1 配置AI参数"></a>3.1 配置AI参数</h3><pre><code class="yaml">spring:
  # ChatGPT配置
  ai:
    openai:
      api-key: 你申请到的key
      base-url: https://api.xty.app
      chat:
        options:
          model: gpt-3.5-turbo
</code></pre>
<p>关于配置,可以在<a target="_blank" rel="noopener" href="https://api.xty.app/%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">https://api.xty.app/查看使用教程</a></p>
<p>关于SpringAI的更多配置,可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/chat/openai-chat.html#_sample_controller%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B%E5%8F%8A%E9%85%8D%E7%BD%AE">https://docs.spring.io/spring-ai/reference/api/chat/openai-chat.html#_sample_controller进行查看及配置</a></p>
<h3 id="3-2-接口定义"><a href="#3-2-接口定义" class="headerlink" title="3.2 接口定义"></a>3.2 接口定义</h3><pre><code class="java">/**
 * @author CH_ywx
 * @version 1.0
 * @create 2024/9/2
 * &lt;p&gt;AI测试控制器&lt;/p&gt;
 */
@CrossOrigin
@RestController
public class OpenAIController &#123;
    private final OpenAiChatModel chatModel;

    @Autowired
    public OpenAIController(OpenAiChatModel chatModel) &#123;
        this.chatModel = chatModel;
    &#125;
    @GetMapping(&quot;/ai/generate&quot;)
    public Map generate(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;) String message) &#123;
        return Map.of(&quot;generation&quot;, chatModel.call(message));
    &#125;

    @GetMapping(value = &quot;/ai/generateStream&quot;,produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; generateStream(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;) String message) &#123;
//        Prompt prompt = new Prompt(new UserMessage(message));
        Flux&lt;String&gt; stream = chatModel.stream(message);
        return stream;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>以上代码在官网都可以copy的到,稍加改动即可</p>
</blockquote>
<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902225103791.png" alt="image-20240902225103791"></p>
<h2 id="4-接入前端测试"><a href="#4-接入前端测试" class="headerlink" title="4.接入前端测试"></a>4.接入前端测试</h2><h3 id="4-1-创建Vue项目"><a href="#4-1-创建Vue项目" class="headerlink" title="4.1 创建Vue项目"></a>4.1 创建Vue项目</h3><pre><code class="javascript">npm create vite
填写项目信息,选择vue项目,javascript语言
cd /项目根路径
npm run dev
</code></pre>
<h3 id="4-2-删除项目自带的组件及css等无关配置"><a href="#4-2-删除项目自带的组件及css等无关配置" class="headerlink" title="4.2 删除项目自带的组件及css等无关配置"></a>4.2 删除项目自带的组件及css等无关配置</h3><p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902225259851.png" alt="image-20240902225259851"></p>
<h3 id="4-3-改造App-vue"><a href="#4-3-改造App-vue" class="headerlink" title="4.3 改造App.vue"></a>4.3 改造App.vue</h3><pre><code class="javascript">&lt;script setup&gt;
  import &#123;ref&#125; from &#39;vue&#39;
  const message = ref(&#39;&#39;)
  const result = ref([])
  const sendMessage = ()=&gt;&#123;
    //事件流请求
    let source = new EventSource(`http://localhost:8080/ai/generateStream?message=$&#123;message.value&#125;`)
    source.onmessage = (event)=&gt;&#123;
      result.value.push(event.data)
    &#125;
  &#125;
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;小昕AI v1.0&lt;/h1&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;historyWindow&quot;&gt;
      &lt;span v-for=&quot;(text,index) in result&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;text&#125;&#125;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;chatWindow&quot;&gt;
      &lt;textarea class=&quot;chatText&quot; v-model=&quot;message&quot;&gt;
      &lt;/textarea&gt;
      &lt;button class=&quot;chatSend&quot; @click=&quot;sendMessage()&quot;&gt;发&amp;nbsp;&amp;nbsp;送&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  *&#123;
    margin: 0px;
    padding: 0px;
  &#125;
  .container&#123;
    display: flex;
    width: 100%;
    height: 100vh;
    flex-direction: row;
    flex-wrap: wrap;
  &#125;
  .historyWindow&#123;
    //background-color: aqua;
    width: 100%;
    height: 600px;
    border: 3px solid aqua;
    border-radius: 5px;
    color: black;
  &#125;
  .chatWindow&#123;
    display: flex;
    //background-color: #646cff;
    width: 100%;
    height: 100px;
  &#125;
  .chatText&#123;
    width: 80%;
    height: 100%;
  &#125;
  .chatSend&#123;
    width: 10%;
    height: 50px;
    flex: content;
    margin-top: 50px;
    color: aqua;
    font-size: 30px;
  &#125;
&lt;/style&gt;
</code></pre>
<h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><pre><code class="javascript">npm run dev
</code></pre>
<blockquote>
<p><code>Tips:</code>接入的模型为ChatGpt3.5,可以进行聊天对话,资料查询等等功能</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240902230707068.png" alt="image-20240902230707068"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/SpringAI/" style="color: #ffa2c4">SpringAI</a>
        </span>
        
    </div>
    <a href="/2024/09/02/SpringAI%E5%88%9D%E4%BD%93%E9%AA%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/01/%E5%88%9D%E5%A7%8Bredis/">
        <h2 class="post-title">初识redis</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><blockquote>
<p>Redis是使用C语言开发的一款高性能开源键值对非关系性数据库,数据间没有必然的关联关系,内部采用单线程机制进行工作,有高性能、高并发的特性,可进行数据持久化,数据灾难恢复</p>
</blockquote>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>通过百度网盘分享的文件：Redis-x64-3.2.100.msi<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/11co2TyJzmNyj4dw8NJWHIg?pwd=1209">https://pan.baidu.com/s/11co2TyJzmNyj4dw8NJWHIg?pwd=1209</a><br>提取码：1209</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a target="_blank" rel="noopener" href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/">Install Redis on Linux | Docs</a></p>
<h1 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h1><h2 id="作为缓存使用"><a href="#作为缓存使用" class="headerlink" title="作为缓存使用"></a>作为缓存使用</h2><ul>
<li>业务功能设计,例如:秒杀、促销、抢票等</li>
<li>高频访问数据,例如:在线人数统计</li>
</ul>
<h2 id="系统功能优化"><a href="#系统功能优化" class="headerlink" title="系统功能优化"></a>系统功能优化</h2><ul>
<li>单服务器升级集群</li>
<li>Session、Token管理</li>
</ul>
<h1 id="Redis基本使用"><a href="#Redis基本使用" class="headerlink" title="Redis基本使用"></a>Redis基本使用</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre><code class="shell">select 0 //选择0号数据库(0-15)
dbsize //当前数据库key的总数
exists key //查看某个key是否存在,存在返回1,不存在返回0
keys * //获取当前数据库所有键
get key //获取key对应的value
type key //获取件对应的value的类型
del key //删除指定的key:value
expire key num //key:键 num:数字 给key设置n秒后过期
ttl key //查看key剩余的过期时间
persist key //去除key的过期时间
</code></pre>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ul>
<li>bind: 绑定redis自身的服务器的ip，不是绑定访问过来的IP地址，默认是127.0.0.1，即只允许本地访问</li>
<li>port:  指定redis监听端口，默认为6379</li>
<li>requirepass:  设置连接密码，客户端连接时，需要密码认证</li>
<li>protected-mode: 开启保护模式(默认开启)，若开启且bind未配置密码也未设置，redis只接受本机连接</li>
<li>timeout: 设置客户端连接时的超时时间，单位为秒，默认值：0代表禁用，永不关闭</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis中的数据类型针对的是value的值,key永远是字符串</p>
<h3 id="1-string字符串"><a href="#1-string字符串" class="headerlink" title="1.string字符串"></a>1.string字符串</h3><pre><code class="shell">set key value //存储
get key //获取
del key //删除

mset key1 value1 key2 value2 ……  //存储多个
mget key1 key2 …… //获取多个

setex key seconds value //设置秒
setex key milliseconds value //设置毫秒
</code></pre>
<h3 id="2-Hash哈希类型"><a href="#2-Hash哈希类型" class="headerlink" title="2.Hash哈希类型"></a>2.Hash哈希类型</h3><pre><code class="shell">hset key field value //存储 hset user username zhangsan
hget key field  //获取一个  hget user username
hgetall key //获取全部
hdel key field  //删除 hdel user username
</code></pre>
<h3 id="3-list列表类型"><a href="#3-list列表类型" class="headerlink" title="3.list列表类型"></a>3.list列表类型</h3><ul>
<li>采用双向链表linkedlist,支持重复元素</li>
<li>可以添加一个元素到列表的头部或者尾部</li>
</ul>
<pre><code class="shell">lpush key value //将元素添加到列表头部
rpush key value //将元素添加到列表尾部
lrange key start end //获取start-end索引位置的元素
lrange key 0 -1 //获取所有元素
lpop key //删除最左边的元素
rpop //删除最右边的元素
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20240901102627970.png" alt="image-20240901102627970"></p>
<h3 id="4-set集合类型"><a href="#4-set集合类型" class="headerlink" title="4.set集合类型"></a>4.set集合类型</h3><h4 id="4-1无序集合"><a href="#4-1无序集合" class="headerlink" title="4.1无序集合"></a>4.1无序集合</h4><blockquote>
<p>不允许重复,元素无序</p>
</blockquote>
<pre><code class="shell">sadd key value //存储
sadd key value1,value2... //存储多个
smembers key //获取该key的所有元素
srem key value //删除该key的value
</code></pre>
<h4 id="4-2有序集合"><a href="#4-2有序集合" class="headerlink" title="4.2有序集合"></a>4.2有序集合</h4><blockquote>
<p>元素不允许重复,但元素有序,每个元素都会关联一个double类型的分数</p>
</blockquote>
<pre><code class="shell">zadd key score value //存储
zrange key start end //获取start至end之间的元素
zrange key 0 -1 withscores //获取全部并带着分数
zrem key value //删除该key的value
</code></pre>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><blockquote>
<p>默认的数据持久化方式,不需要配置,在一定的时间间隔中,检测key的变化,最终持久化数据</p>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>redis.conf:</code></p>
<ul>
<li>save 500 1  :900秒后至少有1个key发生改变就持久化一次</li>
<li>save 200 10  :300秒后至少有10key发生改变就持久化一次</li>
<li>save 100 100 :50秒后至少有10000个key发生改变就持久化一次</li>
</ul>
<blockquote>
<p>注意:修改配置文件后需要重启redis服务</p>
</blockquote>
<h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><blockquote>
<p>通过日志记录对的方式,记录每一条命令的操作。每次操作后持久化数据。</p>
</blockquote>
<p><code>redis.conf</code></p>
<ul>
<li>appendonly no（关闭）</li>
<li>appendonly yes（开启）</li>
<li>appendfsync always  每次操作都持久化</li>
<li>appendfsync everysec  每隔一秒持久化（默认值）</li>
<li>appendfsync no  不持久化</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Redis/" style="color: #ff7d73">Redis</a>
        </span>
        
    </div>
    <a href="/2024/09/01/%E5%88%9D%E5%A7%8Bredis/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/13/vite-vue3%E5%B0%81%E8%A3%85request-js/">
        <h2 class="post-title">vite+vue3封装request.js</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="vite-vue3封装request-js"><a href="#vite-vue3封装request-js" class="headerlink" title="vite+vue3封装request.js"></a>vite+vue3封装request.js</h1><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><ul>
<li><p>1.安装node.js</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere (nodejs.org)</a></p>
</blockquote>
<p>尽量安装LTS版本</p>
</li>
<li><p>2.创建工程</p>
<blockquote>
<p>npm init vite@latest</p>
<p>选择<code>vue</code></p>
<p>选择<code>3</code></p>
<p>输入项目名称，例如<code>my-vue3-project</code></p>
<p>选择存放项目的路径</p>
<p>cd my-vue3-project<br>npm run dev</p>
</blockquote>
</li>
</ul>
<h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h2><h3 id="1-安装axios"><a href="#1-安装axios" class="headerlink" title="1.安装axios"></a>1.安装axios</h3><pre><code class="shell">npm install axios
</code></pre>
<h3 id="2-封装request-js"><a href="#2-封装request-js" class="headerlink" title="2.封装request.js"></a>2.封装request.js</h3><p>在<code>src</code>下新建<code>utils</code>文件夹，新建<code>request.js</code></p>
<pre><code class="javascript">import axios from &quot;axios&quot;
import &#123; ElMessage &#125; from &#39;element-plus&#39;;
import &#123;useTokenStore&#125; from &quot;@/store/token.js&quot;;

const baseURL = &#39;/api&#39;
// 创建axios实例
const service = axios.create(&#123;
    baseURL: baseURL, // 设置默认的 API 地址，url = baseURL + url（使用proxy代理时此处可不写）
    timeout: 5000,	// 设置请求超时时间
&#125;)

//请求拦截器
service.interceptors.request.use(
    (config)=&gt;&#123;
        let tokenStore = useTokenStore()
        if (tokenStore.token)&#123;
            config.headers.Authorization = tokenStore.token
        &#125;
        return config
    &#125;,
    (error)=&gt;&#123;
        ElMessage.error(error.message)
        return Promise.reject(error)
    &#125;
)

// 响应拦截器
service.interceptors.response.use(
    // 响应数据，2xx 范围内的状态码都会触发该函数。
    (response) =&gt; &#123;
        if (response.data.code == 200)&#123;
            const &#123; status, data &#125; = response;
            if (status === 200) &#123;
                const &#123; code, message &#125; = data;
                // 根据后端返回的自定义状态码 code 进行错误信息提示（根据具体需求确定是否需要书写）
                switch (code) &#123;
                    case 401:
                        ElMessage(&#123; message: message, type: &#39;error&#39; &#125;)
                        return Promise.reject(data);
                    default:
                        return data;
                &#125;
            &#125;
        &#125;else&#123;
            return Promise.reject(response.data)
        &#125;
    &#125;,
    (error) =&gt; &#123;
        if (error.response) &#123;
            const &#123; status, data &#125; = error.response;
            ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // if (status === 500) &#123;
            //     ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // &#125; else if (status === 401) &#123;
            //     ElMessage(&#123; message: data.message, type: &#39;error&#39; &#125;)
            // &#125; else &#123;
            //     ElMessage(&#123; message: data.message || &#39;未知错误！&#39;, type: &#39;error&#39; &#125;)
            // &#125;
        &#125; else if (error.request) &#123;
            // 请求已发送，未收到响应
            ElMessage(&#123; message: error.message || &#39;请求已发送，未收到响应信息！&#39;, type: &#39;error&#39; &#125;)
        &#125; else &#123;
            // 其他错误
            ElMessage(&#123; message: error.message, type: &#39;error&#39; &#125;)
        &#125;
        // 若简写，上面代码可省略，只写此一行
        return Promise.reject(error);
    &#125;
)

export default service;
</code></pre>
<h3 id="3-使用pinia进行状态管理"><a href="#3-使用pinia进行状态管理" class="headerlink" title="3.使用pinia进行状态管理"></a>3.使用pinia进行状态管理</h3><p>后端接口一般都是需要验证token来进行访问的：</p>
<p>新建<code>src/store/token.js</code></p>
<pre><code class="javascript">import &#123;defineStore&#125; from &#39;pinia&#39;
import &#123;ref&#125; from &quot;vue&quot;;

export const useTokenStore = defineStore(&#39;token&#39;,()=&gt;&#123;
    const token = ref(&#39;&#39;)
    const setToken = (newToken)=&gt;&#123;
        token.value = newToken
    &#125;

    const removeToken = ()=&gt;&#123;
        token.value = &#39;&#39;
    &#125;

    return &#123;token,setToken,removeToken&#125;
&#125;)
</code></pre>
<p>这里定义了pinia状态管理的js文件，但是我们需要在<code>main.js</code>中使用pinia</p>
<pre><code class="javascript">import &#123;createPinia&#125; from &#39;pinia&#39;
const pinia = createPinia()

const app = createApp(App)
app.use(ElementPlus,&#123;locale&#125;)
    .use(router)
    .use(pinia)
app.mount(&#39;#app&#39;)
</code></pre>
<p>忽略掉ElementPlus与locale以及router,并且在上面的<code>request.js</code>文件中，同样引入了<code>token.js</code>,这是为了方便将登录后获得的token传给请求拦截器，在请求头<code>Headers</code>中加入token</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>定义接口文件<code>api/user.js</code></p>
<pre><code class="javascript">import request from &#39;@/utils/request.js&#39;

const baseUrl = &#39;/user&#39;
export const register = (params)=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/register`,
        params: params
    &#125;)
&#125;

export const login = (params)=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/login`,
        params: params
    &#125;)
&#125;

export const logout = ()=&gt;&#123;
    return request(&#123;
        method: &quot;POST&quot;,
        url: `$&#123;baseUrl&#125;/logout`
    &#125;)
&#125;
</code></pre>
<p>定义接口文件<code>category.js</code></p>
<pre><code class="javascript">import request from &#39;@/utils/request.js&#39;

const baseUrl = &#39;/category&#39;
export const list = ()=&gt;&#123;
    return request(&#123;
        method: &#39;GET&#39;,
        url: `$&#123;baseUrl&#125;`
    &#125;)
&#125;

export const insert = (category)=&gt;&#123;
    return request(&#123;
        method: &#39;POST&#39;,
        url:`$&#123;baseUrl&#125;`,
        data: category
    &#125;)
&#125;

export const update = (category)=&gt;&#123;
    return request(&#123;
        method: &#39;PUT&#39;,
        url: `$&#123;baseUrl&#125;`,
        data: category
    &#125;)
&#125;

export const remove = (id)=&gt;&#123;
    return request(&#123;
        method: &#39;DELETE&#39;,
        url: `$&#123;baseUrl&#125;/$&#123;id&#125;`
    &#125;)
&#125;

export const detail = (id)=&gt;&#123;
    return request(&#123;
        method: &#39;GET&#39;,
        url: `$&#123;baseUrl&#125;/detail`,
        params: id
    &#125;)
&#125;
</code></pre>
<p>登录后发送请求，浏览器控制台：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/QQ_1723528176173.png" alt="QQ_1723528176173" style="zoom:150%;" />

<p><code>前端新手，若有不对欢迎指正</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="color: #03a9f4">前端开发</a>
        </span>
        
    </div>
    <a href="/2024/08/13/vite-vue3%E5%B0%81%E8%A3%85request-js/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/08/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">
        <h2 class="post-title">Java基础笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="JAVA快速入门"><a href="#JAVA快速入门" class="headerlink" title="JAVA快速入门"></a>JAVA快速入门</h1><p>注:个人笔记，适合新手学习，适合对Java SE的复习，请勿转载,如有错误请指教，虚心改正 </p>
<p><code>QQ: 1571466236</code></p>
<p><code>wechat: lucky_all_time_max</code></p>
<h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>准备环境：JAVA 8（JDK8） Windows 10系统</p>
<p>本教程使用的是Java8，在2018年企业开始陆续使用JAVA11，到后面13,16都在用，但8是最稳定的一个版本，新版本特性我辞职后没有好好学习，只能使用我所掌握的jdk8</p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Oracle官网</a>下载JDK安装包：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908231449599.png" alt="image-20210908231449599"></p>
<p>大家可以看到的是页面打开有很多版本，我们需要根据自己所使用的系统进行选择，windows系统使用*.exe*后缀的安装包即可，但在此之前确定好自己的系统是32bit还是64bit，一般家用电脑都是64bit，下载<strong>windows x64</strong>的版本。</p>
<p>安装步骤很简单且我电脑已经装了多个版本，就不一一给大家截图演示，直接在安装界面点击next或者下一步即可。</p>
<h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><h4 id="1-配置JAVA-HOME"><a href="#1-配置JAVA-HOME" class="headerlink" title="1.配置JAVA_HOME"></a>1.配置JAVA_HOME</h4><p>windows10:</p>
<p>桌面此电脑鼠标右击—-&gt;属性—-&gt;高级系统设置—-&gt;环境变量</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908232718137.png" alt="image-20210908232718137"></p>
<p>这里注意：上面的是用户变量，切换用户后就会失效，下面的是系统变量，我们要在系统变量中设置环境变量</p>
<p>新建：JAVA_HOME</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908232848228.png" alt="image-20210908232848228"></p>
<p>变量值是安装JAVA的路径，安装时注意看好路径，一般默认都在C盘下的Program Files\Java</p>
<p>找到Path环境变量：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908233118938.png" alt="image-20210908233118938"></p>
<h4 id="2-配置Path"><a href="#2-配置Path" class="headerlink" title="2.配置Path"></a>2.配置Path</h4><p>将</p>
<p><strong>%JAVA_HOME%\bin</strong></p>
<p><strong>%JAVA_HOME%\jre\bin</strong></p>
<p>加入到Path，将这两条变量值上移到置顶</p>
<p>确定</p>
<h4 id="3-配置CLASSPATH"><a href="#3-配置CLASSPATH" class="headerlink" title="3.配置CLASSPATH"></a>3.配置CLASSPATH</h4><p>找到ClASSPATH，没有就新建：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908233317079.png" alt="image-20210908233317079"></p>
<p>变量值：</p>
<pre><code class="java">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
</code></pre>
<p>完成后确定，退出来</p>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>使用组合键WIN+R，输入CMD，回车</p>
<p>在命令窗口分别输入：</p>
<p>java -version        </p>
<p>javac</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908234658646.png" alt="image-20210908234658646"></p>
<p>这两条命令都有输出的时候代表环境配置成功。</p>
<h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>新建文件 Hello.java</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, world!&quot;);
    &#125;
&#125;
</code></pre>
<p>它的意思是在屏幕上打印出 Hello,world！ 这行文本内容。</p>
<p>Java源码本质上是一个文本文件，我们需要先用<code>javac</code>把<code>Hello.java</code>编译成字节码文件<code>Hello.class</code>，然后，用<code>java</code>命令执行这个字节码文件：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908235215588.png" alt="image-20210908235215588"></p>
<p>在Hello.java文件目录中运行cmd，使用命令javac Hello.java</p>
<p>如果源代码无误，上述命令不会有任何输出，而当前目录下会产生一个<code>Hello.class</code>文件：</p>
<p>使用命令java Hello</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210908235622515.png" alt="image-20210908235622515"></p>
<p>出现上面结果就很完美，第一个程序运行完成！</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><strong>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</strong></p>
<p><strong>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</strong></p>
<p><strong>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</strong></p>
<h3 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h3><p>Java程序的入口是<code>main</code>方法，而<code>main</code>方法可以接受一个命令行参数，它是一个<code>String[]</code>数组。</p>
<p>这个命令行参数由JVM接收用户输入并传给<code>main</code>方法：</p>
<p>Java的<strong>main</strong>方法后面小括号中有<strong>String[] args</strong>,可以传入参数使用，比如我们写如下代码:</p>
<pre><code class="java">public class Hello&#123;
    public static void main(String[] args)&#123;
        for(String arg : args)&#123;
            if(arg.equals(&quot;-version&quot;))&#123;
                System.out.print(&quot;v1.0&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211007165158004-16335967296361.png" alt="image-20211007165158004"></p>
<p>对程序编译过后运行，带上一个**”-version”<strong>参数，程序做出了反应，将我们设置好的</strong>“v1.0”**打印了出来</p>
<h2 id="JAVA程序基础"><a href="#JAVA程序基础" class="headerlink" title="JAVA程序基础"></a>JAVA程序基础</h2><p>因为Java是面向对象的语言，一个程序的基本单位就是<code>class</code>，<code>class</code>是关键字，这里定义的<code>class</code>名字就是<code>Hello</code>：</p>
<pre><code class="java">public class Hello&#123;
    
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p>类名要求：</p>
<ul>
<li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>习惯以大写字母开头</li>
</ul>
<p>要注意遵守命名习惯，好的类命名：</p>
<ul>
<li>Hello</li>
<li>NoteBook</li>
<li>VRPlayer</li>
</ul>
<p>不好的类命名：</p>
<ul>
<li>hello</li>
<li>Good123</li>
<li>Note_Book</li>
<li>_World</li>
</ul>
<p><strong>注意：</strong></p>
<p><code>public</code>是访问修饰符，表示该<code>class</code>是公开的。</p>
<p>不写<code>public</code>，也能正确编译，但是这个类将无法从命令行执行。</p>
<p>在<code>class</code>内部，可以定义若干方法（method）：</p>
<pre><code class="java">public class Hello&#123;
    public static void main(String[] args)&#123;
        
    &#125;
&#125;
</code></pre>
<p>这里的main便是一个<strong>方法</strong>，也称为<strong>函数</strong></p>
<p>方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。</p>
<p>这里的方法名是<code>main</code>，返回值是<code>void</code>，表示没有任何返回值。</p>
<p>我们注意到<code>public</code>除了可以修饰<code>class</code>外，也可以修饰方法。而关键字<code>static</code>是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组。</p>
<p>方法名也有命名规则，命名和<code>class</code>一样，但是首字母小写：</p>
<p>好的方法命名：</p>
<ul>
<li>main</li>
<li>goodMorning</li>
<li>playVR</li>
</ul>
<p>不好的方法命名：</p>
<ul>
<li>Main</li>
<li>good123</li>
<li>good_morning</li>
<li>_playVR</li>
</ul>
<p>在方法内部，语句才是真正的执行代码。<strong>Java的每一行语句必须以分号结束：</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, world!&quot;); // 语句
    &#125;
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p>&#x2F;&#x2F;语句  ：这是Java中的<strong>注释</strong>，代码用于电脑读取，相当于人给电脑的指令，但&#x2F;&#x2F;后面的内容供人阅读，在企业中通常存在程序员离职的情况，这个时候注释的作用就体现出来了，有注释的代码看起来是清晰的，在另一名程序员接手项目的时候可以很快上手。</p>
<p>注释类型:</p>
<pre><code class="java">//单行注释
/*
  1
  2
  3
  多行注释
*/
/**
@Author Xccit
Javadoc
*/
</code></pre>
<h2 id="JAVA变量和数据类型"><a href="#JAVA变量和数据类型" class="headerlink" title="JAVA变量和数据类型"></a>JAVA变量和数据类型</h2><p>变量的概念，我们在小学时候就接触到了，解方程做应用题的时候：</p>
<p>设某某为x，x是一个不确定的量，所以称为变量</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int x = 100; // 定义int类型变量x，并赋予初始值100
        System.out.println(x); // 打印该变量的值
    &#125;
&#125;
</code></pre>
<p>试着运行以上代码：</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>引用类型最常见的就是String</p>
<p>在以后的学习中，会使用形形色色的变量，各种数据类型都会使用</p>
<h4 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h4><p>在Java中，多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围，例如：</p>
<pre><code class="java">if (...) &#123; // if开始
    ...
    while (...) &#123; // while 开始
        ...
        if (...) &#123; // if开始
            ...
        &#125; // if结束
        ...
    &#125; // while结束
    ...
&#125; // if结束
</code></pre>
<p>只要正确地嵌套这些{ }，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子：</p>
<pre><code class="java">&#123;
    ...
    int i = 0; // 变量i从这里开始定义
    ...
    &#123;
        ...
        int x = 1; // 变量x从这里开始定义
        ...
        &#123;
            ...
            String s = &quot;hello&quot;; // 变量s从这里开始定义
            ...
        &#125; // 变量s作用域到此结束
        ...
        // 注意，这是一个新的变量s，它和上面的变量同名，
        // 但是因为作用域不同，它们是两个不同的变量:
        String s = &quot;hi&quot;;
        ...
    &#125; // 变量x和s作用域到此结束
    ...
&#125; // 变量i作用域到此结束
</code></pre>
<p>定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。</p>
<h4 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h4><p>常量定义：</p>
<pre><code class="java">final int i = 1;
</code></pre>
<p>上面的语句使用关键字<strong>final</strong>定义了一个int类型的常量 i</p>
<p>常量定义后不可改变其值（不可重新赋值）；</p>
<h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>Java提供了两种变量类型：基本类型和引用类型</p>
<p>基本类型包括整型，浮点型，布尔型，字符型。</p>
<p>变量可重新赋值，等号是赋值语句，不是数学意义的等号。</p>
<p>常量在初始化后不可重新赋值，使用常量便于理解程序意图。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="整型运算"><a href="#整型运算" class="headerlink" title="整型运算"></a>整型运算</h4><p>整形运算整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    &#125;
&#125;
</code></pre>
<p><strong>溢出:</strong></p>
<p>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    &#125;
&#125;
</code></pre>
<p>可以自行运行以上代码测试，关于溢出的概念，大家可以买《Java核心技术》这本书继续稳固和提升。</p>
<h4 id="浮点型运算"><a href="#浮点型运算" class="headerlink" title="浮点型运算"></a>浮点型运算</h4><p>浮点型运算和整型运算的最大区别，就是浮点型无法进行位运算和移位运算。</p>
<p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p>
<p><strong>举个栗子：</strong></p>
<p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p>
<p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);
        System.out.println(y);
    &#125;
&#125;
</code></pre>
<p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>
<pre><code class="java">// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r &lt; 0.00001) &#123;
    // 可以认为相等
&#125; else &#123;
    // 不相等
&#125;
</code></pre>
<p>浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循<strong>IEEE-754</strong>标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。</p>
<p><strong>类型提升：</strong></p>
<p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 5;
        double d = 1.2 + 24.0 / n; // 6.0
        System.out.println(d);
    &#125;
&#125;
</code></pre>
<p>需要注意的是，在一个复杂的四则运算中出现两个整数的情况下·，整型不会进行类型提升：</p>
<pre><code class="java">double d = 1.2 + 24 / 5; //5.2
</code></pre>
<p>对比如上两条代码，理解类型提升的概念。</p>
<p><strong>溢出：</strong></p>
<p>整型运算在除数为0时会报错并结束程序，但在浮点型运算中如果除数为0，不会报错，但会返回几个特殊值：</p>
<p>NaN：表示 not a number 非数字</p>
<p>Infinity：表示无穷大</p>
<p>-Infinity:表示负无穷</p>
<p>例如：</p>
<pre><code class="java">double x = 0.0 / 0; //NaN
double y = 1.0 / 0; //Infinity
double z = -1.0 / 0; //-Infinity
</code></pre>
<p><strong>强制转型：</strong></p>
<p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p>
<pre><code class="java">int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647   1后面的小数点后移20位
</code></pre>
<p>如果要进行<strong>四舍五入</strong>，可以对浮点数加上0.5再强制转型：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        double d = 2.6;
        int n = (int) (d + 0.5);
        System.out.println(n);
    &#125;
&#125;
</code></pre>
<p><strong>小结</strong></p>
<p>浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；</p>
<p>比较两个浮点数通常比较它们的差的绝对值是否小于一个特定值；</p>
<p>整型和浮点型运算时，整型会自动提升为浮点型；</p>
<p>可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。</p>
<h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><p>对于<strong>boolean</strong>类型，永远只有两个值：<strong>true</strong>和<strong>false</strong></p>
<p>布尔运算是一种关系运算，包括以下几种运算符:</p>
<ul>
<li><p>比较运算符: <code>&lt;   &gt;   &gt;=   &lt;=   ==   != </code></p>
</li>
<li><p>与运算 <code>&amp;&amp;</code></p>
</li>
<li><p>或运算 <code>||</code></p>
</li>
<li><p>非运算  <code> !</code></p>
<pre><code class="java">boolean isGreater = 5 &gt; 3; // true
int age = 12;
boolean isZero = age == 0; // false
boolean isNonZero = !isZero; // true
boolean isAdult = age &gt;= 18; // false
boolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true
</code></pre>
</li>
</ul>
<p>关系运算符的优先级从高到低依次是：</p>
<ul>
<li><code>!</code></li>
<li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
<li><code>==</code>，<code>!=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ul>
<p><strong>短路运算</strong></p>
<p>首先了解一下短路运算的概念，它是布尔运算中的一个重要概念，短路运算在提前确定结果后就会停止后续结果的执行，直接返回结果。</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &lt; 3;
        boolean result = b &amp;&amp; (5 / 0 &gt; 0);
        System.out.println(result);//false
    &#125;
&#125;
</code></pre>
<p>在以上代码中，<code>b</code>的值为<code> false</code>,而<code>b</code>和<code>（5 / 0 &gt; 0）</code>之间使用<code>&amp;&amp;</code>运算符，<code>b</code>已经为<code>false</code>，<code>result</code>的整体结果就已经注定是<code>false</code>，至于<code>(5 /0 &gt; 0)</code>已经不需要去管。</p>
<p>如果没有短路运算，<code>&amp;&amp;</code>后面的表达式会由于除数为<code>0</code>而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果<code>false</code>。</p>
<p>如果变量<code>b</code>的值为<code>true</code>，则表达式变为<code>true &amp;&amp; (5 / 0 &gt; 0)</code>。因为无法进行短路运算，该表达式必定会由于除数为<code>0</code>而报错，可以自行测试。(&amp;&amp;运算符是第一个表达式为false则直接为false，而第一个表达式为true，它就需要确定&amp;&amp;之后的表达式，若表达式为false，整体结果依旧是false，如果表达式错误则程序会报错)</p>
<p>如果将表达式换为:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &gt; 3;//true
        boolean result = b &amp;&amp; (5 / 0 &gt; 0);//注意这里b为true
        System.out.println(result);//报错
    &#125;
&#125;
</code></pre>
<p>同理，如果将<code>&amp;&amp;</code>换为<code>||</code>,则结果为<code>true</code>，原因是<code>||</code>运算符中只要有一个结果为<code>true</code>，则整体结果为<code>true</code></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &gt; 3;//true
        boolean result = b || (5 / 0 &gt; 0);//注意这里b为true
        System.out.println(result);//true
    &#125;
&#125;
</code></pre>
<p><strong>三元运算符</strong></p>
<p>三元运算符也叫三目运算符，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = -100;
        int x = n &gt;= 0 ? n : -n;//三元运算
        System.out.println(x);//100
    &#125;
&#125;
</code></pre>
<p>上述语句的意思是，判断<code>n &gt;= 0</code>是否成立，如果为<code>true</code>，则返回<code>n</code>，否则返回<code>-n</code>。这实际上是一个求绝对值的表达式。</p>
<p>注意到三元运算<code>b ? x : y</code>会首先计算<code>b</code>，如果<code>b</code>为<code>true</code>，则只计算<code>x</code>，否则，只计算<code>y</code>。此外，<code>x</code>和<code>y</code>的类型必须相同，因为返回值不是<code>boolean</code>，而是<code>x</code>和<code>y</code>之一。</p>
<p>如果对三元运算没有掌握的话，做一个小练习：输入一个年龄，如果年龄在6-12岁，屏幕打印该生是小学生，否则打印该生不是。</p>
<pre><code class="java">public class Test&#123;
    public static void main(String[] args)&#123;
        System.out.print(&quot;请输入该生年龄：&quot;);
        int age = new Scanner(System.in).nextInt();
        int flag = age &gt;= 6 &amp;&amp; age &lt;=12 ? 1 : 0;
        switch (flag)&#123;
            case 1:
                System.out.print(&quot;该生是小学生&quot;);
                break;
            case 0:
                System.out.print(&quot;该生不是小学生&quot;);
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210911170633085.png" alt="image-20210911170633085"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210911170651064.png" alt="image-20210911170651064"></p>
<p>关于这道练习题，还有更加简单的方法来实现，不妨开动你们聪明的大脑来实现吧！</p>
<h4 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h4><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>首先明确一点：在Java中，字符和字符串是两个不同的类型。</p>
<p>字符类型<code>char</code>是基本数据类型，它是<code>character</code>的缩写。一个<code>char</code>保存一个Unicode字符：</p>
<pre><code class="java">char c1 = &#39;A&#39;;
char c2 = &#39;中&#39;;
</code></pre>
<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p>
<pre><code class="java">int c1 = &#39;A&#39;;
int c2 = &#39;中&#39;;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210914135737352.png" alt="image-20210914135649201"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210914224444734.png" alt="image-20210914224444734"></p>
<p><code>A</code>的Unicode码是65，<code>中</code>的Unicode码是20013</p>
<p>除此之外，还可以使用”\u”+Unicode码表示一个字符：</p>
<pre><code class="java">char c1 = &quot;\u0041&quot;;
char c2 = &quot;\u4e2d&quot;;
</code></pre>
<p>在16进制表示法中，<code>0041</code>表示十进制的<code>65</code>,<code>4e2d</code>就是十进制的<code>20013</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915201328569.png"></p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>与字符类型不同的是，字符串类型String是引用类型，可存储0到任意个字符，使用<code>&quot;字符串&quot;</code>来表示字符串类型的数据：</p>
<pre><code class="java">String str = &quot;我是一个字符串！&quot;;
String str1 = new String(&quot;我是字符串2！&quot;);
</code></pre>
<p><strong>转义字符：</strong></p>
<p>字符串的表示方式使用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>来进行包裹，万一在字符串中正好有<code>&quot;</code>或者<code>&#39;</code>怎么办呢？这个时候可以使用转义字符<code>\</code>来进行操作：</p>
<pre><code class="java">String str = &quot;I\&#39;m a Student!&quot;;
</code></pre>
<p>测试一下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915202414025.png" alt="image-20210915202414025"></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915202441449.png" alt="image-20210915202441449"></p>
<p>结果显而易见！</p>
<p><strong>转义字符的分歧</strong></p>
<p>因为<code>\</code>本身就是转义字符，所以表示<code>\</code>本身时使用<code>\\</code>：</p>
<pre><code class="java">String str2 = &quot;\\&quot;;
        System.out.println(str2);
</code></pre>
<p>常见的转义字符包括：</p>
<ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<p><strong>字符串连接</strong></p>
<p>字符串的连接使用<code>+</code></p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        String str = &quot;Hello,&quot;;
        String str1 = &quot;World!&quot;;
        String str2 = str+str1;
        System.out.println(str2);
    &#125;
&#125;
</code></pre>
<p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int age = 20;
        String str = &quot;Age is &quot;;
        String str1 = str + age + &quot;years old!&quot;;
        System.out.println(str1);
    &#125;
&#125;
</code></pre>
<p><strong>多行字符串：</strong></p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        String str = &quot;I\&#39;m Ok,\n&quot;
            +&quot;Thank you!\n&quot;
            +&quot;And you?&quot;;
        System.out.println(str);
    &#125;
&#125;
</code></pre>
<p>用如上方法表示多行字符串是非常麻烦的，在Java13开始提供了一个重要特性，在表示多行字符串时使用<code>&#39;&#39;&#39; ...&#39;&#39;&#39;</code></p>
<p>举个栗子：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String str = &quot;&quot;&quot;
                   SELECT * FROM
                     users
                   WHERE id &gt; 100
                   ORDER BY name DESC
                   &quot;&quot;&quot;;
        System.out.println(str);
    &#125;
&#125;
</code></pre>
<p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：</p>
<pre><code class="java">String s = &quot;&quot;&quot; 
           SELECT * FROM
             users
           WHERE id &gt; 100
           ORDER BY name DESC&quot;&quot;&quot;;
</code></pre>
<p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p>
<pre><code class="java">String s = &quot;&quot;&quot;
...........SELECT * FROM
...........  users
...........WHERE id &gt; 100
...........ORDER BY name DESC
...........&quot;&quot;&quot;;
</code></pre>
<p>用<code>.</code>标注的空格都会被去掉。</p>
<p>如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p>
<pre><code class="java">String s = &quot;&quot;&quot;
.........  SELECT * FROM
.........    users
.........WHERE id &gt; 100
.........  ORDER BY name DESC
.........  &quot;&quot;&quot;;
</code></pre>
<p>即总是以最短的行首空格为基准。</p>
<p><strong>字符串的不可变特性</strong></p>
<pre><code class="java">public class StringTest&#123;
    public static void main(String[] args)&#123;
        String s = &#39;Hello&#39;;//打印s是Hello
        System.out.println(s);
        s = &#39;World!&#39;//打印s是World！
        System.out.println(s);
    &#125;
&#125;
</code></pre>
<p>上述代码中的<code>s</code>在重新赋值后打印结果发生了变化，是s本身的值发生了变化吗？其实并不是，只是s将结果的内存地址指向了另一个字符串。</p>
<p>执行<code>String s = &quot;Hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;Hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915210059713.png" alt="image-20210915210059713"></p>
<p>而紧接着执行<code>s = &#39;World!&#39;</code>之后,JVM虚拟机创建字符串<code>&quot;World!&quot;</code>,然后把字符串变量<code>s</code>指向它:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210915210321212.png" alt="image-20210915210321212"></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;hello&quot;;
        String t = s;
        s = &quot;world&quot;;
        System.out.println(t);
    &#125;
&#125;
</code></pre>
<p>思考上述代码,t是”hello”还是”world”?</p>
<p>答案: <code>t并没有重新赋值为s，所以t的值依旧保留为&quot;hello&quot;,如果在打印前补上一句:t = s;那么t的值便是&quot;world&quot;</code></p>
<p><strong>空值null</strong></p>
<p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p>
<pre><code class="java">String s1 = null; // s1是null
String s2; // 没有赋初值值，s2也是null
String s3 = s1; // s3也是null
String s4 = &quot;&quot;; // s4指向空字符串，不是null
</code></pre>
<p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>如果有一组相同类型的数据，可以这么表示:</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int n1 = 98;
        int n2 = 100;
        int n3 = 99;
        int n4 = 70;
        int n5 = 78;
    &#125;
&#125;
</code></pre>
<p>以上方法表示太繁琐，也太复杂，可以使用数组来表示：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        arr[0] = 98;
        arr[1] = 100;
        arr[2] = 99;
        arr[3] = 70;
        arr[4] = 78;
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，<code>int[]</code>。和单个基本类型变量不同，数组变量初始化必须使用<code>new int[5]</code>表示创建一个可容纳5个<code>int</code>元素的数组。</p>
<p>Java的数组有几个特点：</p>
<ul>
<li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li>
<li>数组一旦创建后，大小就不可改变。</li>
</ul>
<p>要访问数组中的某一个元素，需要使用索引。数组索引从<code>0</code>开始，例如，5个元素的数组，索引范围是<code>0</code>~&#96;4&#96;。</p>
<p>可以修改数组中的某一个元素，使用赋值语句，例如，<code>arr[1] = 79;</code>。</p>
<p>可以用<code>数组变量.length</code>获取数组大小：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        arr[0] = 98;
        arr[1] = 100;
        arr[2] = 99;
        arr[3] = 70;
        arr[4] = 78;
        System.out.println(arr.length);//5
    &#125;
&#125;
</code></pre>
<p>除此之外，数组还有一种简单的创建方式：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;90,78,100,99,98&#125;;
        System.out.println(arr.length);//5
    &#125;
&#125;
</code></pre>
<p>这种创建方式最大的优点就是不用指定数组大小，编译器可以直接推算出数组大小</p>
<p>数组是<strong>引用类型</strong>，在使用索引访问数组元素时，如果索引超出范围，运行时将报错：</p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = new int[5];
        int n = 5;
        System.out.println(arr[n]); // 索引n不能超出范围
    &#125;
&#125;
</code></pre>
<p><strong>数组是引用类型且大小不可变</strong></p>
<pre><code class="java">public class ArrayTest&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1,2,3,4,5&#125;;
        System.out.println(Arrays.toString(arr));//1,2,3,4,5
        arr = new int[]&#123;1,2,3&#125;;
        System.out.println(Arrays.toString(arr));//1,2,3
    &#125;
&#125;
</code></pre>
<p>与String同理，arr指向{1,2,3,4,5}的内存地址，在执行<code>arr = new int[]&#123;1,2,3&#125;;</code>这句代码之后，arr指向{1,2,3}这组数的内存地址。</p>
<p>原有5个数的数组没有改变，只是无法使用变量arr来引用它们。</p>
<p><strong>字符串数组</strong></p>
<pre><code class="java">public class StringArrayTest&#123;
    public static void main(String[] args)&#123;
        String[] names = &#123;&quot;Tom&quot;,&quot;Alice&quot;,&quot;Jack&quot;,&quot;James&quot;&#125;;
        System.out.println(Arrays.toString(names));
        names[0] = &quot;Bob&quot;;
        System.out.println(Arrays.toString(names));
    &#125;
&#125;
</code></pre>
<p>在以上代码中，<code>String[] names = &#123;&quot;Tom&quot;,&quot;Alice&quot;,&quot;Jack&quot;,&quot;James&quot;&#125;;</code>定义了一个String类型有四位元素的数组，在执行完<code>names[1] = &quot;Bob&quot;;</code>这句代码后，<code>Tom</code>就会被替换成<code>Bob</code></p>
<p>这并不是names指向了一个新的数组{“Bob”,”Alice”,”Jack”,”James”},而是names的元素names[0]指向了一个新的值”Bob”,在数组中每个值的指向都是独立的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916154445754.png" alt="image-20210916154445754"></p>
<h2 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h2><p>在Java程序中，JVM默认总是顺序执行以分号<code>;</code>结束的语句。但是，在实际的代码中，程序经常需要做条件判断、循环，因此，需要有多种流程控制语句，来实现程序的跳转和循环等功能。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>在使用流程控制之前，先学习输入输出：</p>
<p><strong>输出：</strong></p>
<p>在前面的代码中，我们总是使用<code>System.out.println()</code>来向屏幕输出一些内容。</p>
<p><code>println</code>是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用<code>print()</code>：</p>
<pre><code class="java">public class InOrOutTest&#123;
    public static void main(String[] args)&#123;
        System.out.print(&quot;A,&quot;);
        System.out.print(&quot;B,&quot;);
        System.out.print(&quot;C.&quot;);
        System.out.println();
        System.out.println(&quot;This line is next&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>格式化输出：</strong></p>
<p>Java还提供了格式化输出，因为适合电脑阅读的内容不一定适合我们人类：</p>
<pre><code class="java">public class FormatOut&#123;
    public static void main(String[] args)&#123;
        double d = 1270000000;
        System.out.println(d);//1.27e9
    &#125;
&#125;
</code></pre>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式：</p>
<pre><code class="java">public class FormatOut &#123;
    public static void main(String[] args) &#123;
        double d = 3.1415926;
        System.out.printf(&quot;%.2f\n&quot;, d); // 显示两位小数3.14
        System.out.printf(&quot;%.4f\n&quot;, d); // 显示4位小数3.1416
    &#125;
&#125;
</code></pre>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>格式化输出整数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化输出十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
</tbody></table>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p>
<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>
<pre><code class="java">public class FormatOut &#123;
    public static void main(String[] args) &#123;
        int n = 12345000;
        System.out.printf(&quot;n=%d, hex=%08x&quot;, n, n); // 注意，两个%占位符必须传入两个数
    &#125;
&#125;
</code></pre>
<p>运行结果:</p>
<p><img src="/./Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0.assets/image-20210916161022033.png" alt="image-20210916161022033"></p>
<p><strong>输入：</strong></p>
<p>输入使用的是Scanner，首先看一下比输出复杂的输入如何实现:</p>
<pre><code class="java">public class ScannerTest&#123;
    public static void main(String[] args)&#123;
        Scanner in = new Scanner(System.in);
        System.out.print(&quot;请输入一个数：&quot;);
        int num = in.nextInt();
        if(num % 2 == 0)&#123;
            System.out.println(num + &quot;是一个偶数！&quot;);
        &#125;else&#123;
            System.out.println(num + &quot;是一个奇数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过<code>import</code>语句导入<code>java.util.Scanner</code>，<code>import</code>是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的<code>package</code>中会详细讲解如何使用<code>import</code>。</p>
<p>然后，创建<code>Scanner</code>对象并传入<code>System.in</code>。<code>System.out</code>代表标准输出流，而<code>System.in</code>代表标准输入流。直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码。</p>
<p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</p>
<h3 id="if控制语句"><a href="#if控制语句" class="headerlink" title="if控制语句"></a>if控制语句</h3><p><strong>基本语法：</strong></p>
<pre><code class="java">if(boolean)&#123;
    //true
&#125;
</code></pre>
<p>if关键字后面的括号是一个条件且为布尔类型，可以使用诸如： <code>i == 2</code> <code>x + y == 2</code>等等</p>
<p>如果括号内条件为真则执行花括号里的代码块</p>
<pre><code class="java">public class IfTest&#123;
    public static void main(String[] args)&#123;
        int i = 2;
        if(i == 2)&#123;
            System.out.print(&quot;i结果为2！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>if嵌套：</strong></p>
<p>if可以嵌套else继续使用，假设有一个条件但是有两种结果，那你怎么去执行第二种结果呢？再写一个if吗？显然是不可能的。</p>
<pre><code class="java">public class IfTest&#123;
    public static void main(String[] args)&#123;
        int i = 1;
        if(i == 2)&#123;
            System.out.print(&quot;i结果为2！&quot;);
        &#125;else&#123;
            System.out.print(&quot;i结果不为2！&quot;);//被执行
        &#125;
    &#125;
&#125;
</code></pre>
<p>除此之外，还可以在else后面加上if：</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;请输入1-3的整数:&quot;);
        Scanner in = new Scanner(System.in);
        int i = in.nextInt();
        if(i == 1) &#123;
            System.out.println(&quot;i为1！&quot;);
        &#125;else if(i == 2) &#123;
            System.out.println(&quot;i为2！&quot;);
        &#125;else if(i == 3) &#123;
            System.out.println(&quot;i为3！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>使用if判断引用类型对象相等：</strong></p>
<p>&lt;1&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = &quot;HELLO&quot;;
        String str2 = &quot;hello&quot;.toUpperCase();
        if(str==str2) &#123;
            System.out.println(&quot;str == str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str != str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>&lt;2&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = &quot;HELLO&quot;;
        String str2 = &quot;hello&quot;.toUpperCase();
        if(str.equals(str2)) &#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>&lt;3&gt;</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = null;
        String str2 = &quot;HELLO&quot;;
        if(str.equals(str2)) &#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else &#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>在引用类型对象比较中， &#x3D;&#x3D; 用来表示两个变量的引用地址是否一致，很显然在代码1中，“HELLO” 和 “hello”.toUpperCase()值是一致的，都是”HELLO”,但内存地址就是不同，所以结果只能是 str !&#x3D; str2   在代码2中，由于使用了equals运算符进行比较，它只会比较两个值是否相等，很显然两个值是相等的，所以结果必然是 str equals str2  在代码3中，str &#x3D; null,它指向一个空地址，所以会报错：java.lang.NullPointException</strong></p>
<h4 id="和-equals的区别及应用场景"><a href="#和-equals的区别及应用场景" class="headerlink" title="&#x3D;&#x3D; 和 equals的区别及应用场景"></a>&#x3D;&#x3D; 和 equals的区别及应用场景</h4><p>​		&lt;1&gt;对于&#x3D;&#x3D;，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<p>　　&lt;2&gt;对于equals方法，注意：<strong>equals方法不能作用于基本数据类型的变量</strong></p>
<p>　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。</p>
<p>　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
<p>要避免<strong>java.lang.NullPointException</strong>错误，可以使用**&amp;&amp;**运算符来避免：</p>
<pre><code class="java">public class IfTest &#123;
    public static void main(String[] args) &#123;
        String str = null;
        String str2 = &quot;Hello&quot;;
        if(str != null &amp;&amp; str.equals(str2))&#123;
            System.out.println(&quot;str equals str2&quot;);
        &#125;else&#123;
            System.out.println(&quot;str !equals str2&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<p>运行结果:</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916201148893.png" alt="image-20210916201148893">	</p>
<p><strong>小结：</strong></p>
<p><code>if ... else</code>可以做条件判断，<code>else</code>是可选的；</p>
<p>不推荐省略花括号<code>&#123;&#125;</code>；</p>
<p>多个<code>if ... else</code>串联要特别注意判断顺序；</p>
<p>要注意<code>if</code>的边界条件；</p>
<p>要注意浮点数判断相等不能直接用<code>==</code>运算符；</p>
<p>引用类型判断内容相等要使用<code>equals()</code>，注意避免<code>NullPointerException</code>。</p>
<h3 id="switch控制语句"><a href="#switch控制语句" class="headerlink" title="switch控制语句"></a>switch控制语句</h3><p>除if之外还有一种表达式可以根据条件执行不同分支：switch</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果<code>option</code>的值没有匹配到任何<code>case</code>，例如<code>option = 99</code>，那么，<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code>：</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果把<code>switch</code>语句翻译成<code>if</code>语句，那么上述的代码相当于：</p>
<pre><code class="java">if (option == 1) &#123;
    System.out.println(&quot;已进入单人模式&quot;);
&#125; else if (option == 2) &#123;
    System.out.println(&quot;已进入双人模式&quot;);
&#125; else if (option == 3) &#123;
    System.out.println(&quot;已进入练习模式&quot;);
&#125; else &#123;
    System.out.println(&quot;No selected&quot;);
&#125;
</code></pre>
<p>对于多个<code>==</code>判断的情况，使用<code>switch</code>结构更加清晰。</p>
<p>同时注意，上述“翻译”只有在<code>switch</code>语句中对每个<code>case</code>正确编写了<code>break</code>语句才能对应得上。</p>
<p>使用<code>switch</code>时，注意<code>case</code>语句并没有花括号<code>&#123;&#125;</code>，而且，<code>case</code>语句具有“<em>穿透性</em>”，<strong>漏写<code>break</code>将导致意想不到的结果。</strong></p>
<p><strong>使用<code>switch</code>语句时，只要保证有<code>break</code>，<code>case</code>的顺序不影响程序逻辑：</strong></p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1.单人模式\n&quot;
        +&quot;2.双人模式\n&quot;
        +&quot;3.练习模式\n&quot;);
        System.out.print(&quot;请输入游戏模式:&quot;);
        int option = new Scanner(System.in).nextInt();
        switch (option)&#123;
            case 3:
                System.out.println(&quot;已进入练习模式&quot;);
            break;
            case 1:
                System.out.println(&quot;已进入单人模式&quot;);
            break;
            case 2:
                System.out.println(&quot;已进入双人模式&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>switch</code>语句还可以匹配<strong>字符串</strong>。字符串匹配时，是比较“内容相等”。例如：</p>
<pre><code class="java">public class SwitchTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;apple\n&quot;
        +&quot;orange\n&quot;
        +&quot;3.banana\n&quot;);
        System.out.print(&quot;请输入想吃的水果:&quot;);
        String option = new Scanner(System.in).nextLine();
        switch (option)&#123;
            case &quot;apple&quot;:
                System.out.println(&quot;您选择吃苹果！&quot;);
            break;
            case &quot;orange&quot;:
                System.out.println(&quot;您选择吃橘子！&quot;);
            break;
            case &quot;banana&quot;:
                System.out.println(&quot;您选择吃香蕉！&quot;);
            break;
            default:
                System.out.println(&quot;No selected&quot;);
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>编译检查</strong></p>
<p>使用IDE时，可以自动检查是否漏写了<code>break</code>语句和<code>default</code>语句，方法是打开IDE的编译检查。</p>
<p>在Eclipse中，选择<code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code>，将以下检查标记为Warning：</p>
<ul>
<li>‘switch’ is missing ‘default’ case</li>
<li>‘switch’ case fall-through</li>
</ul>
<p>在IDEA中，选择<code>File </code>- <code>Settings</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code>，将以下检查标记为Warning：</p>
<ul>
<li>Fallthrough in ‘switch’ statement</li>
<li>‘switch’ statement without ‘default’ branch</li>
</ul>
<p>当<code>switch</code>语句存在问题时，即可在IDE中获得警告提示。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210916205937679.png" alt="image-20210916205937679"></p>
<h4 id="Java12中的switch新特性"><a href="#Java12中的switch新特性" class="headerlink" title="Java12中的switch新特性"></a>Java12中的switch新特性</h4><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String fruit = new Scanner(System.in).nextLine();
        switch (fruit) &#123;
        case &quot;apple&quot; -&gt; System.out.println(&quot;Selected apple&quot;);
        case &quot;pear&quot; -&gt; System.out.println(&quot;Selected pear&quot;);
        case &quot;mango&quot; -&gt; &#123;
            System.out.println(&quot;Selected mango&quot;);
            System.out.println(&quot;Good choice!&quot;);
        &#125;
        default -&gt; System.out.println(&quot;No fruit selected&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h3><p> while的基本语法：</p>
<pre><code class="java">while (条件)&#123;
    //语句块
&#125;
</code></pre>
<p>while就是括号内的条件为真时，执行语句块的内容，然后返回while，再次判断条件，为真则继续执行，为假则退出。while的最小执行次数为0，因为while需要先判断条件再执行。</p>
<p>例如计算1-100的和：</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        int i = 1;
        int sum = 0;
        while(i &lt;= 100)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(&quot;1-100的和为:&quot;+sum);
    &#125;
&#125;
</code></pre>
<p>这里的条件就是i &lt;&#x3D; 100，如果i &gt; 100,则循环结束</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>如果while的条件一直为真，那么语句块的代码会一直执行下去，这种情况就会造成死循环:</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        while (true)&#123;
            System.out.println(&quot;死循环！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。</p>
<p>还有另一种情况，可能会执行很多次，但最终由于逻辑错误，还是会退出while:</p>
<pre><code class="java">public class WhileTest &#123;
    public static void main(String[] args) &#123;
        int i,sum;
        i = 1;
        sum = 0;
        while (i &gt; 0)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(sum);
    &#125;
&#125;
</code></pre>
<p>表面上看这貌似也是个死循环，因为i怎么都大于0，但是当i超过整型的最大值后，便会返回一个负数，这个时候while就会退出；</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>while</code>循环先判断循环条件是否满足，再执行循环语句；</p>
<p><code>while</code>循环可能一次都不执行；</p>
<p>编写循环时要注意循环条件，并避免死循环。</p>
<h3 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do while循环控制"></a>do while循环控制</h3><p>do while与while不同的是，do while 需要先执行一次语句，再判断条件，所以do while最小执行次数为1</p>
<p>基本语法：</p>
<pre><code class="java">do &#123;
    //代码块
&#125;while (条件);
</code></pre>
<p>使用do while改写1-100的和:</p>
<pre><code class="java">public class DoWhileTest &#123;
    public static void main(String[] args) &#123;
        int i = 1,sum = 0;
        do &#123;
            sum += i;
            i++;
        &#125;while(i &lt;= 100);
        System.out.println(&quot;1-100的和:&quot;+sum);
    &#125;
&#125;
</code></pre>
<h3 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h3><p><code>for</code>循环的功能非常强大，它使用计数器实现循环。<code>for</code>循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为<code>i</code>。</p>
<p>我们把1到100求和用<code>for</code>循环改写一下：</p>
<pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int sum = 0;
        for (int i = 0; i &lt;= 100 ; i++) &#123;
            sum += i;
        &#125;
        System.out.println(&quot;1-100的和：&quot;+sum);
    &#125;
&#125;
</code></pre>
<h4 id="for循环基本语法"><a href="#for循环基本语法" class="headerlink" title="for循环基本语法:"></a>for循环基本语法:</h4><pre><code class="java">for (计数器;计数区间;计数器自增/自减)&#123;
    //代码块
&#125;
</code></pre>
<h4 id="for循环遍历数组"><a href="#for循环遍历数组" class="headerlink" title="for循环遍历数组"></a>for循环遍历数组</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;100,120,135,150,93,97&#125;;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="打印乘法表"><a href="#打印乘法表" class="headerlink" title="打印乘法表"></a>打印乘法表</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 9 ; i++) &#123;
            for (int j = 1; j &lt;= i; j++) &#123;
                System.out.print(j + &quot;x&quot; + i + &quot;=&quot; + j*i + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="使用全局变量定义for"><a href="#使用全局变量定义for" class="headerlink" title="使用全局变量定义for"></a>使用全局变量定义for</h4><pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int i,j;
        for (i = 1; i &lt;= 9 ; i++) &#123;
            for (j = 1; j &lt;= i; j++) &#123;
                System.out.print(j + &quot;x&quot; + i + &quot;=&quot; + j*i + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        i = 10;//i和j在经过for循环后还可以继续使用
        j = 20;
        System.out.println(i + &quot; &quot; + j);
    &#125;
&#125;
</code></pre>
<h4 id="灵活使用for循环"><a href="#灵活使用for循环" class="headerlink" title="灵活使用for循环"></a>灵活使用for循环</h4><p><code>for</code>循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：</p>
<pre><code>// 不设置结束条件:
for (int i=0; ; i++) &#123;
    ...
&#125;
// 不设置结束条件和更新语句:
for (int i=0; ;) &#123;
    ...
&#125;
// 什么都不设置:
for (;;) &#123;
    ...
&#125;
</code></pre>
<p>通常不推荐这样写，但是，某些情况下，是可以省略<code>for</code>循环的某些语句的。</p>
<h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>上面使用for循环遍历数组，使用数组下标访问数组的每一个元素，其实还有更简单的办法就是使用for each循环:</p>
<pre><code class="java">public class ForTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6&#125;;
        for (int num : arr)&#123;
            System.out.print(num + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>for each条件中间使用 <code>:</code>分割，左边是遍历容器中元素的类型变量，右边就是容器名，比如上面的数组，全都是整型元素，那么用来接收值额变量num也应该是整型</p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break:跳出循环，结束代码块；</p>
<p>continue:跳过此次循环，开始执行下次循环</p>
<p>这两句总结可能不会很简明，我们举个栗子：</p>
<p>需求:计算1-100内所有<strong>偶数</strong>的和：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args)&#123;
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++)&#123;
            if (i % 2 == 0)&#123;
                sum += i;
            &#125;else&#123;
                continue;
            &#125;
        &#125;
        System.out.print(&quot;1-100偶数和:&quot;+sum);
    &#125;
&#125;
</code></pre>
<p>需求：在for循环的计数器加到100时，结束该循环</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args)&#123;
        for (int i = 0; ; i++)&#123;
            if(i == 100)&#123;
                break;
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h4><p><code>break</code>语句可以跳出当前循环；</p>
<p><code>break</code>语句通常配合<code>if</code>，在满足条件时提前结束整个循环；</p>
<p><code>break</code>语句总是跳出最近的一层循环；</p>
<p><code>continue</code>语句可以提前结束本次循环；</p>
<p><code>continue</code>语句通常配合<code>if</code>，在满足条件时提前结束本次循环。</p>
<p><code>break和continue</code>不仅局限于for或while，可以使用于很多场景。</p>
<h2 id="Java数组操作"><a href="#Java数组操作" class="headerlink" title="Java数组操作"></a>Java数组操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i]+&quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for each遍历"></a>for each遍历</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        for (int num: arr) &#123;
            System.out.print(num + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="Arrays-toString-遍历"><a href="#Arrays-toString-遍历" class="headerlink" title="Arrays.toString()遍历"></a>Arrays.toString()遍历</h4><p>Arrays.toString()是Java提供的一个遍历数组的函数，如不使用它，直接打印数组就会打印数组的内存地址:</p>
<pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<h4 id="直接打印的效果"><a href="#直接打印的效果" class="headerlink" title="直接打印的效果:"></a>直接打印的效果:</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;99,98,97,96,95&#125;;
        System.out.println(arr);//[I@1540e19d
    &#125;
&#125;
</code></pre>
<p>这样就会直接打印出内存地址:[I@1540e19d</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;37,66,95,41,25,10,21&#125;;
        //排序前：
        System.out.println(&quot;排序前：&quot;+Arrays.toString(arr));
        //排序后:
        for (int i = 0; i &lt; arr.length -1; i++) &#123;
            for (int j = 0; j &lt; arr.length -i -1; j++) &#123;
                if (arr[j] &gt; arr[j+1])&#123;
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;排序后：&quot;+Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p>
<p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p>
<pre><code class="java">int x = 1;
int y = 2;

x = y; // x现在是2
y = x; // y现在还是2
</code></pre>
<p>正确的写法是：</p>
<pre><code class="java">int x = 1;
int y = 2;

int t = x; // 把x的值保存在临时变量t中, t现在是1
x = y; // x现在是2
y = t; // y现在是t的值1
</code></pre>
<h4 id="Java内置数组排序"><a href="#Java内置数组排序" class="headerlink" title="Java内置数组排序"></a>Java内置数组排序</h4><p>Java内置数组排序的方法为:<code>Arrays.sort();</code></p>
<pre><code class="java">public class ArrayTest &#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;37,66,95,41,25,10,21&#125;;
        System.out.println(&quot;排序前:&quot;);
        System.out.println(Arrays.toString(arr));
        System.out.println(&quot;排序后:&quot;);
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>定义:</p>
<pre><code class="java">int[][] num = &#123;
    &#123;1,2,3,4&#125;,
    &#123;5,6,7,8&#125;,
    &#123;9,10,11,12&#125;,
    &#123;13,14,15,16&#125;
&#125;;
</code></pre>
<p>其次，二位数组对每个数组元素的长度也没有限制：</p>
<pre><code class="java">int[][] num = &#123;
    &#123;1,2,3&#125;,
    &#123;1,2&#125;,
    &#123;4,5,6,7,8&#125;
&#125;;
</code></pre>
<h4 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a>二维数组遍历</h4><p>fori:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        for(int i = 0;i&lt;nums.length;i++)&#123;
            for(int j = 0;j&lt;nums[i].length;j++)&#123;
                System.out.print(nums[i][j]+&quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>foreach:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        for(int[] num : nums)&#123;
            for (int i : num)&#123;
                System.out.print(i + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>deepToString:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] nums = &#123;
                &#123;1,2,3&#125;,
                &#123;2,4&#125;,
                &#123;2,4,6,8&#125;
        &#125;;
        System.out.print(Arrays.deepToString(nums));
    &#125;
&#125;
</code></pre>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>下面二位数组代表几位同学的各科成绩，请计算各位同学的平均分：</p>
<pre><code class="java">int[][] scores = &#123;
                &#123; 82, 90, 91 &#125;,
                &#123; 68, 72, 64 &#125;,
                &#123; 95, 91, 89 &#125;,
                &#123; 67, 52, 60 &#125;,
                &#123; 79, 81, 85 &#125;,
        &#125;;
</code></pre>
<p>答案：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] scores = &#123;
                &#123; 82, 90, 91 &#125;,
                &#123; 68, 72, 64 &#125;,
                &#123; 95, 91, 89 &#125;,
                &#123; 67, 52, 60 &#125;,
                &#123; 79, 81, 85 &#125;,
        &#125;;

        for(int[] num : scores)&#123;
            int plus = 0;
            double average = 0;
            int count = 0;
            for(int i = 0;i&lt;num.length;i++)&#123;
                plus += num[i];
                average = plus / 3;
            &#125;
            count += 1;
            System.out.println(&quot;第&quot;+count+&quot;名同学的平均分是:&quot;+average+&quot;分！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="面向对象概念："><a href="#面向对象概念：" class="headerlink" title="面向对象概念："></a>面向对象概念：</h3><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p>
<p>那什么是面向对象编程？</p>
<p>顾名思义，面向对象，你得首先有个对象，在Java中有一个名词叫做”万物皆对象”</p>
<p>比如可以拿Java来表示女朋友:</p>
<pre><code class="java">public class GirlFriend&#123;
    int id;//身份证号
    String name;//姓名
    String[] hobby;//兴趣爱好
    String post;//地址
&#125;
</code></pre>
<p>那么如何让你女朋友的信息打印出来呢？</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        GirlFriend girlFriend = new GirlFriend();//对象实例化
        girlFriend.id = 620521200001011121L;
        girlFriend.name = &quot;女朋友&quot;;
        girlFriend.hobby = new String[]&#123;&quot;琴&quot;, &quot;棋&quot;, &quot;书&quot;, &quot;画&quot;&#125;;
        girlFriend.post = &quot;地球-中国-甘肃&quot;;
        System.out.println(girlFriend.id);
        System.out.println(girlFriend.name);
        System.out.println(Arrays.toString(girlFriend.hobby));
        System.out.println(girlFriend.post);
    &#125;
&#125;
</code></pre>
<p>因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p>
<p>在本章中，我们将讨论：</p>
<p>面向对象的基本概念，包括：</p>
<ul>
<li>类</li>
<li>实例</li>
<li>方法</li>
</ul>
<p>面向对象的实现方式，包括：</p>
<ul>
<li>继承</li>
<li>多态</li>
</ul>
<p>Java语言本身提供的机制，包括：</p>
<ul>
<li>package</li>
<li>classpath</li>
<li>jar</li>
</ul>
<p>以及Java标准库提供的核心类，包括：</p>
<ul>
<li>字符串</li>
<li>包装类型</li>
<li>JavaBean</li>
<li>枚举</li>
<li>常用工具类</li>
</ul>
<p>通过本章的学习，完全可以理解并掌握面向对象的基本思想，但不保证能找到对象。</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211007171101932.png" alt="image-20211007171101932"></p>
<h3 id="面向对象基础："><a href="#面向对象基础：" class="headerlink" title="面向对象基础："></a>面向对象基础：</h3><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p>
<table>
<thead>
<tr>
<th align="left">现实世界</th>
<th align="left">计算机模型</th>
<th align="left">Java代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">人</td>
<td align="left">类 &#x2F; class</td>
<td align="left">class Person { }</td>
</tr>
<tr>
<td align="left">小明</td>
<td align="left">实例 &#x2F; ming</td>
<td align="left">Person ming &#x3D; new Person()</td>
</tr>
<tr>
<td align="left">小红</td>
<td align="left">实例 &#x2F; hong</td>
<td align="left">Person hong &#x3D; new Person()</td>
</tr>
<tr>
<td align="left">小军</td>
<td align="left">实例 &#x2F; jun</td>
<td align="left">Person jun &#x3D; new Person()</td>
</tr>
</tbody></table>
<p>面向对象主要搞清class和instance的概念，class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型。</p>
<p>instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同。</p>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><pre><code class="java">class Person&#123;
    String name;
    int age;
&#125;
</code></pre>
<p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><pre><code class="java">Person ming = new Person();
</code></pre>
<p>如上所示代码创建一个Person实例: <code>Person ming</code>是一个Person类型的变量，<code>new Person()</code>是创建一个Person类型的实例，通过变量ming即可对这个实例进行操作，也就是跟对象交流：</p>
<h4 id="操作对象实例"><a href="#操作对象实例" class="headerlink" title="操作对象实例"></a>操作对象实例</h4><pre><code class="java">ming.name = &quot;小明&quot;;
ming.age = 20;
</code></pre>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p> 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p>
<pre><code class="java">public class Main&#123;
    Person ming = new Person();//Person实例1
    Person hong = new Person();//Person实例2
    Book book1 = new Book();//Book实例1
    Book book2 = new Book();//Book实例2
    ming.name = &quot;小明&quot;;
    ming.age = 20;
    hong.name = &quot;小红&quot;;
    hong.age = 19;
    book1.bookName = &quot;Java编程思想&quot;;
    book1.author = &quot;Bruce Eckel&quot;;
    book1.price = 80.2;
    book2.bookName = &quot;C++编程思想&quot;;
    book2.author = &quot;Bruce Eckel&quot;;
    book2.price = 90.8;
&#125;
class Person&#123;
    String name;
    int age;
&#125;
class Book&#123;
    String bookName;
    String author;
    double price;
&#125;
</code></pre>
<p>上面两个类各自<strong>分别</strong>创建了两个实例，每个类的每一个实例有自己<strong>独立的数据，互不干扰</strong>。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p>
<p>定义<code>class</code>就是定义了一种数据类型，对应的<code>instance</code>是这种数据类型的实例；</p>
<p><code>class</code>定义的<code>field</code>，在每个<code>instance</code>都会拥有各自的<code>field</code>，且互不干扰；</p>
<p>通过<code>new</code>操作符创建新的<code>instance</code>，然后用变量指向它，即可通过变量来引用这个<code>instance</code>；</p>
<p>访问实例字段的方法是<code>变量名.字段名</code>；</p>
<p>指向<code>instance</code>的变量都是引用变量。</p>
<h4 id="方法-函数"><a href="#方法-函数" class="headerlink" title="方法&#x2F;函数"></a>方法&#x2F;函数</h4><p>在<code>class</code>中，不仅仅可以定义<code>field(字段)</code>，还可以定义<code>方法、函数（function）</code></p>
<p>不同的人对方法的叫法不同，也有人会称之为函数：</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;//main方法/函数，程序入口
        
    &#125;
&#125;
</code></pre>
<p>我们给Person类定义方法:</p>
<pre><code class="java">class Person&#123;
    String name;
    int age;
    public void eat()&#123;
        System.out.print(&quot;吃了！&quot;);
    &#125;
&#125;
</code></pre>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person ming = new Person();
        ming.eat();
    &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>在定义方法时，有修饰符可选，<code>public</code>,<code>private</code>,<code>protected</code>,不同修饰符对应不同的调用权限:<strong>public</strong> void fun(){}</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>相同包</th>
<th>不同包</th>
<th>子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>private</td>
<td>可访问</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>protected</td>
<td>可访问</td>
<td>可访问</td>
<td>不可访问</td>
<td>可访问</td>
</tr>
</tbody></table>
<h5 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h5><p>返回值类型就是类似<code>void</code>,<code>int</code>,<code>String</code>,<code>char</code>这种数据类型：public <strong>void</strong> fun(){}</p>
<p>除void外，其他类型均需使用return返回相同数据类型的数据，这个数据可以是变量，也可以是常量：</p>
<pre><code class="java">public class Main&#123;
    public void eat()&#123;
        System.out.print(&quot;吃了！&quot;);
    &#125;
    public int drink()&#123;
        System.out.print(&quot;喝了！&quot;);
        return 1;
    &#125;
    public String sleep()&#123;
        System.out.print(&quot;睡了！&quot;);
        return &quot;晚安&quot;;
    &#125;
    ...
&#125;
</code></pre>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法就是带<code>static</code>的方法，这种方法甚至可以被<strong>类名直接调用</strong>，也可以被非静态方法调用，但是静态方法无法调用非静态方法</p>
<pre><code class="java">public class StaticTest &#123;
    static String name = &quot;Name&quot;;//静态field
    String str = &quot;Str&quot;;//非静态field
    public void eat()&#123;
        System.out.println(&quot;吃了！&quot;);
        drink();//非静态调用静态
    &#125;
    public static void drink()&#123;
        System.out.println(&quot;喝了！&quot;);
        System.out.println(name);//调用静态变量就没事
        //eat();//调用非静态方法就会报错
        //System.out.println(str);//调用非静态变量也会报错
    &#125;

    public static void main(String[] args) &#123;
        drink();//main方法也是静态方法，可以直接调用静态方法（使用StaticTest.drink();也可以）
        //要调用非静态方法，必须对象实例化
        StaticTest staticTest = new StaticTest();
        staticTest.eat();
        System.out.println(staticTest.str);
    &#125;
&#125;
</code></pre>
<p>仔细体会如上代码。</p>
<h5 id="this变量"><a href="#this变量" class="headerlink" title="this变量"></a>this变量</h5><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向<strong>当前实例</strong>。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>
<p>如果没有命名冲突，可以省略<code>this</code>。例如：</p>
<pre><code class="java">class Person&#123;
    String name;
    public String getName()&#123;
        return name;//相当于this.name
    &#125;
&#125;
</code></pre>
<p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>
<pre><code class="java">class Person&#123;
    String name;
    public void setName(String name)&#123;
        this.name = name;//注意，这里的this.name是类的字段，而单独的name是局部变量，局部变量指的是方法参数
    &#125;
&#125;
</code></pre>
<h5 id="带参函数"><a href="#带参函数" class="headerlink" title="带参函数"></a>带参函数</h5><p>定义方法时，方法后面总有一个括号，可能经常能看到这类函数:</p>
<pre><code class="java">public class Person&#123;
    int age;
    String name;
    String[] hobby;
    Long identity;
    public void setAttribute(int age,String name,String[] hobby,Long identity)&#123;
       this.age = age;
       this.name = name;
       this.hobby = hobby;
       this.identity = indentity;
    &#125; 
&#125;
</code></pre>
<p>这种函数在定义时后面的括号中总会有参数，这些参数在方法被调用时必须赋值，而且在赋值时必须顺序一致，也就是数据类型必须一一对应:</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person person = new Person();
        person.setAttribute(20,&quot;小昕&quot;,&#123;&quot;编程&quot;,&quot;社工&quot;,&quot;渗透&quot;&#125;,620521200101010101L);//这里传进去的值顺序不可以乱
    &#125;
&#125;
</code></pre>
<p>如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>
<p>上面Person类<code>setAttrubite()</code>函数后面的参数跟类中的字段一样，所以函数括号内的参数优先级更高。</p>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><h6 id="可变参数定义"><a href="#可变参数定义" class="headerlink" title="可变参数定义"></a>可变参数定义</h6><p>定义可变参数使用<code>数据类型...</code>来进行定义，可变参数相当于数组:</p>
<pre><code class="java">public class FunctionChangeAttribute&#123;
    private String[] names;
    public void setAttrubite(String...names)&#123;
        this.names = names;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        FunctionChangeAttribute f = new FunctionChangeAttribute();
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;,&quot;itio&quot;);//四个值
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;);//两个值
        f.setAttrubite(&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;);//三个值
        f.setAttrubite();//空值
    &#125;
&#125;
</code></pre>
<p>上面调用方法时，<code>&quot;xcc&quot;,&quot;ycc&quot;,&quot;xccit&quot;,&quot;itio&quot;</code>等便是传进去的实参，且连续调用方法3次，每次传进不一样的值</p>
<p>其实<code>String... names</code>完全可以改写成<code>String[] names</code>，但这样做的话，你不想给方法传参数便会报错，例如:</p>
<p><code>FunctionChangeAttribute.java</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211014203551375.png" alt="image-20211014203551375"></p>
<p><code>Main.java</code></p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211014203642388.png" alt="image-20211014203642388"></p>
<p>这就是一个缺点，另外在调用时必须手动<code>new String[]</code>,而且可以传入一个<code>null</code>,这样的话容易出现<code>java.lang.NullPointerException</code>异常，使用可变参数便可以有效避免传入参数为<code>null</code>的问题，就算不传值，它编译后也是一个空数组</p>
<h5 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h5><h6 id="基本类型参数绑定"><a href="#基本类型参数绑定" class="headerlink" title="基本类型参数绑定"></a>基本类型参数绑定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        int age =15;
        Person person = new Person();
        person.setAge(age);
        System.out.println(person.getAge());//15
        age = 20;
        System.out.println(person.getAge());//15
    &#125;
&#125;
class Person&#123;
    private int age;
    public void setAge(int age)&#123;
        this.age = age;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
&#125;
</code></pre>
<p>运行代码，看结果可知，在<code>age赋值为15</code>后传入<code>Person</code>的<code>setAge()</code>方法,第一次通过<code>getAge()</code>方法获取<code>person实例</code>的age的值是15，在Main类的age重新赋值为20后再次调用<code>person实例</code>的<code>getAge()</code>方法，得到的值依旧是15</p>
<p>原因是<code>setAge()</code>方法获得的参数，复制了<code>age</code>的值，<code>person实例</code>的age和<code>Main类</code>的age的值得修改互不影响</p>
<h6 id="引用类型参数绑定"><a href="#引用类型参数绑定" class="headerlink" title="引用类型参数绑定"></a>引用类型参数绑定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] fullName = new String[]&#123;&quot;xcc&quot;,&quot;xccit&quot;,&quot;ywx&quot;&#125;;
        Person p = new Person();
        p.setNames(fullName);
        System.out.println(p.getName());//xcc xccit
        fullName[0] = &quot;JamesY&quot;;
        System.out.println(p.getName());//JamesY xccit
    &#125;
&#125;
class Person&#123;
    private String[] names;

    public void setNames(String[] names)&#123;
        this.names = names;
    &#125;
    public String getName()&#123;
        return this.names[0] + &quot; &quot; + this.names[1];
    &#125;
&#125;
</code></pre>
<p>注意<code>setNames()</code>传入的参数是一个数组，将数组传入<code>setNames()</code>后，修改<code>fullName</code>的内容，对象的<code>names</code>也被修改</p>
<p>结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</p>
<h6 id="特殊的引用类型参数绑定"><a href="#特殊的引用类型参数绑定" class="headerlink" title="特殊的引用类型参数绑定"></a>特殊的引用类型参数绑定</h6><p>有了上个引用类型参数绑定的案例，再看看另外一个:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String name = &quot;Bob&quot;;
        Person person = new Person();
        person.setName(name);
        System.out.println(person.getName());//Bob
        name = &quot;James&quot;;
        System.out.println(person.getName());//Bob
    &#125;
&#125;
class Person&#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>这里参数使用<code>String</code>类型，在参数被修改后对象的<code>name</code>并没有被改变，原因在哪呢？</p>
<p>看一下这份代码的运行结果：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        String name = &quot;Bob&quot;;
        Person person = new Person();
        person.setName(name);
        System.out.println(person.getName());//Bob
        System.out.println(name == person.getName());//true
        name = &quot;James&quot;;
        System.out.println(person.getName());//Bob
        System.out.println(name == person.getName());//false
    &#125;
&#125;
class Person&#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p><code>==</code>在对诸如<code>String、Date</code>这种引用类型对象比较时，比较的是<code>内存地址</code>，在改变<code>name</code>的值后内存地址也发生了改变，<code>name</code>和<code>person对象的name</code>指向不同的地址，<code>person</code>依旧指向内存中的<code>Bob</code>,而<code>name</code>已经指向了一个新的值<code>James</code>，他们指向的地址不同，所以对应的值也不同，所以就会出现第一次给<code>person.setName()</code>指向name的值<code>Bob</code>不会被改变的状态。</p>
<p>简而言之，第一次给<code>person的name赋值为&quot;Bob&quot;</code>，在Main中的name值被改变后，Main中的name的值指向一个新的地址”James”,而<code>person的name</code>依旧指向”Bob”</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装概念"><a href="#封装概念" class="headerlink" title="封装概念"></a>封装概念</h4><p>封装就是将类的属性及实现方式隐藏起来，对外提供一个方法进行访问而不是直接访问，通常对参数使用<code>private</code>,并且提供<code>getter/setter</code>方法进行访问</p>
<h4 id="参数私密性"><a href="#参数私密性" class="headerlink" title="参数私密性"></a>参数私密性</h4><p>Computer.java</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>上面的类就对属性使用了private修饰符，使属性不能被直接调用，要使用参数必须调用参数对应的<code>getter/setter</code>方法</p>
<p>Main.java</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();
        computer.setCode(10);
        System.out.println(computer.getCode());//10
    &#125;
&#125;
</code></pre>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><p>无参构造实际上我们前面一直在用：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();//初始化对象时这种操作默认就是无参构造
        computer.setCode(10);
        System.out.println(computer.getCode());//10
    &#125;
&#125;
</code></pre>
<p>而对于Computer类来讲，无参构造也是默认存在的:</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer() &#123;//无参构造方法
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>Computer这两份代码实际上就是一模一样的，只是一个没写无参构造方法，一个写了无参构造方法</p>
<h5 id="带参构造"><a href="#带参构造" class="headerlink" title="带参构造"></a>带参构造</h5><p>无参构造貌似并没有感受到什么变化，带参构造就有变化了，我们初始化对象后要对其属性赋值，必须一个个使用<code>setter</code>方法赋值，而带参构造就是为了解决这个问题，在初始化对象时直接对属性赋值：</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer() &#123;//无参构造
    &#125;

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer(10,&quot;i7-7300HQ&quot;,true);
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<p>这样在对象初始化时，直接对属性赋值，但请注意:传值的顺序必须与括号内属性的顺序一致</p>
<p>要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p>
<pre><code class="java">public class Computer &#123;
    private int code;
    private String cpu;
    private boolean isNevdia;

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<p>这段代码去掉了无参构造方法，只有带参构造,像以前一样直接<code>new Computer();</code>就会报错</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();//编译报错
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<p>看一下控制台:</p>
<pre><code class="java">E:\IdeaProjects\JavaSE\src\com\oop\base\Main.java:7:29
java: 无法将类 com.oop.base.Computer中的构造器 Computer应用到给定类型;
  需要: int,java.lang.String,boolean
  找到:    没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<p>如果既想使用没有参数的构造方法，又想使用带参数的构造方法，那么只能把两种方法都定义出来</p>
<h5 id="带参函数参数初始化注意事项"><a href="#带参函数参数初始化注意事项" class="headerlink" title="带参函数参数初始化注意事项"></a>带参函数参数初始化注意事项</h5><h6 id="对象属性的最终值由构造函数决定"><a href="#对象属性的最终值由构造函数决定" class="headerlink" title="对象属性的最终值由构造函数决定"></a>对象属性的最终值由构造函数决定</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer(10,&quot;i7-7300HQ&quot;,true);
        System.out.println(computer.getCode()+&quot; &quot;+computer.getCpu()+&quot; &quot;+computer.isNevdia());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Computer &#123;
    /*参数已经被初始化*/
    private int code = 20;
    private String cpu = &quot;R900&quot;;
    private boolean isNevdia = false;

/*    public Computer() &#123;//无参构造
    &#125;*/

    public Computer(int code, String cpu, boolean isNevdia) &#123;//带参构造
        this.code = code;
        this.cpu = cpu;
        this.isNevdia = isNevdia;
    &#125;

    public int getCode() &#123;
        return code;
    &#125;

    public void setCode(int code) &#123;
        this.code = code;
    &#125;

    public String getCpu() &#123;
        return cpu;
    &#125;

    public void setCpu(String cpu) &#123;
        this.cpu = cpu;
    &#125;

    public boolean isNevdia() &#123;
        return isNevdia;
    &#125;

    public void setNevdia(boolean nevdia) &#123;
        isNevdia = nevdia;
    &#125;
&#125;
</code></pre>
<h5 id="多构造方法"><a href="#多构造方法" class="headerlink" title="多构造方法"></a>多构造方法</h5><p>Java可以定义多个构造方法，在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Person();//调用Person()
        Person person1 = new Person(&quot;xccit&quot;);//调用Person(String name)
        Person person2 = new Person(&quot;xccit&quot;,20);//调用Person(String name,int age)
    &#125;
&#125;
class Person&#123;
    private int age;
    private String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);//调用Person(String name)
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);//调用Person(String name,int age)
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>另外各构造方法之间可以使用<code>this</code>进行调用，这样做的好处就是可以<code>代码复用</code>，具体的自己测试即可</p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>在一个类中，如果有功能相同但参数不同的方法，可以把这些方法以同名定义，称为<code>同名方法</code>，方法后面的参数替换掉即可，这就是方法重载</p>
<pre><code class="java">public class Hello &#123;

    public void hello()&#123;//第一个hello方法
        System.out.println(&quot;Hello&quot;);
    &#125;
    public void hello(String name)&#123;//第二个hello方法
        System.out.println(&quot;Hello&quot;+name);
    &#125;
    public void hello(String[] names)&#123;//第三个hello方法
        System.out.println(&quot;Hello&quot;+ Arrays.toString(names));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
       Hello h = new Hello();
       h.hello();//调用第一个hello()
       h.hello(&quot;小昕&quot;);//调用第二个hello()
       h.hello(new String[]&#123;&quot;小昕&quot;,&quot;小明&quot;,&quot;小军&quot;&#125;);//调用第三个hello()
    &#125;
&#125;
</code></pre>
<p>注意：方法重载的返回值类型通常都是相同的。</p>
<p>方法重载的目的是：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>举个栗子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p>
<ul>
<li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li>
<li><code>int indexOf(String str)</code>：根据字符串查找；</li>
<li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li>
<li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h4><p>如果有一些功能相同的类，并且在使用时不想二次写代码或者CTRL CV，那么这个时候<code>继承</code>就派上用场了,继承关键字是<code>extends</code></p>
<p>以Person类举个栗子：</p>
<pre><code class="java">public class Person &#123;
    private int age;
    private String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>这个时候新建一个类为:Student.java 继承Person</p>
<pre><code class="java">public class Student extends Person&#123;
    
&#125;
</code></pre>
<p>这个时候在Main.java中new一个Student实例：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211024135640149.png" alt="image-20211024135640149"></p>
<p>这个时候new的Student已经可以使用Person的所有方法</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Student student = new Student();
        student.setAge(20);
        student.setName(&quot;xccit&quot;);
        System.out.println(student);
    &#125;
&#125;
</code></pre>
<p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>
<p>想让Student实现新功能，只需要给它编写新功能即可：</p>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello(String name)&#123;//新功能，说一句Hello xxx
        System.out.println(&quot;Hello&quot;+name);
    &#125;
&#125;
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211024140543769.png" alt="image-20211024140543769"></p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）</p>
<p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>
<pre><code class="ascii">┌───────────┐
│  Object   │
└───────────┘
      ▲
      │
┌───────────┐
│  Person   │
└───────────┘
      ▲
      │
┌───────────┐
│  Student  │
└───────────┘
</code></pre>
<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p>
<pre><code class="ascii">┌───────────┐
       │  Object   │
       └───────────┘
             ▲
             │
       ┌───────────┐
       │  Person   │
       └───────────┘
          ▲     ▲
          │     │
          │     │
┌───────────┐ ┌───────────┐
│  Student  │ │  Teacher  │
└───────────┘ └───────────┘
</code></pre>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段,这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问:</p>
<pre><code class="java">public class Person &#123;
    protected int age;
    protected String name;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    Person()&#123;
        this(&quot;ywx&quot;);
    &#125;
    Person(String name)&#123;
        this(&quot;ywx&quot;,20);
    &#125;
    Person(String name,int age)&#123;
        this.age = age;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;+name);//这里的name就是父类的name字段
    &#125;
&#125;
</code></pre>
<p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</p>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>，例如：</p>
<pre><code class="java">public class Student extends Person&#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;+super.name);//这里的super.name就是父类的name字段
    &#125;
&#125;
</code></pre>
<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>但是，在某些时候，就必须使用<code>super</code>,举个栗子：</p>
<pre><code class="java">public class Person &#123;
    protected int age;
    protected String name;

    public Person(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        this.score = score;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Student student = new Student(20,&quot;xccit&quot;,100);
        System.out.println(student);
    &#125;
&#125;
</code></pre>
<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法:</p>
<pre><code class="java">java: 无法将类 com.oop.extend.Person中的构造器 Person应用到给定类型;
  需要: int,java.lang.String
  找到:    没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        super();//自动调用父类的构造方法
        this.score = score;
    &#125;
&#125;
</code></pre>
<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>
<pre><code class="java">public class Student extends Person&#123;
    protected int score;

    public Student(int age, String name, int score) &#123;
        super(age,name);//自动调用父类的构造方法
        this.score = score;
    &#125;
&#125;
</code></pre>
<p>这样就可以正常编译了,因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<p>这里还顺带引出了另一个问题：<code>即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</code></p>
<h4 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h4><p>当一个类使用<code>final</code>关键字修饰时，它就不可被继承，如果只想指定类继承它，在Java15中新出两个关键字可以完美解决此需求:</p>
<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称：</p>
<pre><code class="java">public sealed class Person permits Student,Teacher,Engineer&#123;
    //现在的Person类就是一个sealed类，通过permits关键字只允许被Student,Teacher,Engineer类继承
&#125;
</code></pre>
<p>如果使用Student继承Person可以这么写:</p>
<pre><code class="java">public final class Student extends Person&#123;
    
&#125;
</code></pre>
<p>而如果使用一个未被permits关键字修饰的类继承Person就会报错，例如:</p>
<pre><code class="java">public final class People&#123;
    
&#125;
</code></pre>
<p>这种机制主要用于一些框架，防止继承被滥用，最典型的框架便是<code>Spring</code></p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>在使用Java的继承时，可以使用<code>父类</code>类型的变量接收<code>子类</code>类型的实例，但不允许使用<code>子类类型变量接收父类实例</code>：</p>
<p>举个栗子：Student类继承自Person类</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person p = new Student();//允许
        Student stu = new Person();//禁止，也是错误的
    &#125;
&#125;
</code></pre>
<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>向下转型跟向上转型完全相反，向下转型是将<code>父类类型实例使用子类类型变量接收</code></p>
<p>举个栗子:Student类继承自Person类</p>
<pre><code class="java">public class Main()&#123;
    public static void main(String[] args)&#123;
        Person p1 = new Person();
        Person p2 = new Student();
        Student stu1 = (Student) p1;//运行时异常，ClassCastException
        Student stu2 = (Student) p2;//运行成功
    &#125;
&#125;
</code></pre>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code></p>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<pre><code class="java">Person p = new Person();
System.out.println(p instanceof Person); // true
System.out.println(p instanceof Student); // false

Student s = new Student();
System.out.println(s instanceof Person); // true
System.out.println(s instanceof Student); // true

Student n = null;
System.out.println(n instanceof Student); // false
</code></pre>
<p>如果测试结果为false,在写代码时一定不要用<code>instanceof</code>操作符左边的类型转换成操作符右边的类型</p>
<p>instanceof<code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为</code>null<code>，那么对任何</code>instanceof<code>的判断都为</code>false</p>
<p>所以建议在进行类型转换操作时，可以使用<code>instanceof</code>进行判断，结果为<code>true</code>后再进行转换</p>
<pre><code class="java">public class Main&#123;
    public static void main(String[] args)&#123;
        Person person = new Student();
        if(person instanceof Student)&#123;//只有判断成功才会向下转型
            Student stu = (Student) person;//转型一定成功！
        &#125;
    &#125;
&#125;
</code></pre>
<p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。举个栗子：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Object obj = &quot;I am a String!&quot;;//Object是一切类的超类
        if(obj instanceof String)&#123;
            String str = (String) obj;
            System.out.println(str.toUpperCase());//可以调用String的方法
        &#125;
    &#125;
&#125;
</code></pre>
<p>上一份代码还可以这么改：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Object obj = &quot;I am a String!&quot;;//Object是一切类的超类
        if(obj instanceof String str)&#123;
            System.out.println(str.toUpperCase());//可以调用String的方法
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p><code>继承</code>和<code>组合</code>说起来容易，理解起来可能稍微有点难，特别是对基础并不扎实的童鞋来讲，可能只会写代码，并不知道这么写的意义在哪：</p>
<p>举个栗子:</p>
<p>给出三个类：Person,Student,Book</p>
<p>Person和Student是<code>is</code>关系，Student属于Person的一种，或者可以这么理解:人有很多种职业，按职业区分说这个人是程序员，那个人是学生，老师，白领… 所以在这个基础上，Student继承自Person，写法为:</p>
<pre><code class="java">public class Student extends Person&#123;
    
&#125;
</code></pre>
<p>而Book和Student呢？学生需要读书，都有什么书呢？比如语文，数学，英语，那么相应的每一本书属于某个同学，所以Book和Student属于<code>has</code>关系，用代码可以这么写：</p>
<pre><code class="java">public class Student &#123;
    private Book book;//Book属于Student
&#125;
</code></pre>
<p>因此继承是is关系，组合是has关系</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="方法重写（覆写）"><a href="#方法重写（覆写）" class="headerlink" title="方法重写（覆写）"></a>方法重写（覆写）</h4><p>在封装中说过方法重载，多态中又要说方法重写:</p>
<p>举个栗子:Person和Student</p>
<pre><code class="java">public class Person&#123;
    public void run()&#123;
        System.out.print(&quot;Person.run&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    public void run()&#123;//重写父类run方法
        System.out.print(&quot;Student.run&quot;);
    &#125;
&#125;
</code></pre>
<p>重写和重载的概念要分清：子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）</p>
<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
<pre><code class="java">class Person &#123;
    public void run() &#123; … &#125;
&#125;

class Student extends Person &#123;
    // 不是Override，因为参数不同:
    public void run(String s) &#123; … &#125;
    // 不是Override，因为返回值不同:
    public int run() &#123; … &#125;
&#125;
</code></pre>
<h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p>
<pre><code class="java">public class Person &#123;
    public void run()&#123;
        System.out.println(&quot;Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    @Override
    public void run(String s)&#123;//运行失败！因为重写的方法参数不同
        System.out.println(&quot;Run!&quot;);
    &#125;
&#125;
</code></pre>
<p>正确写法：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211025111155821.png" alt="image-20211025111155821"></p>
<p>另外，如果手动重写方法并且代码正确，**@Override<strong>并不是必需的，</strong>@Override**只是会在代码编写阶段帮助我们验证是否正确重写方法</p>
<h5 id="调用谁的方法"><a href="#调用谁的方法" class="headerlink" title="调用谁的方法"></a>调用谁的方法</h5><p>在前面我们使用了<code>父类类型 变量 = new 子类类型();</code>，在使用这种方法创建子类实例后覆写其父类方法，运行时调用其父类方法还是子类自身的方法：</p>
<pre><code class="java">public class Person &#123;
    public void run()&#123;
        System.out.println(&quot;Person.Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student extends Person&#123;
    @Override
    public void run()&#123;
        System.out.println(&quot;Student.Run!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Student();//父类new子类
        person.run();//调用该方法
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211025111900808.png" alt="image-20211025111900808"></p>
<p>事实证明依旧会调用子类自身的方法，得出结论：Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<p>这个非常重要的特性在面向对象编程中称之为<code>多态</code>。它的英文拼写非常复杂：<code>Polymorphic</code>。</p>
<h4 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h4><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
<p>那如果按上面的例子，有这么一个方法:</p>
<pre><code class="java">public void runTeice(Person p)&#123;
    p.run();
    p.run();
&#125;
</code></pre>
<p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>
<p>举个栗子:</p>
<p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p>
<pre><code class="java">class Income&#123;
    protected double income;
    public double getTax()&#123;
        return income*0.1;//税率10%
    &#125;
&#125;
</code></pre>
<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p>
<pre><code class="java">class Salary extends Income&#123;
    @Override
    public double getTax() &#123;
        if(income &lt; 5000)&#123;
            return 0;
        &#125;
        return (income - 5000) * 0.1;
    &#125;
&#125;
</code></pre>
<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<pre><code class="java">class StateCouncilSpecialAllowance extends Income&#123;
    @Override
    public double getTax() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<pre><code class="java">public double totalTax(Income... incomes) &#123;
    double total = 0;
    for (Income income: incomes) &#123;
        total = total + income.getTax();
    &#125;
    return total;
&#125;
</code></pre>
<p>整体代码:</p>
<pre><code class="java">package com.oop.polymorphic;

/**
 * @author Administrator_Xcc
 */
public class Main &#123;
    public static void main(String[] args) &#123;
        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:
        Income[] incomes = new Income[]&#123;
                new Income(3000),//300
                new Salary(7500),//250
                new StateCouncilSpecialAllowance(10000)//0
        &#125;;
        System.out.println(totalTax(incomes));
    &#125;
    public static double totalTax(Income... incomes) &#123;
        double total = 0;
        for (Income income: incomes) &#123;
            total += income.getTax();
        &#125;
        return total;
    &#125;
&#125;
class Income&#123;
    protected double income;
    public Income(double income)&#123;this.income = income;&#125;
    public double getTax()&#123;
        return income*0.1;//税率10%
    &#125;
&#125;
class Salary extends Income&#123;
    public Salary(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        if(income &lt; 5000)&#123;
            return 0;
        &#125;
        return (income - 5000) * 0.1;
    &#125;
&#125;
class StateCouncilSpecialAllowance extends Income&#123;
    public StateCouncilSpecialAllowance(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>
<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
<h4 id="重写Object方法"><a href="#重写Object方法" class="headerlink" title="重写Object方法"></a>重写Object方法</h4><p>Java有一个超类叫做<code>Object</code>，Object中定义了几个重要方法：</p>
<ul>
<li><code>toString()</code>:将实例对象以<code>String</code>输出，如不重写此方法会输出该实例内存地址</li>
<li><code>equals()</code>:判断两个实例是否逻辑相等</li>
<li><code>hashCode()</code>:计算实例的hash值</li>
</ul>
<p>在很多时候我们都会用到这几个方法:</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        Person person = new Person();
        person.name = &quot;xcc&quot;;
        System.out.println(person.hashCode());
        System.out.println(person);
    &#125;
&#125;
class Person&#123;
    protected String name;

    @Override
    public int hashCode() &#123;
        return this.name.hashCode();
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if(obj instanceof Person)&#123;
            Person p = (Person) obj;
            return this.name.equals(p.name);
        &#125;
        return false;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person:name=&quot;+name;
    &#125;
&#125;
</code></pre>
<h4 id="调用super方法"><a href="#调用super方法" class="headerlink" title="调用super方法"></a>调用super方法</h4><p>在子类需要调用父类被重写的方法时，可以使用<code>super</code></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
       Person person = new Student();
       person.name = &quot;Xcc&quot;;
        System.out.println(person.hello());
    &#125;
&#125;
class Person &#123;
    protected String name;
    public String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

class Student extends Person &#123;
@Override
    public String hello() &#123;
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p>
<pre><code class="java">class Person&#123;
    protected String name;
    public final String hello()&#123;
        return &quot;Hello&quot;+name;
    &#125;
&#125;
class Student extends Person&#123;
    
    @Override
    public String hello()&#123;
        //compile error :不允许重写
    &#125;
&#125;
</code></pre>
<p>除此以外:</p>
<ul>
<li>一个类不想被继承，也可以在该类名前加上final</li>
<li>一个字段的值不想被修改，可以加上final</li>
<li><strong>可以在构造方法中初始化字段，这种方法很实用，可以保证实例一旦被创建，其被final修改的字段就不可以改变：</strong></li>
</ul>
<pre><code class="java">class Person&#123;
    public final String name;
    Person(String name)&#123;
        //构造方法中将name初始化
        this.name = name;
    &#125;
&#125;
</code></pre>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>由于多态的特性，每个子类都可以覆写父类的方法：</p>
<pre><code class="java">class Person &#123;
    protected String name;
    public String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

class Student extends Person &#123;
@Override
    public String hello() &#123;
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    &#125;
&#125;
</code></pre>
<p>如果父类的方法没有实际意义，可否去掉方法的执行语句？</p>
<pre><code class="java">class Person&#123;
    public String hello();//没有执行语句
&#125;
</code></pre>
<p>那么这么写肯定不行，编译会报错，可以讲&#x3D;将方法定义为抽象方法吗？</p>
<pre><code class="java">class Person&#123;
    public abstract String hello();//没有执行语句
&#125;
</code></pre>
<p>这样子也不行，会导致Person类无法编译。</p>
<p>这个时候抽象类的作用就出来了，把不需要写实际执行代码的方法写进抽象类，这样既可保证类正常编译，又能减轻代码量。</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216223854115.png" alt="image-20211216223854115" style="zoom:50%;" />

<h4 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h4><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<pre><code class="java">Person s = new Student();
Person t = new Teacher();
</code></pre>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<pre><code class="java">//不用关心Person变量的子类类型
t.hello();
s.hello();
</code></pre>
<p>同样，如果新建一个类继承了Person，我们仍然不用关心Person类型变量的具体子类类型：</p>
<pre><code class="java">Person e = new Employee();
e.run();
</code></pre>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>抽象类的本质就是一个高层类，即定义一个接口规范，让继承它的类都使用同一个接口规范，如果这个抽象类中没有任何字段，所有方法都是抽象方法，那么这个类可以使用<code>接口</code>代替，也就是<code>interface</code>：</p>
<p>abstract class:</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224118794.png" alt="image-20211216224118794" style="zoom:50%;" />

<p>interface:</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224525393.png" alt="image-20211216224525393" style="zoom:50%;" />

<p>抽象类中子类使用<code>extends</code>字段继承该类后可使用该类的所有方法，在接口中，子类需使用<code>implements</code>实现该接口：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216224830958.png" alt="image-20211216224830958" style="zoom:50%;" />

<p>其次在Java中，一个类只可以继承一个类，但一个类可以实现多个接口：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216225041644.png" alt="image-20211216225041644" style="zoom:50%;" />

<p>这样的话，Hello这个接口中有什么方法，Student类也必须重写该接口的方法，不然编译器就会报错：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211216225239543.png" alt="image-20211216225239543"></p>
<p>未实现Hello接口的方法，编译器提示报错。</p>
<h4 id="Java接口和编程接口"><a href="#Java接口和编程接口" class="headerlink" title="Java接口和编程接口"></a>Java接口和编程接口</h4><p>Java接口泛指<code>intrface</code>的定义，表示一组接口类型和一组方法签名，编程接口泛指接口规范，比如方法签名，数据格式，网络协议等。</p>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>Person.java</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217133240926.png" alt="image-20211217133240926" style="zoom:50%;" />

<p>此时<code>Person</code>接口继承了<code>Hello</code>，<code>Hello</code>接口的方法也会一并继承下去，在有子类实现了<code>Person</code>接口时，也要一并实现<code>Hello</code>接口的方法：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217133529259.png" alt="image-20211217133529259" style="zoom:50%;" />

<p>在使用时，实例化的对象永远是一个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217172801420.png" alt="image-20211217172801420" style="zoom:50%;" />

<h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>在接口中，可以自定义<code>default</code>方法：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173242630.png" alt="image-20211217173242630" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173542446.png" alt="image-20211217173542446" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211217173711380.png" alt="image-20211217173711380" style="zoom:50%;" />

<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p>关于静态方法，前面在方法已经轻微提到过，本章着重讲解</p>
<h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>在一个<code>class</code>中定义的字段，称为<code>实例字段</code>，每个实例调用时都互不干扰，但是还有一种带<code>static</code>的字段，称为<code>静态字段（static field）</code>,静态字段在内存中有一块独立的区域，所有实例都会共享该字段,举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224185153367.png" alt="image-20211224185153367" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224190545524.png" alt="image-20211224190545524" style="zoom: 46%;" />



<p>最终的运行结果也是：</p>
<pre><code class="java">90
80
</code></pre>
<p>原因是st1实例和st2实例都属于<code>StaticTest</code>类，<code>num</code>字段也属于<code>StaticTest</code>类，所以使用<code>st1.num=90</code>给num赋值就相当于：所有这个类的实例调用num时都是同一个值，而这个值被某个实例调用时改变后，其他实例调用同样也是这个值。虽然实例可以访问静态字段，但是它们指向的其实都是<code>StaticTest</code>的静态字段。所以，所有实例共享一个静态字段。</p>
<p>而对于上述代码，其实更好写的方式是：</p>
<pre><code class="java">StaticTest.num = 90;
</code></pre>
<p>直接拿类名调用字段看起来更清晰，也更好理解。</p>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法同样使用一个类名就可以调用，举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224192336696.png" alt="image-20211224192336696" style="zoom:50%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224192403848.png" alt="image-20211224192403848" style="zoom:50%;" />

<p>因为静态方法同样属于<code>StaticTest</code>类而不属于某个实例，所以静态方法无法访问实例字段及<code>this.字段</code>，静态方法只能访问静态字段，通过某个实例也可以调用静态方法，编译器会自动将实例名称变为类名，正常情况下使用实例变量调用静态方法会收到编译器的警告：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224200915126.png" alt="image-20211224200915126"></p>
<p>虽然会警告，但是程序可以正常运行，所以建议使用<code>类名.静态方法</code></p>
<h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>一般来讲，接口做为一种纯抽象类，它不能定义实例字段，但可以定义静态字段，但静态字段必须是<code>final</code>类型，举个栗子：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224201558286.png" alt="image-20211224201558286" style="zoom:50%;" />

<p>但其实编译器会自动加上前面的关键字，所以这段代码的简写形式为：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224201658652.png" alt="image-20211224201658652" style="zoom:50%;" />

<p>拓展：使用Java静态字段和静态方法统计实例创建次数：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224202607960.png" alt="image-20211224202607960" style="zoom:49%;" />

<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224202523488.png" alt="image-20211224202523488" style="zoom:50%;" />

<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包名的定义规范"><a href="#包名的定义规范" class="headerlink" title="包名的定义规范"></a>包名的定义规范</h4><p>包名在定义时，一般使用项目域名的倒置写法，比如有一个web项目的域名是:<code>https://xccit.io</code>,那么这个项目的包名在命名时，就是这样的：<code>io.xccit.*</code></p>
<p>在后面使用<code>MVC</code>开发模式时，会有分层开发模式，而这个时候包名就会这么写：</p>
<p>M层：<code>io.xccit.model</code>(大多数会使用dao，这儿是举个栗子)</p>
<p>V层：<code>io.xccit.view</code></p>
<p>C层：<code>io.xccit.controller</code></p>
<p>看下我在举个栗子的时候写的包名：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224203456444.png" alt="image-20211224203456444"></p>
<p>项目名为：JavaSE</p>
<p>包名顶层为:com</p>
<p>com下有2个包：<code>base </code> <code>oop</code></p>
<p>base下只有三个类</p>
<p>oop下又有5个包：<code>base</code> <code>extend</code> <code>interfaces</code> <code>polymorphic</code> <code>statictest</code></p>
<p>这些包层层深入，里面有不同的类，类与类之间可以根据权限修饰符互相访问</p>
<p>参考另一个web项目的包：</p>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224204009559.png" alt="image-20211224204009559"></p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h4><p>一个类定义在另一个类的内部，这个类就叫做内部类：</p>
<img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20211224205315948.png" alt="image-20211224205315948" style="zoom:50%;" />

<p>这里可以发现Outer十一个正常存在的类，而Inner是一个内部类，内部类必须依附外围的内存在，也就是Outer，这里可以看到Inner在创建时前面还有一个<code>Outer.</code>，而且创建后的<code>inner</code>实例成功访问到了Outer的<code>private</code>字段，因为Inner在Outer内部，所以可以访问Outer中使用<code>private</code>修饰的字段和方法。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>还有一种定义内部类的方法，它不需要在<code>Outer</code>中明确定义，而是在<code>Outer</code>的方法中通过<code>匿名内部类</code>来定义：</p>
<pre><code class="java">public class InnerTest()&#123;
    public static void main(String args[])&#123;
        new Outer(&quot;xccit&quot;).asyncHello();
    &#125;
    class Outer&#123;
    private String name;
    public Outer(String name)&#123;
        this.name = name;
    &#125;

    void asyncHello()&#123;
        Runnable r = new Runnable()&#123;
            @Override
            public void run()&#123;
                System.out.println(&quot;Hello &quot;+Outer.this.name);
            &#125;
        &#125;;
        new Thread(r).start();
    &#125;
&#125;
&#125;
</code></pre>
<p>通过实现一个<code>Runnable</code>接口的实例来体现出匿名内部类。</p>
<p>除此之外，匿名内部类还可以继承自普通类：</p>
<pre><code class="java">public class InnerTest &#123;
    public static void main(String[] args) &#123;
        HashMap&lt;String, Object&gt; map1 = new HashMap&lt;&gt;();
        HashMap&lt;String, Object&gt; map2 = new HashMap&lt;&gt;()&#123;&#125;;//匿名类
        HashMap&lt;String, Object&gt; map3 = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;Key1&quot;,&quot;Value1&quot;);
                put(&quot;Key2&quot;,&quot;Value2&quot;);
                put(&quot;Key3&quot;,&quot;Value3&quot;);
            &#125;
        &#125;;
        System.out.println(map3.get(&quot;Key1&quot;));
    &#125;
&#125;
</code></pre>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是在原来内部类的基础上加了<code>static</code>关键字，它不再依附于<code>Outer</code>，所以不会再使用<code>Outer.this</code>来引用，并且它还可以访问Outer的private静态字段和方法，但作用域仅在<code>Outer</code>类。</p>
<pre><code class="java">/**
 * 测试静态内部类
 * @author xccit
 */
public class StaticInnerClass &#123;
    public static void main(String[] args) &#123;
        Outerr.Innerr in = new Outerr.Innerr();
        in.sayHello();
    &#125;
&#125;

class Outerr&#123;
    static String NAME = &quot;xccit&quot;;
    private String name;
    public Outerr(String name)&#123;
        this.name = name;
    &#125;

    static class Innerr&#123;
        void sayHello()&#123;
            System.out.println(&quot;Hello &quot;+Outerr.NAME);
        &#125;
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #ff7d73">Java</a>
        </span>
        
    </div>
    <a href="/2024/08/08/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/08/08/Linux%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/">
        <h2 class="post-title">Linux挂载光盘安装软件</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="挂载光盘安装Linux软件包"><a href="#挂载光盘安装Linux软件包" class="headerlink" title="挂载光盘安装Linux软件包"></a>挂载光盘安装Linux软件包</h1><pre><code class="shell">mkdir /media/CentOS
mount -t /dev/cdrom /media/CentOS
df -HT
cd /etc/yum.repos.d/
mkdir ./bak
mv ./*.repo ./bak/
cp ./bak/CentOS-Media.repo .
vim CentOS-Media.repo
</code></pre>
<p>更改后的文件:</p>
<pre><code class="shell"># CentOS-Media.repo
#
#  This repo can be used with mounted DVD media, verify the mount point for
#  CentOS-7.  You can use this repo and yum to install items directly off the
#  DVD ISO that we release.
#
# To use this repo, put in your DVD and use it with the other repos too:
#  yum --enablerepo=c7-media [command]
#  
# or for ONLY the media repo, do this:
#
#  yum --disablerepo=\* --enablerepo=c7-media [command]

[c7-media]
name=CentOS-$releasever - Media
baseurl=file:///media/CentOS7/  ---需要改的地方，挂载的光驱
gpgcheck=1
enabled=1 ---从0改到1开启光驱
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

~                                                                               
~                                                                               
~                                                
</code></pre>
<p> 依次执行以下命令:  </p>
<pre><code class="shell">yum clean all
yum repolist
yum install ftp
</code></pre>
<h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><pre><code class="shell">yum install telnet telnet-server xinetd
service xinetd start
vim /etc/xinetd.d/telnet
</code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/xccit/blog_images/images_resource/image-20210415185927765.png" alt="image-20210415185927765"></p>
<pre><code class="shell">service xinetd restart
</code></pre>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><pre><code class="shell">yum install sshd  / openssh*
service sshd start
</code></pre>
<h2 id="Vsftpd"><a href="#Vsftpd" class="headerlink" title="Vsftpd"></a>Vsftpd</h2><pre><code class="shell">yum install vsftpd
service vsftpd start
iptables -I INPUT -p tcp 21 --dport -j ACCEPT
iptables -I INPUT -p udp 21 --dport -j ACCEPT
vim /etc/vsftpd/vsftpd.conf,修改anonymous_enable = NO  --禁止匿名用户登陆
去掉chroot_local_user = yes前的注释，限制用户访问家目录之外的地方
</code></pre>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><pre><code class="shell">yum install mysql mysql-server mysql-devel
service mysqld start
mysql -u root password &#39;password&#39;   --给mysql的root用户设置密码
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Linux/" style="color: #ffa2c4">Linux</a>
        </span>
        
    </div>
    <a href="/2024/08/08/Linux%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">
        2
    </a>
    
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/myavatar.jpg" alt="avatar" />
        </div>
        <div class="name">CH_ywx</div>
        <div class="description">
            <p>贩卖温柔の優しさを振りまく<br>   QQ: 1571466236<br>WECHAT: lucky_all_time_max</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 xccitのblog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;CH_ywx
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
